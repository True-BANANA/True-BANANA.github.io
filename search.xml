<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>博客迁移通知</title>
      <link href="/2020/07/28/2020-07-28-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E9%80%9A%E7%9F%A5/"/>
      <url>/2020/07/28/2020-07-28-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E9%80%9A%E7%9F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="RenaMoe’s-Blog"><a href="#RenaMoe’s-Blog" class="headerlink" title="RenaMoe’s Blog"></a><a href="https://renamoe.gitee.io" target="_blank" rel="noopener">RenaMoe’s Blog</a></h1><p>我在 gitee 搭了一个新 blog</p><p>访问速度更快，主题也更新了</p><p>欢迎访问和添加友链！</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>回顾我的初中oi生涯</title>
      <link href="/2020/04/07/2020-04-07-%E5%9B%9E%E9%A1%BE%E6%88%91%E7%9A%84%E5%88%9D%E4%B8%ADoi%E7%94%9F%E6%B6%AF/"/>
      <url>/2020/04/07/2020-04-07-%E5%9B%9E%E9%A1%BE%E6%88%91%E7%9A%84%E5%88%9D%E4%B8%ADoi%E7%94%9F%E6%B6%AF/</url>
      
        <content type="html"><![CDATA[<blockquote><p>声明：本文为博主真实感受，绝无 fake 之言</p><p>每句话加句号可是我很难得的正经语气~</p></blockquote><p>大概 2017 年 8 月，初一前的暑假知道了信息学竞赛，有点兴趣，也没什么概念。</p><p>当时还发现了洛谷这个网站，注册了账号，觉得里面好高深啊（当时连编程语言都不知道是啥），以至于 <a href="https://www.luogu.com.cn/user/52243" target="_blank" rel="noopener">我的洛谷账号</a> 是自豪的五位编号。</p><p>入学石门实验学校（这个我又爱又恨的学校）后，报了个 C 语言的校本课程。当时石门的几乎没有竞赛经验，学校微机老师每周随随便便教一节课，一个学期了 C 语法没学完。第二学期一个德行（甚至还收了钱），初一一道正经题没做过。</p><p>2018 年暑假，二中南校区组织培训，南校教练教大概普及难度，<del>基本是上边念课件下边颓废</del>，不够培训完已经能用 C++ 写题了。记得是一本通 oj 和洛谷上刷了三四十道题（尽是些入门题），也算是真正入门了。</p><p>上了初二，报了 NOIP2018 的普及组，考前两个月组织每天下午有一个多小时专门到小屋子里做题。并不是很努力，一直在吃暑假的老本，每次模拟考还不算垫底，较难的牛客模拟赛天天炸。lym 神犇次次 rk1，orz。十一国庆有个北校的培训，基本听不懂。</p><p>考试发挥还算稳定，拿了186，毕竟到那时我是个搜索还不一定写的对的菜鸡，dp 只写过 01 背包，只是刚初步养成代码思维，t1还写挂了30qwq。万幸的是我在 HE 弱省，1=分数线居然 140！！！</p><p>那年石门有lym、lsq、ljz（我）拿了1=，南校找我们签了约，<del>然而并没有免学费</del>。不过从此开始了我的提高组学习（还啥都不会呢就跟着高一学提高？？？），得到了每周去三次南校机房自习一个多小时的机会。</p><p>我果然是啥都不会啊，2019年的寒假到北校培训，讲的提高组算法（简单的dp、线段树等数据结构、基本的数论线代之类的），然而对我来说是天书。做题量匮乏（就五十多道红橙题）的我相当于一个只会语法的入门菜鸡，听课发呆、课后颓废、考试爆零已经成了习惯。唯一的收获是思维提高了，对各种算法有了初步的印象。lym 太神仙了总是吊打高一学长，初三的 lsq 中途似乎退役学文化课去了</p><p>初二考后的时间基本维持在一个月三四道题的速度，简直毫无长进。</p><p>2019 年的暑假是我 oi 生涯的转折点。</p><p>刚放暑假就去了南校培训，有两天全天自习，恶补了些图论和数学（那时候才会链式前向星和最短路好羞耻），也体验了一天十道题的快感。水平还是很差，会一些黄绿题，蓝题还得看题解。</p><p>因为性格比较慢熟，水平差比较自卑，和高一学长关系比较冷淡，挺孤独的。</p><p>7月北校培训已经是提高组拔高的水平了，我更吃力了，很快就回到了寒假的颓废状态。我发现了自己的致命弱点——做题太少。培训完的时间终于开始养成假期坚持做题的习惯，可还是深深地体会到自己水平的低下。</p><p>后来 rl 教练联系我，问我参不参加准高一的培训，是刚退役的高三学长讲的面向基础的知识。我觉得从基础开始补。说是基础，其实进度很快，高三学长也比较热情地往难讲。在北校的一周对我来说还算轻松，毕竟同机房的高一学长刚会语法，我跟着刷题，提升了不少代码能力和基础算法（搜索、二分之类的）能力。lym 没有参加，落单的我开始结识一些高一的同学。</p><p>到了南校又培训了十几天，难度已经和那年寒假差不多了。自我感觉刚退役的高三学长讲的比老一辈的学长要更易于接受。我虽说浪费了整个初二，但水平也在那个机房属于领先，不由得变得轻浮起来。当时一整天只有下午讲课，可是我变得越来越颓废，一天做不了三四个蓝题，不过长进相比初二快很多。佩服 lhm 刘队长，每天切题十几道，异常的努力。</p><p>南校宿舍管的很松，晚上我便带电脑回宿舍。那时候迷上了动漫电影，每天下载一部晚上看到12点（宿舍没网啊），午休会看两三集下好的番。<del>那时起从阳光的男初中生彻底堕落成恶心死宅</del>。不过因为熬夜，早上经常犯困。而且在机房听歌耳机被没收了<del>好羞耻</del>。</p><p>这次培训让我的oi学习步入了正轨，终于能够把讲的听懂的落实到代码上了。刷题速度也正常了（暑假AC200了）。虽然不是很努力，但也是个不低的起步点。</p><p>8月后面还有北校高二的培训，依旧很难，我又自闭了。<del>番倒是补了不少。</del></p><p>那时 NOIP 取消了，我感觉将来的 oi 生涯可能不会平静了。</p><p>上了初三，文化课压力直线上升。可我还是安排上了一周翘掉两三个晚自习去南校机房，我也成了班里经常性不交作业的人（我的座位在讲台正前面，以至于每天摊开空作业在老师眼皮底下听课）。临近 CSP，我的积极性也提上来了，对自己的要求严格起来。每次去机房都要求自己做两道以上蓝紫题（真是我为数不多的努力时刻）。那段时间渐渐融入了南校高一的机房（存真楼txdy！）。</p><p>其实当时我文化课并没有落下，因为我每天都在因期盼着去机房而努力提高学习效率，要说没有oi我的文化课也好不到哪里去。</p><p>CSP2019 发挥的并不是太好，二百多点分拿了tg2=，<del>pj别提了</del>，详细的看我 <a href="http://localhost:4000/2020/01/17/2020-01-17-CSP2019-游记/" target="_blank" rel="noopener">CSP2019 游记</a>。这次CSP似乎二中发挥的都不太好，据我所知南校高二有不少很强的学长退役了，没退役的分数也不是很理想。回石家庄的路上大家心情都很沉重。</p><p>也许是意识到自己水平差距依然很大，考后我更用功了，虽然我面临着中考这一大难题。那段时间我只能靠努力维持文化课和oi的平衡。开始着手省选难度的内容，不得不说省选范围广难度又大啊。</p><p>期末考前半个月没去机房，虽然期末考了年级前十，心里却很空虚（要是 CSP 有1=多好啊）。</p><p>2020年寒假到北校培训省选内容，高二人数太少了，和第一批高一的一个机房。难度很大，毕竟是针对高二准备省选的学长，再次自闭。</p><p>之前北校培训一直走读，这次住宿还算愉快，经常和南校同机房的出去吃晚饭，一不小心又养成了爱喝奶茶的坏习惯。宿舍管的也不严，晚上总是肝题和推gal到凌晨两三点</p><p>这个寒假不安宁：羟基计划代替了自招，新冠病毒爆发。我初中开始走下坡路的转折点。</p><p>问题是寒假培训第二阶段取消了，学校开学也推迟了。</p><p>恰巧当时饮食和熬夜过于放纵，我感冒了……过年期间还发了一次烧，吓怕我了。不过过两周康复了。</p><p>寒假文化课作业一直翘着，直到网上开学也没交过作业，缓慢地学着oi，这种低效率的状态持续到二月底，班主任打电话过来了。我开始每天完成作业了，但是这意味着要AFO直到中考完。</p><p>HE是中高考大省，竞赛的话高中生可能有二中衡中等强校给你好的条件，初中则没个老师管你竞赛咋样。HE 的oier大多都是高中零基础开始的，这两年也吃了大亏。对于石门来说，啥样的竞赛奖项都不如好的中考成绩实在，<del>这关系到学校的生源和老师的工资</del>。我也是因为文化课没有掉太多，班主任之前没咋管我，但临近中考了，老师家长不愿让一个初三生在分心学oi。更重要的，南校只有中考上了600才免学费，私立的南校的学费一直是不小的负担。</p><p>在家状态极差，完成作业对于我简直是世界难题。最快最快（在课上也偷写作业）也要晚上十点半写完，然而十点就会被催去睡觉。我真是效率低的失败人士（不过作业真的比在学校还多）。这种烂状态咋挤时间学oi？久了也开始颓废了，作业越来越应付了，只是单纯的觉得学习没了奔头。</p><p>我每天看番、推galgame、追轻小说、打osu、刷知乎……然后抄完作业答案对着日历叹息。</p><p>这样下去文化课也学不好吧？我真的忍不了了，四月一号情绪激动地和父母诉说了，在家这样荒废时间还不如再学学oi。班主任也同意了（我当时借口是调整心态）。我仿佛获得了新生，刷题速度一度飙升。</p><p>这样又能维持的了多久？突然又不交作业的我被各科老师催来催去，我这个基本问题全在我身上的理由难以向老师表达。文化课不好好补补中考迟早药丸啊，初三第一学期的老本又能吃多久。期盼着早点开学，等来的却是一次又一次延迟的通知。</p><p>4月9号，决定了全身心回归文化课（线上考试的事情打乱了我要AC350的计划）</p><hr><p>To be continued…</p><p>我不过是一具懒惰的身躯包裹着的脆弱的心灵，回顾我颓废的初中生活，只有无意义的叹息。</p><p>从初中开始学oi，是我曾经的优势，也是我如今的遗憾。</p><p>OI is my faith! 感谢初中有oi相伴，高中我会更加努力的~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>总结 虚树</title>
      <link href="/2020/04/06/2020-04-06-%E6%80%BB%E7%BB%93-%E8%99%9A%E6%A0%91/"/>
      <url>/2020/04/06/2020-04-06-%E6%80%BB%E7%BB%93-%E8%99%9A%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>某些树形dp的数据范围过大，有多次询问，每次询问选定关键点（关键点总和在 1e5~1e6 的范围）</p><p>例题：<a href="https://www.luogu.com.cn/problem/P2495" target="_blank" rel="noopener">P2495 [SDOI2011]消耗战</a></p><p>此时会有很多点不需要参与dp，只要另外建出一棵包含有用点的虚树来</p><p><img src="https://s1.ax1x.com/2020/04/06/Gs98AI.png" alt=""></p><p>有一种增量构造的方法，难写难记（几个月前写的还没调出来），所以我干脆只学本文这种方法</p><p>推荐 <a href="https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p2495" target="_blank" rel="noopener">shadowice1984 的博客</a></p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们只要掌握了一棵树的dfs序，就可以模拟整个dfs过程</p><p>对于关键点序列 a，dfs 一遍，求出每个点的 dfs 序（入栈和出栈的）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">pu[u] = ++dfu;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">dfs(v, u);</span><br><span class="line">po[u] = ++dfu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将关键点按dfs序排序，相邻两个点取 LCA，加入 a 序列，再把树根 1 加入</p><p>注意开个 bool 数组<strong>去重</strong></p><p>最后把整个序列 a 复制一份，全部<strong>取负</strong>，加入序列</p><p>此时序列 a 中全是虚树节点，正数代表入栈点，负数代表出栈点</p><p>将 a 序列按照 dfs 序排序，cmp 中要区分出入栈：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在整个虚树的 dfs 序已经知道了，如果是简单的树形dp甚至不需要建树，直接模拟 dfs 遍历：</p><p>开一个栈，遍历 a 序列，如果是正数即入栈，进行 dfs 递归前的操作</p><p>负数说明出栈，进行 dfs 递归完各个子树后的操作</p><p>如果要建树，“dfs”时对于每个父子关系建边就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v = stk[top--], u = stk[top];</span><br><span class="line">Add_edge(u, v), Add_edge(v, u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意多次询问的一定要清空（在 a 序列上的点），不能用 $O(n)$ 的 memset</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> tot, top, cnt_e;</span><br><span class="line"><span class="keyword">int</span> a[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">pu[u] = ++dfu;</span><br><span class="line">    <span class="comment">// 预处理LCA用的deep,fa...</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">dfs(v, u);</span><br><span class="line">po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">tot = top = cnt_e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">a[++tot] = <span class="built_in">array</span>[i], vis[a[tot]] = <span class="literal">true</span>;</span><br><span class="line">sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; k; ++i) &#123;</span><br><span class="line">lca = LCA(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!vis[lca]) a[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[<span class="number">1</span>]) a[++tot] = <span class="number">1</span>;</span><br><span class="line">k = tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">a[++tot] = -a[i];</span><br><span class="line">sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v = stk[top--], u = stk[top];</span><br><span class="line">Add_edge(u, v), Add_edge(v, u);</span><br><span class="line">vis[v] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Luogu-P2495-code"><a href="#Luogu-P2495-code" class="headerlink" title="Luogu P2495 code"></a>Luogu P2495 code</h2><p>顺便放上去</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">'\n'</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">25e4</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt_e, dfu;</span><br><span class="line"><span class="keyword">int</span> head[N], pu[N], po[N], fa[N][<span class="number">20</span>], deep[N], mn[N], a[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line">LL f[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">pu[u] = ++dfu;</span><br><span class="line">deep[u] = deep[last] + <span class="number">1</span>;</span><br><span class="line">fa[u][<span class="number">0</span>] = last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[u]; ++i)</span><br><span class="line">fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = e[i].to) != last) &#123;</span><br><span class="line">mn[v] = min(mn[u], e[i].val);</span><br><span class="line">dfs(v, u);</span><br><span class="line">&#125;</span><br><span class="line">po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line"><span class="keyword">if</span> (deep[fa[x][i]] &gt;= deep[y])</span><br><span class="line">x = fa[x][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line"><span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">x = fa[x][i], y = fa[y][i];</span><br><span class="line"><span class="keyword">return</span> x == y ? x : fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v, w; i &lt; n; ++i)</span><br><span class="line">read(u), read(v), read(w), add_edge(u, v, w), add_edge(v, u, w);</span><br><span class="line">mn[<span class="number">1</span>] = <span class="number">0x7fffffff</span>;</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">int</span> k, tot, top;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">tot = top = <span class="number">0</span>;</span><br><span class="line">read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">read(a[++tot]), vis[a[tot]] = <span class="literal">true</span>, f[a[tot]] = mn[a[tot]];</span><br><span class="line">sort(a+<span class="number">1</span>, a+k+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; k; ++i)&#123;</span><br><span class="line">lca = LCA(a[i], a[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!vis[lca]) a[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[<span class="number">1</span>]) a[++tot] = <span class="number">1</span>;</span><br><span class="line">k = tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">a[++tot] = -a[i];</span><br><span class="line">sort(a+<span class="number">1</span>, a+tot+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u; i &lt;= tot; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[i] &gt; <span class="number">0</span>) stk[++top] = a[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">u = stk[top--];</span><br><span class="line"><span class="keyword">if</span> (u != <span class="number">1</span>)</span><br><span class="line">f[stk[top]] += min(f[u], (LL)mn[u]);</span><br><span class="line"><span class="keyword">else</span> print(f[u]);</span><br><span class="line">f[u] = vis[u] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3233 [HNOI2014]世界树</title>
      <link href="/2020/04/06/%E9%A2%98%E8%A7%A3%20P3233%20HNOI2014%E4%B8%96%E7%95%8C%E6%A0%91/"/>
      <url>/2020/04/06/%E9%A2%98%E8%A7%A3%20P3233%20HNOI2014%E4%B8%96%E7%95%8C%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P3233" target="_blank" rel="noopener">题目</a></p><blockquote><p>给一棵树，每条边距离为1，q 次询问，每次选择 k 个关键点，树上每个点由距离最近的关键的管辖（距离相同选择编号最小的），求每个关键的管辖点数</p><p>$N,q\le3\times10^5,\sum_{i=1}^q{k_i}\le3\times10^5$</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>树形dp</strong>，看数据范围，需要建<strong>虚树</strong>来优化</p><p>考虑每次把关键点建出虚树</p><p>dp求出每个点 u 的 $belong_u$（管辖 u 的关键点），$dis_u$ （u 到 $belong_u$ 的距离）</p><p>类似最短路的松弛，注意第一遍dp统计儿子对父亲的贡献，第二遍统计父亲对儿子的贡献</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v]))</span><br><span class="line">    dis[u] = dis[v] + E[i].val, bl[u] = bl[v];</span><br></pre></td></tr></table></figure><p>第三遍dp统计答案，设 $f_u$ 表示原树中经过 u 增加 $belong_u$ 贡献的点数</p><p>在虚树上有两种情况：</p><ul><li>以 u 为根的原树的子树中没有关键点，那么这棵子树都由 u 或 $belong_u$ 管辖</li><li>虚树上连接 u 和 v 的边（u 为 v 的父亲），代表原树中的一条链，又分两种情况：<ul><li>$belong_u=belong_v$，这一条链除了 v 点其它都是 u 的贡献（v 点及其子树为 v 的贡献）</li><li>$belong_u\not=belong_v$，这条链被分成两部分，通过倍增找出分界点，划分 u,v 贡献</li></ul></li></ul><p>把 u 贡献加到 $belong_u$ 的答案上即可</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>这题一堆全局变量数组（命名冲突好麻烦），比大数据结构难调</p><p>关于链上找分界点（属于 v 范围的最高点）：</p><p>先求出 $belong_u$ 和 $belong_v$ 的距离 d，<code>deep[v] - (d / 2 - dis[v])</code> 即中间点的 deep</p><p>如果 u，v 中间有奇数个点，必定有一个点 x 到两个关键点的距离相等，要让 d - 1，倍增后中间点为 x 的儿子（对 d 为偶数没有影响），看两个关键点编号大小选择是否往上走</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d = deep[v] - deep[u] + dis[u] + dis[v] - <span class="number">1</span>, tmp = d / <span class="number">2</span> - dis[v], mid = v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; ~j; --j)</span><br><span class="line">    <span class="keyword">if</span> (deep[fa[mid][j]] &gt;= deep[v] - tmp)</span><br><span class="line">        mid = fa[mid][j];</span><br><span class="line"><span class="keyword">if</span> ((d &amp; <span class="number">1</span>) &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][<span class="number">0</span>];<span class="comment">// tmp 可能为负</span></span><br></pre></td></tr></table></figure><p>另外<strong>多测要清空</strong></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(TT x, <span class="keyword">char</span> end = <span class="string">'\n'</span>)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">3e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt_e, Q, k, dfu, tot, top;</span><br><span class="line"><span class="keyword">int</span> head[N], Head[N], pu[N], po[N];</span><br><span class="line"><span class="keyword">int</span> deep[N], fa[N][<span class="number">20</span>], size[N], a[N], t[N&lt;&lt;<span class="number">1</span>], stk[N];</span><br><span class="line"><span class="keyword">int</span> dis[N], bl[N], f[N], ans[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>], E[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> is[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">E[++cnt_e] = (Edge)&#123;Head[u], v, w&#125;, Head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">pu[u] = ++dfu;</span><br><span class="line">deep[u] = deep[last] + <span class="number">1</span>;</span><br><span class="line">fa[u][<span class="number">0</span>] = last;</span><br><span class="line">size[u] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[u]; ++i)</span><br><span class="line">fa[u][i] = fa[fa[u][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = e[i].to) != last)</span><br><span class="line">dfs(v, u), size[u] += size[v];</span><br><span class="line">po[u] = ++dfu;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deep[x] &lt; deep[y]) swap(x, y);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line"><span class="keyword">if</span> (deep[fa[x][i]] &gt;= deep[y])</span><br><span class="line">x = fa[x][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">19</span>; ~i; --i)</span><br><span class="line"><span class="keyword">if</span> (fa[x][i] != fa[y][i])</span><br><span class="line">x = fa[x][i], y = fa[y][i];</span><br><span class="line"><span class="keyword">return</span> x == y ? x : fa[x][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt; <span class="number">0</span> ? pu[x] : po[-x]) &lt; (y &gt; <span class="number">0</span> ? pu[y] : po[-y]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build_tree</span><span class="params">(<span class="keyword">int</span> kk)</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> vis[N];</span><br><span class="line">tot = top = cnt_e = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i)</span><br><span class="line">t[++tot] = a[i], vis[t[tot]] = <span class="literal">true</span>;</span><br><span class="line">sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, lca; i &lt; kk; ++i) &#123;</span><br><span class="line">lca = LCA(t[i], t[i+<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">if</span> (!vis[lca]) t[++tot] = lca, vis[lca] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[<span class="number">1</span>]) t[++tot] = <span class="number">1</span>;</span><br><span class="line">kk = tot;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= kk; ++i)</span><br><span class="line">t[++tot] = -t[i];</span><br><span class="line">sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= tot; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (t[i] &gt; <span class="number">0</span>) stk[++top] = t[i];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">v = stk[top--], u = stk[top];</span><br><span class="line">Add_edge(u, v, deep[v] - deep[u]), Add_edge(v, u, deep[v] - deep[u]);</span><br><span class="line">vis[v] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp1</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is[u]) dis[u] = <span class="number">0</span>, bl[u] = u;</span><br><span class="line"><span class="keyword">else</span> dis[u] = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u], v; i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = E[i].to) != last) &#123;</span><br><span class="line">dp1(v, u);</span><br><span class="line"><span class="keyword">if</span> (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v]))</span><br><span class="line">dis[u] = dis[v] + E[i].val, bl[u] = bl[v];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 我把第二三遍dp合在一块了</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp2</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">f[u] = size[u];<span class="comment">// 初值为子树size</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = Head[u], v; i; i = E[i].nxt)</span><br><span class="line"><span class="keyword">if</span> ((v = E[i].to) != last) &#123;</span><br><span class="line"><span class="keyword">if</span> (dis[v] &gt; dis[u] + E[i].val || (dis[v] == dis[u] + E[i].val &amp;&amp; bl[v] &gt; bl[u]))</span><br><span class="line">dis[v] = dis[u] + E[i].val, bl[v] = bl[u];</span><br><span class="line">dp2(v, u);</span><br><span class="line"><span class="keyword">if</span> (bl[u] == bl[v])</span><br><span class="line">f[u] -= size[v];</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> d = deep[v] - deep[u] + dis[u] + dis[v] - <span class="number">1</span>, tmp = d / <span class="number">2</span> - dis[v], mid = v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">19</span>; ~j; --j)</span><br><span class="line"><span class="keyword">if</span> (deep[fa[mid][j]] &gt;= deep[v] - tmp)</span><br><span class="line">mid = fa[mid][j];</span><br><span class="line"><span class="keyword">if</span> ((d &amp; <span class="number">1</span>) &amp;&amp; tmp &gt;= <span class="number">0</span> &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][<span class="number">0</span>];<span class="comment">// tmp可能为负数</span></span><br><span class="line">f[u] -= size[mid];</span><br><span class="line">f[v] += size[mid] - size[v];</span><br><span class="line">&#125;</span><br><span class="line">ans[bl[v]] += f[v];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (u == <span class="number">1</span>) ans[bl[<span class="number">1</span>]] += f[<span class="number">1</span>];<span class="comment">// 别落下根节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">read(u), read(v), add_edge(u, v, <span class="number">0</span>), add_edge(v, u, <span class="number">0</span>);</span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">read(Q);</span><br><span class="line"><span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">read(k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">read(a[i]), is[a[i]] = <span class="literal">true</span>;</span><br><span class="line">build_tree(k);</span><br><span class="line">dp1(<span class="number">1</span>, <span class="number">0</span>), dp2(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">print(ans[a[i]], <span class="string">' '</span>), is[a[i]] = ans[a[i]] = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">        <span class="comment">// 清空，用memset会TLE</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= tot; ++i)</span><br><span class="line"><span class="keyword">if</span> (t[i] &gt; <span class="number">0</span>)</span><br><span class="line">Head[t[i]] = dis[t[i]] = bl[t[i]] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 树形DP </tag>
            
            <tag> 虚树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2014 [CTSC1997]选课</title>
      <link href="/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P2014-CTSC1997%E9%80%89%E8%AF%BE/"/>
      <url>/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P2014-CTSC1997%E9%80%89%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2014" target="_blank" rel="noopener">题目</a></p><blockquote><p>给一棵 n 个点的树，每个点有权值，选择一个点必须同时选择其父节点</p><p>求选 m 个点的最大权值和</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>树上背包问题</strong></p><p>选择 m 个点使其总价值最大，典型的背包问题</p><p>先设 $f_{i,j}$，表示以 i 为根的子树中选择 j 个能够得到最大价值</p><p>再考虑树形dp的模型，要求一棵树的答案能够由其子树得到</p><p>把节点 u 看作背包枚举空间 j，把每个儿子 v 看做物品，枚举选择个数（重量）k，物品价值为 $f_{v,k}$</p><p>转移方程：</p><script type="math/tex; mode=display">\large f_{u,j}=f_{u,j-k}+f_{v,k}</script><p>注意是01背包，j 要倒序枚举</p><ul><li><p>如何保证选择一个点的同时选择其父节点？</p></li><li><p>赋初值 $f_{u,1}=val_u$，手动模拟一下dp过程就懂了</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">309</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, cnt_e;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], f[N][N];</span><br><span class="line">Edge e[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add_edge</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">e[++cnt_e] = (Edge)&#123;head[u], v&#125;, head[u] = cnt_e;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">f[u][<span class="number">1</span>] = val[u];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) &#123;</span><br><span class="line">v = e[i].to;</span><br><span class="line">dp(v);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = m + <span class="number">1</span>; j; --j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; j; ++k)</span><br><span class="line">f[u][j] = max(f[u][j], f[u][j-k] + f[v][k]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u; i &lt;= n; ++i)</span><br><span class="line">read(u), add_edge(u, i), read(val[i]);</span><br><span class="line">dp(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">0</span>][m+<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5664 Emiya 家今天的饭</title>
      <link href="/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P5664-Emiya-%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/"/>
      <url>/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P5664-Emiya-%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P5664" target="_blank" rel="noopener">题目</a></p><blockquote><p>n 种烹饪方法，有 m 种食材，第 i 个方法的第 j 种食材有 $a_{i,j}$ 个</p><p>要求：</p><ul><li>至少要做一道菜</li><li>一种方法最多做一道菜</li><li>做 k 道菜，每种食材使用次数不超过 $\lfloor\frac{k}{2}\rfloor$ 次</li></ul><p>求总方案数（$\mod{998244353}$）</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>明显的计数DP</p><p>第三个限制很讨厌，先不管它</p><p>我们可以用总方案数减去不合法的方案</p><p>因为题目背景让我叙述不方便，<strong>建议把“方法”和“食材”想象成行和列</strong></p><h3 id="总方案数"><a href="#总方案数" class="headerlink" title="总方案数"></a>总方案数</h3><p>无视第三个条件时，只要考虑每个方法选或不选</p><p>设 $s_i$ 表示第 i 种方法的食材个数和，即 $\sum_{k=1}^m{a_{i,k}}$</p><p>设 $g_{i,j}$ 表示前 i 种方法选了 j 种的方案数</p><script type="math/tex; mode=display">\large g_{i,j}=g_{i-1,j}+g_{i-1,j-1}\times s_i</script><p>此时总方案数为</p><script type="math/tex; mode=display">\sum_{i=1}^n{g_{n,i}}</script><p>复杂度 $O(n^2)$</p><h3 id="不合格方案数"><a href="#不合格方案数" class="headerlink" title="不合格方案数"></a>不合格方案数</h3><p>某种食材选择的个数超过的总菜数的一半即为不合格</p><p>因为<strong>最多只有一种食材</strong>的个数会超过一半</p><p>只要对于每一种食材 i，考虑第 i 种食材的个数与其它食材的个数关系</p><p>设 $f_{j,x,y}$ 表示前 j 种方法，食材 i 选了 x 个，其它选了 y 个</p><script type="math/tex; mode=display">\large f_{j,x,y}=f_{j-1,x,y}+f_{j-1,x-1,y}\times a_{j,i}+f_{j-1,x,y-1}\times(s_j-a_{j,i})</script><p>每种食材dp一遍，复杂度 $O(mn^3)$，需要<strong>降维</strong></p><p>又碰上这种套路：<strong>我们不需要知道 x，y 的具体数值，只需要知道他们的关系</strong></p><p>设 $f_{j,k}$ 表示前 j 种方法，食材 i 选的个数比其它的多 k 个</p><script type="math/tex; mode=display">\large f_{j,k}=f_{j-1,k}+f_{j-1,k-1}\times a_{j,i}+f_{j-1,k+1}\times(s_j-a_{j,i})</script><p>这样复杂度就是 $O(mn^2)$ 了</p><p>总共不合法方案数为</p><script type="math/tex; mode=display">\sum_{i=1}^n{f_{n,i}}</script><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>DP $f_{j,k}$ 时，k 的范围为 -j ~ j，可能为<strong>负数</strong>，需要数组下标整体偏移 n，数组也要开 2n 倍</p><p>转移时 <code>g[i][j] = (g[i-1][j] + sum[i][0] * g[i-1][j-1]) % MOD;</code> 这么写爆 long long</p><p>要<strong>每个</strong>乘法前强制转 long long，或者直接全开 long long</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">109</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">2009</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">LL ans;</span><br><span class="line">LL a[N][M], sum[N][M], f[N][N&lt;&lt;<span class="number">1</span>], g[N][N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">read(a[i][j]), sum[i][<span class="number">0</span>] = (sum[i][<span class="number">0</span>] + a[i][j]) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">sum[i][j] = (sum[i][<span class="number">0</span>] - a[i][j] + MOD) % MOD;</span><br><span class="line">    </span><br><span class="line">g[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">g[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">g[i][j] = (g[i<span class="number">-1</span>][j] + sum[i][<span class="number">0</span>] * g[i<span class="number">-1</span>][j<span class="number">-1</span>]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i) &#123;</span><br><span class="line"><span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">f[<span class="number">0</span>][n] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = n - j; k &lt;= n + j; ++k)</span><br><span class="line">f[j][k] = (f[j<span class="number">-1</span>][k] + a[j][i] * f[j<span class="number">-1</span>][k<span class="number">-1</span>] + sum[j][i] * f[j<span class="number">-1</span>][k+<span class="number">1</span>]) % MOD;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">ans = (ans + MOD - f[n][n+j]) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">ans = (ans + g[n][i]) % MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推DP </tag>
            
            <tag> 容斥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1966 火柴排队</title>
      <link href="/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P1966-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/"/>
      <url>/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P1966-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P1966" target="_blank" rel="noopener">题面</a></p><blockquote><p>两个数列 $a,b$，求最少相邻两数交换多少次使得 $\sum_{i=1}^n{(a_i-b_i)^2}$ 最小</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先来简单地变换一下式子（见到这种狗式子一定要拆）：</p><script type="math/tex; mode=display">\sum{(a_i-b_i)^2}=\sum(a_i^2+b_i^2-2a_ib_i)</script><p>$\sum(a_i^2+b_i^2)$ 是不变的，所以要最大化 $\sum{a_ib_i}$</p><p>所以要让 $a,b$ 中排名第 k 的两个数在同一位置上</p><p>为啥？<del>一点也不严谨的口胡</del>证明：</p><blockquote><p>假设有四个数 $x_1,x_2,y_1,y_2$，且 $x_1&lt;x_2,y_1&lt;y_2$</p><p>那么 $x_1y_1+x_2y_2&gt;x_1y_2+x_2y_1$，<del>这很显然吧</del></p><p>也就是说 $a,b$ 中最大两数乘积、次大两数乘积……的和是最大的</p></blockquote><p>然后怎么做？</p><p>让排名为 k 的 $a_i,b_j$ 两数在同一位置上，就是让 $b_j$ 到位置 $i$ 上</p><p>令 $b_j=i$，再将 $b$ 数组排序，$b_j$ 自然到位置 $i$ 上了</p><p>是相邻两数交换来排序的话，最少次数就是此时 $b$ 的逆序对数（挺好证吧）</p><p>直接上树状数组或者归并</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>出题人还算良心，同一数列中两两各不相同，少了许多细节</p><p><a href="https://www.luogu.com.cn/record/30589508" target="_blank" rel="noopener">评测记录</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/* fast read */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">99999997</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, ans;</span><br><span class="line"><span class="keyword">int</span> a[N], b[N], tmp[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 离散化</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">lsh</span><span class="params">(<span class="keyword">int</span> *t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) tmp[i] = t[i];</span><br><span class="line">sort(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> tot = unique(tmp+<span class="number">1</span>, tmp+n+<span class="number">1</span>) - tmp;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">t[i] = lower_bound(tmp+<span class="number">1</span>, tmp+tot+<span class="number">1</span>, t[i]) - tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 树状数组，用于求逆序对</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit_Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> tr[N];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= n) </span><br><span class="line">tr[x] += k, x += lowbit(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x) </span><br><span class="line">re += tr[x], x -= lowbit(x);</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line">&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(a[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) read(b[i]);</span><br><span class="line">    <span class="comment">// 离散化，同时也是得到每个数的排名</span></span><br><span class="line">lsh(a), lsh(b);</span><br><span class="line">    <span class="comment">// 让 b 数列每个元素得到 a 中同一排名元素的坐标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">tmp[a[i]] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">b[i] = tmp[b[i]];</span><br><span class="line">    <span class="comment">// 统计答案</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 每次加入一个数增加逆序对数：原个数 - 小于它的元素个数</span></span><br><span class="line">ans = (ans + i - <span class="number">1</span> - tr.query(b[i])) % MOD;</span><br><span class="line">tr.add(b[i], <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2831 愤怒的小鸟</title>
      <link href="/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/"/>
      <url>/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.com.cn/problem/P2831" target="_blank" rel="noopener">题面</a></p><blockquote><p>在坐标系第一象限有一些点，用一些经过原点、开口向下的抛物线 $y=ax^2+bx$ 覆盖所有点，最少需要多少条</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>注意到 $n\le 18$，基本上是状压 DP </p><h3 id="初始做法"><a href="#初始做法" class="headerlink" title="初始做法"></a>初始做法</h3><p>考虑压缩点的覆盖状态，设 $f[S]$ 表示集合 $S$ 被覆盖需要最少的抛物线数</p><p>每两个点确定一条抛物线（经过原点），预处理每条抛物线 $line_{i,j}$ 能覆盖的点集合</p><p>不难得出转移方程：</p><script type="math/tex; mode=display">f[S\cup line_{i,j}]=f[S]+1\\f[S\cup i]=f[S]+1</script><p>那么 $O(2^n)$ 枚举集合状态，再每个状态 $O(n^2)$ 枚举抛物线转移，复杂度 $O(Tn^2 2^n)$</p><p>估算一下，计算量在 4e8 级别，不一定过</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>在每个状态 $S$，转移后至少覆盖一个点</p><p>从 i 出发枚举抛物线转移和从 j 出发枚举的顺序先后没有关系</p><p>先覆盖 i，和覆盖 j 后再覆盖 i，是一样的（如果 j 出发的抛物线能覆盖 i，从 i 出发也一定能覆盖 j）</p><p>于是每个状态我只从一个点出发枚举抛物线，复杂度降到 $O(Tn2^n)$，稳过</p><p>要预处理每个状态最小的未覆盖的点是哪个</p><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><p>从两个点的坐标 $(x_1,y_1),(x_2,y_2)$ 算出抛物线参数 $a,b$，要推一下公式：</p><p>解 $a$：</p><script type="math/tex; mode=display">\begin{cases}    y_1=ax_1^2+bx_1\\    y_2=ax_2^2+bx_2\end{cases}\\\begin{cases}    \frac{y_1}{x_1}=ax_1+b\\    \frac{y_2}{x_2}=ax_2+b\end{cases}\\a(x_1-x_2)=\frac{y_1}{x_1}-\frac{y_2}{x_2}\\a=\frac{x_2y_1-x_1y_2}{x_1x_2(x_1-x_2)}</script><p>解 $b$：</p><script type="math/tex; mode=display">\begin{cases}    y_1=ax_1^2+bx_1\\    y_2=ax_2^2+bx_2\end{cases}\\\begin{cases}    \frac{y_1}{x_1^2}=a+\frac{b}{x_1}\\    \frac{y_2}{x_2^2}=a+\frac{b}{x_2}\end{cases}\\b(\frac{1}{x_1}-\frac{1}{x_2})=\frac{y_1}{x_1^2}-\frac{y_2}{x_2^2}\\b=\frac{x_1^2y_2-x_2^2y_1}{x_1x_2(x_1-x_2)}</script><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p><a href="https://www.luogu.com.cn/record/30577051" target="_blank" rel="noopener">提交记录</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/* fast read */</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MAXN = (<span class="number">1</span> &lt;&lt; <span class="number">18</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装了抛物线，便于比较</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Line</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> a, b;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> ==(Line &amp;t) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fabs</span>(a - t.a) &lt;= eps &amp;&amp; <span class="built_in">fabs</span>(b - t.b) &lt;= eps;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> T, n, m, maxn;</span><br><span class="line"><span class="keyword">int</span> low[MAXN], line[N][N], f[MAXN];</span><br><span class="line"><span class="keyword">double</span> x[N], y[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由推导的公式算抛物线</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Line <span class="title">get_line</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (Line)&#123;</span><br><span class="line">(x[b] * y[a] - x[a] * y[b]) / (x[a] * x[b] * (x[a] - x[b])),</span><br><span class="line">(x[a] * x[a] * y[b] - x[b] * x[b] * y[a]) / (x[a] * x[b] * (x[a] - x[b]))</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 预处理最小未覆盖的点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= MAXN; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; ++j)</span><br><span class="line"><span class="keyword">if</span> ((i &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>) &#123;</span><br><span class="line">low[i] = j + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">read(T);</span><br><span class="line"><span class="keyword">while</span> (T--) &#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line">maxn = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%lf%lf"</span>, &amp;x[i], &amp;y[i]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j) &#123;</span><br><span class="line">line[i][j] = <span class="number">0</span>;<span class="comment">// 多测清空</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(x[i] - x[j]) &gt;= eps) &#123;<span class="comment">// 横坐标相同则无解</span></span><br><span class="line">Line t = get_line(i, j);</span><br><span class="line"><span class="keyword">if</span> (t.a &gt; -eps) <span class="keyword">continue</span>;<span class="comment">// 解出来开口向上不算</span></span><br><span class="line">line[i][j] |= (<span class="number">1</span> &lt;&lt; (i - <span class="number">1</span>)) | (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>));</span><br><span class="line"><span class="comment">// 寻找在同一抛物线上的点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line"><span class="keyword">if</span> (k != i &amp;&amp; k != j &amp;&amp; get_line(i, k) == t)</span><br><span class="line">line[i][j] |= <span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++i) f[i] = INF;<span class="comment">// 清空qwq</span></span><br><span class="line">f[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; maxn; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = low[i], j = <span class="number">1</span> &lt;&lt; (x - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (x &gt; n) <span class="keyword">continue</span>;</span><br><span class="line">f[i|j] = min(f[i|j], f[i] + <span class="number">1</span>); <span class="comment">// 只覆盖一个点</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">1</span>; y &lt;= n; ++y)</span><br><span class="line">f[i|line[x][y]] = min(f[i|line[x][y]], f[i] + <span class="number">1</span>); <span class="comment">// 通过抛物线转移</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[maxn]);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 SA</title>
      <link href="/2020/02/13/2020-02-13-%E6%9D%BF%E5%AD%90-SA/"/>
      <url>/2020/02/13/2020-02-13-%E6%9D%BF%E5%AD%90-SA/</url>
      
        <content type="html"><![CDATA[<p>先贴个板子，总结有时间在再说</p><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>$O(n)$ 的排序是不是很诱人，桶排改进而已</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">qsort</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">tax[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">++tax[rnk[i]];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">tax[i] += tax[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i; --i)</span><br><span class="line">sa[tax[rnk[tp[i]]]--] = tp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="后缀排序"><a href="#后缀排序" class="headerlink" title="后缀排序"></a>后缀排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_SA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">rnk[i] = s[i], tp[i] = i;</span><br><span class="line">m = <span class="number">127</span>, qsort();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> w = <span class="number">1</span>, p = <span class="number">0</span>; w &lt;= n &amp;&amp; p &lt; n; m = p, w &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - w + <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">tp[++p] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (sa[i] &gt; w)</span><br><span class="line">tp[++p] = sa[i] - w;</span><br><span class="line">qsort();</span><br><span class="line">swap(rnk, tp);</span><br><span class="line">rnk[sa[<span class="number">1</span>]] = p = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">rnk[sa[i]] = (tp[sa[i]] == tp[sa[i<span class="number">-1</span>]] &amp;&amp; tp[sa[i]+w] == tp[sa[i<span class="number">-1</span>]+w]) ? p : ++p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求-height-数组"><a href="#求-height-数组" class="headerlink" title="求 height 数组"></a>求 height 数组</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">get_height</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, k = <span class="number">0</span>, j; i &lt;= n; ++i) &#123;</span><br><span class="line">k = max(<span class="number">0</span>, k - <span class="number">1</span>), j = sa[rnk[i]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">while</span> (s[i+k] == s[j+k])</span><br><span class="line">k++;</span><br><span class="line">ht[rnk[i]] = k;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 SAM</title>
      <link href="/2020/02/13/2020-02-13-%E6%80%BB%E7%BB%93-SAM/"/>
      <url>/2020/02/13/2020-02-13-%E6%80%BB%E7%BB%93-SAM/</url>
      
        <content type="html"><![CDATA[<p>$SAM: Suffix Automaton$ ，后缀自动机</p><p>难理解，但代码好写（当初敲完模板题没总结，现在忘光了QAQ）</p><p>总体上是 <strong>后缀 trie + parent tree</strong> ，构成一个可以表示所有子串的 DAG</p><p>福利：<a href="http://yeah.moe/p/a8e74947/" target="_blank" rel="noopener">后缀自动机可视化</a></p><p>推荐博客：</p><ul><li><a href="https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie" target="_blank" rel="noopener">KesdiaelKen 的博客</a>（我就是看这博客学会的）</li><li><a href="https://www.luogu.com.cn/blog/ShadowassIIXVIIIIV/solution-p3804" target="_blank" rel="noopener">shadowice1984 的博客</a></li><li><a href="https://www.cnblogs.com/xzyxzy/p/9186759.html" target="_blank" rel="noopener">xzyxzy 的博客</a></li></ul><p>这博客主要是我总结自己不好理解的地方，不是很全面</p><hr><blockquote><p>声明：本文中图片大部分为 BANANA 从他人博客<del>盗来的</del>借鉴的，一些语言表达借鉴于 <a href="https://www.luogu.com.cn/blog/Kesdiael3/hou-zhui-zi-dong-ji-yang-xie" target="_blank" rel="noopener">KesdiaelKen 的博客</a> ，若有侵权请 <a href="mailto:true-banana@outlook.com">联系BANANA</a> 删除</p></blockquote><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h3><p>先了解几个概念：</p><p><strong>后缀 trie </strong>：把字符串的每一个后缀插入到 trie 树里</p><p>一个普通的后缀 trie ，有很大部分节点是可以压缩的</p><p><img src="/img/001.png" style="zoom:50%;" /></p><p><strong>endpos 集合</strong> ：一个子串在原串出现的位置（可能出现多次）的右端点集合</p><blockquote><p>比如一个串“banana”</p><p>$endpos(b)=\{1\}, endpos(a)=\{2,4,6\}$</p><p>$endpos(an)=\{3,5\}, endpos(ana)=\{4,6\}$</p></blockquote><p><strong>parent tree</strong> ：一个子串前面添加一个或几个字符，可以将他的 endpos 集合<strong>分割</strong>，endpos 集合之间便有了父子关系</p><p><img src="/img/002.png" style="zoom:70%;" /></p><p>parent tree 上每一个节点表示的 endpos 集合唯一地表示一个后缀集合</p><p><del>不好举例，自己手模吧</del></p><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><p><em>将后缀 trie 和 parent tree 结合起来便是 SAM 的 DAG</em></p><p><strong>那么一条路径表示原串的一个子串，一个节点 x 表示根节点到 x 路径形成的所有串的 endpos 集合</strong></p><p>SAM 常见的增量构造：将字符串从前到后一个一个字符插进去（离线构造窝不会）</p><p>先确定一些量：</p><ul><li><p>$fa[x]$ ：x 节点表示的集合在 parent tree 上的父亲</p></li><li><p>$len[x]$ ：x 节点表示的集合中<strong>最长</strong>的串的长度</p><p>如果设最短的串长为 $minlen[x]$ ，那么 $len[fa[x]]+1=minlen[x]$ ，即 parent tree 上的分割关系</p></li></ul><p>我们考虑从后面插入一个字符 c，会有什么变化：</p><ul><li>多出新串的后缀</li><li>新串后缀的 endpos 集合改变</li></ul><p>那么在 trie 的意义上要把旧串所有后缀的后面加上字符 c</p><p>在 SAM 上实现就是先新建节点 np</p><p>然后把最后一个节点 p、它在 parent tree 的父亲以及祖先的 c 儿子设为该节点（<strong>相当于压缩地遍历旧串的所有后缀</strong>）</p><p>并且 $len[np]=len[p]+1$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> p = last, np = last = ++cnt;</span><br><span class="line">len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">    ch[p][c] = np, p = fa[p];</span><br></pre></td></tr></table></figure><ol><li><p>如果这些祖先都没有 c 儿子，到达最高的祖先就是根节点</p><p>说明字符 c 是一个新字符，parent tree 上根节点多一个儿子：只有位置 c 的 endpos 集合</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><ol><li><p>那么如果有一个祖先 p 已经有了 c 儿子，设它为 q</p><p>说明旧串有子串的结尾是 c 字符，那么就要看这个 q 的 len 了</p><ul><li><p>$len[q]=len[p]+1$</p><p>说明 q 在插入时 p 就是最后一个节点了</p><p>那么根到 q 点表示的子串都是根到 np 表示的子串的后缀</p><p>在 parent tree 上，q 是 np 的父亲</p></li><li><p>$len[q]&gt;len[p]+1$</p><p>在 parent tree 上，q 和 np 是兄弟</p><p>那么就新建一个 nq （复制一份 q ）作为它俩的父亲</p><p>将之前 p 及其祖先指向 q 的 c 儿子全指向 nq 即可</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> q = ch[p][c];</span><br><span class="line"><span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">    fa[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">int</span> nq = ++cnt;</span><br><span class="line">    <span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">    len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">    fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">        ch[p][c] = nq, p = fa[p];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>完整构造代码，看起来一堆 while 却是$O(n)$</p><p>注意点数是 2n 规模</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Suffix_Automaton</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt, last;</span><br><span class="line"><span class="keyword">int</span> fa[N&lt;&lt;<span class="number">1</span>], ch[N&lt;&lt;<span class="number">1</span>][<span class="number">30</span>], len[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Suffix_Automaton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">last = cnt = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> p = last, np = last = ++cnt;</span><br><span class="line">len[np] = len[p] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; !ch[p][c])</span><br><span class="line">ch[p][c] = np, p = fa[p];</span><br><span class="line"><span class="keyword">if</span> (!p) fa[np] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> q = ch[p][c];</span><br><span class="line"><span class="keyword">if</span> (len[q] == len[p] + <span class="number">1</span>)</span><br><span class="line">fa[np] = q;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> nq = ++cnt;</span><br><span class="line"><span class="built_in">memcpy</span>(ch[nq], ch[q], <span class="keyword">sizeof</span> ch[q]);</span><br><span class="line">len[nq] = len[p] + <span class="number">1</span>;</span><br><span class="line">fa[nq] = fa[q], fa[q] = fa[np] = nq;</span><br><span class="line"><span class="keyword">while</span> (p &amp;&amp; ch[p][c] == q)</span><br><span class="line">ch[p][c] = nq, p = fa[p];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; SAM;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ul><li><p>判断子串</p><p>直接在 SAM 上跑，跑完没到 NULL 即为子串</p></li><li><p>求不同子串个数</p><p>设 $f[i]$ 为从 i 点出发的子串， $f[i]=\sum_{(i,j)\in Edge}{f[j]+1}$</p><p>好像还可以直接求 $\sum{(len[i]-len[fa[i]])}$ ，因为 SAM上无重复子串</p></li><li><p>待更~</p></li></ul><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>BANANA 由于过菜，还不会写几道题~</p><ul><li><a href="https://www.luogu.com.cn/problem/P3804" target="_blank" rel="noopener">P3804 【模板】后缀自动机 (SAM)</a></li></ul><blockquote><p>求出 <em>S</em> 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值</p></blockquote><p>一个子串的出现次数即在 parent tree 上该子树的 size</p><p>暴力建出 parent tree，或者拓扑一下 DAG ，统计</p><ul><li><a href="https://www.luogu.com.cn/problem/P4070" target="_blank" rel="noopener">P4070 [SDOI2016]生成魔咒</a></li></ul><blockquote><p>每次向后插入一个字符，并求每次操作后不同子串个数</p></blockquote><p>显然 SAM 应用在求不同子串个数 $\sum{(len[i]-len[fa[i]])}$</p><p>每次只增加一个 len 影响总个数的节点，<code>ans += len[x] - len[fa[x]]</code>，于是每次 $O(1)$ 统计答案</p><p>大坑：“字符”范围 1e9 ，每个节点要用 map 存儿子</p><ul><li>待更~</li></ul>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 OI中一些数学定理</title>
      <link href="/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-OI%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86/"/>
      <url>/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-OI%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Matrix-Tree-定理"><a href="#Matrix-Tree-定理" class="headerlink" title="Matrix Tree 定理"></a>Matrix Tree 定理</h2><p>定义一个图 $G$ 的 $Kirchhoff$ 矩阵 $C=\text{度数矩阵}-\text{邻接矩阵}$</p><script type="math/tex; mode=display">C_{i,j}=\begin{cases}    degree_i& (i=j)\\    -1& (i\not=j\ and\ (i,j)\in G(E))\\    0& (i\not=j\ and\ (i,j)\notin G(E))\end{cases}</script><p>将矩阵 $C$ 去掉任意一行和一列，该矩阵的行列式即图 $G$ 的 生成树个数</p><h2 id="概率相关"><a href="#概率相关" class="headerlink" title="概率相关"></a>概率相关</h2><p>$P(A)$ ： $A$ 事件发生的概率</p><p>$E(X)$：随机变量 $X$ 的期望值，$E(X)=\sum P(X=i)\times i$</p><p>$P(A|B)$：$A$ 在 $B$ 发生的条件下发生的概率，$P(A|B)=\frac{P(AB)}{P(B)}$</p><p>全概率公式：$P(B)=\sum_{i=1}^n{P(A_i)P(B|A_i)}$</p><p>贝叶斯公式：$P(A_i|B)=\frac{P(B|A_i)P(A_i)}{\sum_{j=1}^n{P(B|A_j)P(A_j)}}$ （不会，不知道有没有用）</p><p>期望的性质：</p><p>$E(X+Y)=E(X)+E(Y)$</p><p>$E(aX+b)=aE(X)+b$</p><p>$E(XY)=E(X)+E(Y)$ （ $x,y$ 相互独立）</p><h2 id="辛普森积分"><a href="#辛普森积分" class="headerlink" title="辛普森积分"></a>辛普森积分</h2><script type="math/tex; mode=display">\frac{b-a}{6}[f(a)+4f(\frac{a+b}{2})+f(b)]</script><p>自适应辛普森，分成左右分别套辛普森法则，不断拟合：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simpson</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (f(l) + <span class="number">4</span> * f(mid) + f(r)) * (r - l) / <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">solve</span><span class="params">(<span class="keyword">double</span> l, <span class="keyword">double</span> r, <span class="keyword">double</span> last, <span class="keyword">double</span> eps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">double</span> ln = simpson(l, mid), rn = simpson(mid, r);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(ln + rn - last) &lt;= eps)</span><br><span class="line"><span class="keyword">return</span> ln + rn + (ln + rn - last);</span><br><span class="line">    <span class="keyword">return</span> solve(l, mid, ln, eps/<span class="number">2</span>) + solve(mid, r, rn, eps/<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模性质"><a href="#模性质" class="headerlink" title="模性质"></a>模性质</h2><p>模意义下加、减、乘随便做，除要转换成逆元</p><p>$a\equiv b\pmod p\nRightarrow \frac{a}{2}\equiv \frac{b}{2}\pmod p$</p><h2 id="裴蜀定理"><a href="#裴蜀定理" class="headerlink" title="裴蜀定理"></a>裴蜀定理</h2><p>对于不定方程：$ax+by=c$</p><p>有（整数）解的充要条件为 $\gcd⁡(a,b) | c$</p><p>即一定存在 $x,y$ 满足 $ax+by=\gcd(a,b)$</p><p>推论：$a,b$ 互素等价于 $ax+by=1$ 有解</p><h2 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h2><h3 id="gcd"><a href="#gcd" class="headerlink" title="gcd"></a>gcd</h3><script type="math/tex; mode=display">\gcd(a,b)=\gcd(a-b,b)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b ? gcd(b, a % b) : a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">gcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">while</span> (b)</span><br><span class="line">        t = a, a = b, b = t % a;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exgcd"><a href="#exgcd" class="headerlink" title="exgcd"></a>exgcd</h3><script type="math/tex; mode=display">ax+by=\gcd(a,b)\\bx'+(a\%b)y'=\gcd(b,a\%b)</script><p>将 $a mod b$ 替换为 $a-\lfloor\frac{a}{b}\rfloor b$ ，得</p><script type="math/tex; mode=display">\begin{align}bx'+(a\%b)y'&=bx'+(a-\lfloor\frac{a}{b}\rfloor b)y'\\&=ay'+b(x'-\lfloor\frac{a}{b}\rfloor y')\end{align}</script><p>则 $x,y$ 和 $x’,y’$ 的关系为</p><script type="math/tex; mode=display">x=y',y=x'-\lfloor\frac{a}{b}\rfloor y'</script><p>当 $b=0$ 时，$x’=1$ ，$y$ 可以为任何值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> &amp;y, <span class="keyword">int</span> &amp;gcd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>, y = <span class="number">0</span>, gcd = a;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    exgcd(b, a%b, y, x, gcd);</span><br><span class="line">    y -= a / b * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="整数唯一分解定理"><a href="#整数唯一分解定理" class="headerlink" title="整数唯一分解定理"></a>整数唯一分解定理</h2><p>对于任意整数 $N (N\ge2)$ </p><script type="math/tex; mode=display">\large N=\prod_{i=1}^k{p_i^{r_i}}\quad (p_i\text{为质数},r_i\ge0)</script><p>$N$ 的正约数集合：$\large\{\prod_{i=1}^k{p_i^{b_i}}\} (0\le b_i\le r_i)$</p><p>$N$ 的正约数个数：$\large\prod_{i=1}^k{(r_i+1)}$</p><p>$N$ 的正约数和：$\large\prod_{i=1}^k(\sum_{j=0}^{r_i}p_i^j)$</p><h2 id="威尔逊定理"><a href="#威尔逊定理" class="headerlink" title="威尔逊定理"></a>威尔逊定理</h2><p>$p$ 是质数的充要条件为:</p><script type="math/tex; mode=display">(p-1)!\equiv -1\pmod p</script><h2 id="费马小定理"><a href="#费马小定理" class="headerlink" title="费马小定理"></a>费马小定理</h2><p>$p$ 为质数，且 $\gcd(a,p)=1$ ，则：</p><script type="math/tex; mode=display">a^{p-1}\equiv 1\pmod p</script><p>故 $a$ 在模 $p$ 下的乘法逆元为 $a^{p-2}$</p><h3 id="线性预处理逆元"><a href="#线性预处理逆元" class="headerlink" title="线性预处理逆元"></a>线性预处理逆元</h3><p>设 $p=i*k+r(0\le r\lt i)$</p><script type="math/tex; mode=display">i*k+r\equiv 0\pmod p</script><p>两边乘 $i^{-1}r^{-1}$</p><script type="math/tex; mode=display">k*r^{-1}+i^{-1}\equiv0\pmod p\\i^{-1}\equiv -k*r^{-1}\pmod p</script><p>其中 $r=p\%i,k=\lfloor\frac{p}{i}\rfloor$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = (p - p / i) * inv[p%i] % p;</span><br></pre></td></tr></table></figure><p>还有一种方法：</p><p>设 $s_i=\prod_{j=1}^{i}a_i,invs_i=s_i^{-1}$</p><p>$O(\log_2(mod))$ 预处理 $invs_n$ ，则 $invs_i=invs_{i+1}\times a_{i+1}$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    s[i] = s[i<span class="number">-1</span>] * a[i] % p;</span><br><span class="line">invs[n] = power(s[n], p<span class="number">-2</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i; --i)</span><br><span class="line">    invs[i] = invs[i+<span class="number">1</span>] * a[i+<span class="number">1</span>] % p;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    inv[i] = invs[i] * s[i<span class="number">-1</span>] % p;</span><br></pre></td></tr></table></figure><h2 id="欧拉函数"><a href="#欧拉函数" class="headerlink" title="欧拉函数"></a>欧拉函数</h2><script type="math/tex; mode=display">\varphi(n)=\sum_{i=1}^n[\gcd(n, i)=1]</script><p>若 $p$ 为素数，则 $\varphi(p)=p-1$</p><p>若 $\gcd(a,b)=1$，则 $\varphi(ab)=\varphi(a)\varphi(b)$</p><p>基于素因数分解求 $\varphi(n)$ ，复杂度 $O(\sqrt{n})$ ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">euler_phi</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (n % i == <span class="number">0</span>) &#123;</span><br><span class="line">res = res / i * (i - <span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span> (n % i == <span class="number">0</span>)</span><br><span class="line">                n /= i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (n != <span class="number">1</span>) </span><br><span class="line">        res = res / n * (n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="欧拉定理"><a href="#欧拉定理" class="headerlink" title="欧拉定理"></a>欧拉定理</h2><p>$a,p$ 为互质的正整数</p><script type="math/tex; mode=display">a^{\varphi(p)}\equiv 1\pmod p</script><h3 id="扩展欧拉定理"><a href="#扩展欧拉定理" class="headerlink" title="扩展欧拉定理"></a>扩展欧拉定理</h3><p>若 $a,p$ 不一定互质，且 $x\ge \varphi(p)$</p><script type="math/tex; mode=display">a^x\equiv a^{x\%\varphi(p)+\varphi(p)}\pmod p</script><h2 id="中国剩余定理"><a href="#中国剩余定理" class="headerlink" title="中国剩余定理"></a>中国剩余定理</h2><h3 id="crt"><a href="#crt" class="headerlink" title="crt"></a>crt</h3><p>对于一元线性同余方程组：</p><script type="math/tex; mode=display">\begin{cases}    x\equiv a_1\pmod{m_1}\\    x\equiv a_2\pmod{m_2}\\    ……\\    x\equiv a_n\pmod{m_n}\end{cases}</script><p>其中 $m_i$ 两两互质</p><p>该方程组的通解为：</p><script type="math/tex; mode=display">M=\prod_{i=1}^nm_i\\M_i=\frac{M}{m_i}\\t_i=M_i^{-1}\pmod{m_i}\\x\equiv \sum_{i=1}^n{a_it_iM_i\pmod M}</script><h3 id="excrt"><a href="#excrt" class="headerlink" title="excrt"></a>excrt</h3><p>还不会，咕……</p><h2 id="拉格朗日插值"><a href="#拉格朗日插值" class="headerlink" title="拉格朗日插值"></a>拉格朗日插值</h2><p>对于一个给定 n 个点 $(x_i,y_i)$ 的多项式，可以 $O(n^2)$ 算出该多项式在 $x_k$ 的取值</p><script type="math/tex; mode=display">f(x_k)=\sum_{i=1}^n{y_i\prod_{i\not=j}\frac{x_k-x_j}{x_i-x_j}}</script><p>如果已知取值 $x_1$ 到 $x_n$ 是连续的话，可以预处理前缀积优化到 $O(n\log n)$（逆元再线性处理就是 $O(n)$ ）</p><h2 id="莫比乌斯函数"><a href="#莫比乌斯函数" class="headerlink" title="莫比乌斯函数"></a>莫比乌斯函数</h2><script type="math/tex; mode=display">\mu(n)=\begin{cases}    1& (n=1)\\    (-1)^k& (n\text{无平方数因数},n=\prod_{i=1}^k{p_i})\\    0& (n\text{有大于1的平方数因数})\end{cases}</script><script type="math/tex; mode=display">\sum_{d\mid n}\mu(d)=\begin{cases}    1& (n=1)\\    0& (n=0)\end{cases}\\\sum_{d\mid n}\frac{\mu(d)}{d}=\frac{\varphi(n)}{n}</script><h2 id="一些积性函数"><a href="#一些积性函数" class="headerlink" title="一些积性函数"></a>一些积性函数</h2><ul><li>$\varphi(n)$：欧拉函数</li><li>$\mu(n)$：莫比乌斯函数</li><li>$\gcd(n,k)$：（$k$ 固定时）最小公因数</li><li>$d(n)$：$n$ 的约数个数</li><li>$\sigma(n)$：$n$ 的约数和</li><li>$1(n)=1$</li><li><p>$id(n)=n$</p></li><li><p>$e(n)=\begin{cases}1&amp;(n=1)\\0&amp;(n\not=1)\end{cases}$</p></li></ul><h2 id="狄利克雷卷积"><a href="#狄利克雷卷积" class="headerlink" title="狄利克雷卷积"></a>狄利克雷卷积</h2><script type="math/tex; mode=display">h=f\times g\\h(n)=\sum_{i\mid n}{f(i)*g(\frac{n}{i})}</script><p>两个数论函数的狄利克雷卷积结果仍是一个数论函数</p><p>两个积性函数的狄利克雷卷积仍是一个积性函数</p><p>狄利克雷卷积满足交换律、结合律</p><h2 id="二项式定理"><a href="#二项式定理" class="headerlink" title="二项式定理"></a>二项式定理</h2><h2 id="Lucas定理"><a href="#Lucas定理" class="headerlink" title="Lucas定理"></a>Lucas定理</h2><hr><p>待补充……</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 BSGS</title>
      <link href="/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-BSGS/"/>
      <url>/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-BSGS/</url>
      
        <content type="html"><![CDATA[<p>B（拔）S（山）G（盖）S（世）没什么好总结的，就当水博客了</p><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><p>用于求这样的问题：</p><blockquote><p>给出 $a, b, p$</p><script type="math/tex; mode=display">a^x\equiv b\pmod p</script><p>求 $x$ 的最小非负整数解</p></blockquote><p><a href="https://www.luogu.com.cn/problem/P2485" target="_blank" rel="noopener">例题 Luogu P2485</a></p><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><p>先把 $x$ 拆分成 $i*t-j$ 的形式（$t=\lceil\sqrt{p}\rceil$）</p><script type="math/tex; mode=display">a^{i*t-j}\equiv b\pmod p\\a^{i*t}\equiv b*a^j\pmod p</script><p>枚举 $j\in [0,t]$ ，将 $b*a^j$ 放进哈希表（我这么懒肯定用 $map$ 水）</p><p>再枚举 $i\in [0,t]$ ，从哈希表中查找 $a^{i\ast t}$ ，找到即答案为 $i\ast t-j$</p><p>枚举 $i,j$ 都是 $O(\sqrt{p})$ 的</p><p><del>是不是很 easy</del></p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>这里只好放 P2485 的代码了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;LL, LL&gt; m;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">BSGS</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    m.clear();</span><br><span class="line">    b %= p;</span><br><span class="line">    <span class="keyword">if</span> (a % p == <span class="number">0</span>) &#123;<span class="comment">// 恶心的特判</span></span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LL t = <span class="built_in">ceil</span>(<span class="built_in">sqrt</span>(p));</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>, bn = b; i &lt;= t; ++i)</span><br><span class="line">        m[bn] = i, bn = bn * a % p;</span><br><span class="line">    a = power(a, t);</span><br><span class="line">    <span class="keyword">for</span> (LL i = <span class="number">0</span>, an = <span class="number">1</span>, j; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.count(an)) &#123;</span><br><span class="line">            j = m[an];</span><br><span class="line">            <span class="keyword">if</span> (i * t - j &gt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> i * t - j;</span><br><span class="line">        &#125;</span><br><span class="line">        an = an * a % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> BSGS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 FWT</title>
      <link href="/2020/01/29/2020-01-29-%E6%9D%BF%E5%AD%90-FWT/"/>
      <url>/2020/01/29/2020-01-29-%E6%9D%BF%E5%AD%90-FWT/</url>
      
        <content type="html"><![CDATA[<p>快速沃尔什变换，用于处理 $C_k=\sum_{i\otimes j=k}A_i*B_j$ （$\otimes$ 是集合运算符）几何卷积运算</p><p>对于 $A$ 求出 $fwt[A]$ ，使得 $fwt[C]=fwt[A]*fwt[B]$ ，于是就 $O(n)$ 了</p><p>我纯靠感性理解，更不会讲QAQ，这里只贴板子</p><p>几篇有帮助的博客：</p><ul><li><p><a href="https://www.cnblogs.com/ACMLCZH/p/8022502.html" target="_blank" rel="noopener">ACMLCZH的blog</a></p></li><li><p><a href="https://www.luogu.com.cn/blog/xht37/solution-p4717" target="_blank" rel="noopener">xht37的blog</a></p></li></ul><h2 id="or-或卷积"><a href="#or-或卷积" class="headerlink" title="$or$ 或卷积"></a>$or$ 或卷积</h2><p>$FWT$：</p><script type="math/tex; mode=display">fwt[a]=(fwt[a_0],\ fwt[a_0]+fwt[a_1])</script><p>$IFWT$：</p><script type="math/tex; mode=display">a=(a_0,\ a_0-a_1)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_or</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j)</span><br><span class="line">f[i+mid+j] = ((LL)f[i+j] * opt + f[i+mid+j] + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="and-与卷积"><a href="#and-与卷积" class="headerlink" title="$and$ 与卷积"></a>$and$ 与卷积</h2><p>非常相似呢，<del>只管粘过来一改就好</del></p><p>$FWT$：</p><script type="math/tex; mode=display">fwt[a]=(fwt[a_0]+fwt[a_1],\ fwt[a_1])</script><p>$IFWT$：</p><script type="math/tex; mode=display">a=(a_0-a_1,\ a_1)</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_and</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j)</span><br><span class="line">f[i+j] = ((LL)f[i+j] + f[i+mid+j] * opt + MOD) % MOD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="xor-异或卷积"><a href="#xor-异或卷积" class="headerlink" title="$xor$ 异或卷积"></a>$xor$ 异或卷积</h2><p>最恶心的</p><p>$FWT$：</p><script type="math/tex; mode=display">fwt[a]=(fwt[a_0]+fwt[a_1],\ fwt[a_0]-fwt[a_1])</script><p>$IFWT$：</p><script type="math/tex; mode=display">a=(\frac{a_0+a_1}{2},\ \frac{a_0-a_1}{2})</script><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FWT_xor</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> opt = <span class="number">1</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt;&lt; <span class="number">1</span> &lt;= n; mid &lt;&lt;= <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i += mid &lt;&lt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j) &#123;</span><br><span class="line"><span class="keyword">int</span> fx = f[i+j], fy = f[i+mid+j];</span><br><span class="line">f[i+j] = (LL)opt * (fx + fy) % MOD;</span><br><span class="line">f[i+mid+j] = (LL)opt * (fx - fy + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（$IFWT$ 时，opt 应为 $2^{-1}$）</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FWT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 多项式四则运算</title>
      <link href="/2020/01/24/2020-01-24-%E6%80%BB%E7%BB%93-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/"/>
      <url>/2020/01/24/2020-01-24-%E6%80%BB%E7%BB%93-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h2 id="前置知识：FFT-NTT"><a href="#前置知识：FFT-NTT" class="headerlink" title="前置知识：FFT/NTT"></a>前置知识：FFT/NTT</h2><p>见<a href="https://true-banana.github.io/2020/01/17/2020-01-17-板子-FFTNTT/">板子 FFT/NTT</a></p><h2 id="多项式加减"><a href="#多项式加减" class="headerlink" title="多项式加减"></a>多项式加减</h2><p>在系数表示法下直接逐位加减</p><h2 id="多项式乘法"><a href="#多项式乘法" class="headerlink" title="多项式乘法"></a>多项式乘法</h2><p>两式先通过 DFT（FFT/NTT）化为点值表示法，逐位相乘，再 IDFT 回来</p><p>这里放个封装的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> *y, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(X, <span class="number">0</span>, <span class="keyword">sizeof</span> X), <span class="built_in">memset</span>(Y, <span class="number">0</span>, <span class="keyword">sizeof</span> Y);<span class="comment">// 复制一份</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (lim &gt;&gt; <span class="number">1</span>); ++i)</span><br><span class="line">X[i] = x[i], Y[i] = y[i];</span><br><span class="line">NTT(X, lim, <span class="number">1</span>), NTT(Y, lim, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">X[i] = <span class="number">1l</span>l * X[i] * Y[i] % MOD;</span><br><span class="line">NTT(X, lim, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">x[i] = X[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多项式求逆"><a href="#多项式求逆" class="headerlink" title="多项式求逆"></a>多项式求逆</h2><p>引用了 <a href="https://www.luogu.com.cn/user/37834" target="_blank" rel="noopener">autoint</a> 的 <a href="https://www.luogu.com.cn/blog/autoint/solution-p4238" target="_blank" rel="noopener">这篇博客</a></p><script type="math/tex; mode=display">A\times B\equiv 1\quad (mod\ x^n)\\A\times B'\equiv 1\quad (mod\ x^{\frac{n}{2}})\\A\times (B-B')\equiv 0\quad (mod\ x^{\frac{n}{2}})\\B-B'\equiv 0\quad (mod\ x^{\frac{n}{2}})\\(B-B')^2\equiv 0\quad(mod\ x^n)\\A\times(B^2-2BB'+B'^2)\equiv 0\quad(mod\ x^n)\\B-2B'+AB'^2\equiv 0\quad (mod\ x^n)\\B\equiv 2B'-AB'^2\quad (mod\ x^n)</script><p>据此可以倍增（可以把 B 数组滚动）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">inv</span><span class="params">(<span class="keyword">int</span> *x, <span class="keyword">int</span> y[<span class="number">2</span>][N], <span class="keyword">int</span> &amp;cur, <span class="keyword">int</span> lim)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> base = <span class="number">1</span>, now = <span class="number">2</span>, len = <span class="number">1</span>;</span><br><span class="line">cur = <span class="number">0</span>;</span><br><span class="line">y[cur][<span class="number">0</span>] = power(x[<span class="number">0</span>], MOD - <span class="number">2</span>);</span><br><span class="line"><span class="keyword">while</span> (base &lt;= lim &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line">calc_rev(now, len);</span><br><span class="line">cur ^= <span class="number">1</span>;</span><br><span class="line"><span class="built_in">memset</span>(y[cur], <span class="number">0</span>, <span class="keyword">sizeof</span> y[cur]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; ++i)</span><br><span class="line">y[cur][i] = (y[cur^<span class="number">1</span>][i] &lt;&lt; <span class="number">1</span>) % MOD;</span><br><span class="line">mul(y[cur^<span class="number">1</span>], y[cur^<span class="number">1</span>], now);</span><br><span class="line">mul(y[cur^<span class="number">1</span>], x, now);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; base; ++i)</span><br><span class="line">y[cur][i] = plus_mod(y[cur][i], MOD - y[cur^<span class="number">1</span>][i]);</span><br><span class="line">base &lt;&lt;= <span class="number">1</span>, now &lt;&lt;= <span class="number">1</span>, len++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>咕咕咕。。。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 K-D Tree</title>
      <link href="/2020/01/20/2020-01-20-%E6%9D%BF%E5%AD%90-K-D-Tree/"/>
      <url>/2020/01/20/2020-01-20-%E6%9D%BF%E5%AD%90-K-D-Tree/</url>
      
        <content type="html"><![CDATA[<p>用于处理高维空间组织点</p><p>大概就是在某个维度下从坐标中位数二分，最后形成一棵二叉树</p><p>插入删除会导致树不平衡，需要类似替罪羊树的拍扁重建</p><p>这里先放个 2-D 的吧，针对<a href="https://www.luogu.com.cn/problem/P4169" target="_blank" rel="noopener">模板题P4169</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">6e5</span> + <span class="number">9</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Alph = <span class="number">0.75</span>;<span class="comment">// 平衡因子</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维下的坐标及树节点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pos</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x[<span class="number">2</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> minx[<span class="number">2</span>], maxx[<span class="number">2</span>], ls, rs, sz;<span class="comment">// minx，maxx存坐标范围</span></span><br><span class="line">Pos p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, ans, root, cnt, nd;<span class="comment">// nd为此时维度</span></span><br><span class="line">Pos a[N];</span><br><span class="line">Node tr[N];</span><br><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; trash;<span class="comment">// 垃圾回收</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按照某个维度排序用cmp</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(Pos A, Pos B) &#123;</span><br><span class="line"><span class="keyword">return</span> A.x[nd] &lt; B.x[nd];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 新建节点</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">new_node</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">if</span> (trash.empty())</span><br><span class="line">x = ++cnt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">x = trash.front(), trash.pop();</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新信息</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ls = tr[x].ls, rs = tr[x].rs;</span><br><span class="line">    <span class="comment">// 范围</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i) &#123;</span><br><span class="line">tr[x].minx[i] = tr[x].maxx[i] = tr[x].p.x[i];</span><br><span class="line"><span class="keyword">if</span> (ls)</span><br><span class="line">tr[x].minx[i] = min(tr[x].minx[i], tr[ls].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[ls].maxx[i]);</span><br><span class="line"><span class="keyword">if</span> (rs)</span><br><span class="line">tr[x].minx[i] = min(tr[x].minx[i], tr[rs].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[rs].maxx[i]);</span><br><span class="line">&#125;</span><br><span class="line">tr[x].sz = tr[ls].sz + tr[rs].sz + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建树（包括重建）</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt; r)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> x = new_node(), mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">nd = d, nth_element(a+l, a+mid, a+r+<span class="number">1</span>), tr[x].p = a[mid];<span class="comment">// 找中位数</span></span><br><span class="line">tr[x].ls = build(l, mid<span class="number">-1</span>, d^<span class="number">1</span>), tr[x].rs = build(mid+<span class="number">1</span>, r, d^<span class="number">1</span>);</span><br><span class="line">push_up(x);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拍扁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pia</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].ls)</span><br><span class="line">pia(tr[x].ls, num);</span><br><span class="line">a[num+tr[tr[x].ls].sz+<span class="number">1</span>] = tr[x].p, trash.push(x);<span class="comment">// 把点放入a数组便于建树</span></span><br><span class="line"><span class="keyword">if</span> (tr[x].rs)</span><br><span class="line">pia(tr[x].rs, num + tr[tr[x].ls].sz + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查平衡</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Alph * tr[x].sz &lt; tr[tr[x].ls].sz || Alph * tr[x].sz &lt; tr[tr[x].rs].sz)</span><br><span class="line">pia(x, <span class="number">0</span>), x = build(<span class="number">1</span>, tr[x].sz, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(Pos tp, <span class="keyword">int</span> &amp;x, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x) &#123;</span><br><span class="line">x = new_node(), tr[x].p = tp, tr[x].ls = tr[x].rs = <span class="number">0</span>, push_up(x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tp.x[d] &lt;= tr[x].p.x[d])</span><br><span class="line">insert(tp, tr[x].ls, d^<span class="number">1</span>);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">insert(tp, tr[x].rs, d^<span class="number">1</span>);</span><br><span class="line">push_up(x), check(x, d);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>顺便放一下 K-D Tree 在该题的运用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">dist</span><span class="params">(Pos A, Pos B)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">abs</span>(A.x[<span class="number">0</span>] - B.x[<span class="number">0</span>]) + <span class="built_in">abs</span>(A.x[<span class="number">1</span>] - B.x[<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 求点到矩形（K-D Tree上一个子树）的曼哈顿距离</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">getdis</span><span class="params">(Pos tp, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">1</span>; ++i)</span><br><span class="line">sum += max(<span class="number">0</span>, tp.x[i] - tr[x].maxx[i]) + max(<span class="number">0</span>, tr[x].minx[i] - tp.x[i]);<span class="comment">// 不理解就手玩一下</span></span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">query</span><span class="params">(Pos tp, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ans = min(ans, dist(tp, tr[x].p));</span><br><span class="line"><span class="keyword">int</span> dl = INF, dr = INF;</span><br><span class="line"><span class="keyword">if</span> (tr[x].ls) </span><br><span class="line">dl = getdis(tp, tr[x].ls);</span><br><span class="line"><span class="keyword">if</span> (tr[x].rs)</span><br><span class="line">dr = getdis(tp, tr[x].rs);</span><br><span class="line">    <span class="comment">// 爆搜，先搜最优的</span></span><br><span class="line"><span class="keyword">if</span> (dl &lt; dr) &#123;</span><br><span class="line"><span class="keyword">if</span> (dl &lt; ans)</span><br><span class="line">query(tp, tr[x].ls);</span><br><span class="line"><span class="keyword">if</span> (dr &lt; ans)</span><br><span class="line">query(tp, tr[x].rs);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (dr &lt; ans)</span><br><span class="line">query(tp, tr[x].rs);</span><br><span class="line"><span class="keyword">if</span> (dl &lt; ans)</span><br><span class="line">query(tp, tr[x].ls);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// query</span></span><br><span class="line">ans = INF, query(tp, root), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br></pre></td></tr></table></figure><p>我tcl，只会模板题</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K-DTree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2467 [SDOI2010]地精部落</title>
      <link href="/2020/01/19/2020-01-19-%E9%A2%98%E8%A7%A3-P2467-SDOI2010%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD/"/>
      <url>/2020/01/19/2020-01-19-%E9%A2%98%E8%A7%A3-P2467-SDOI2010%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD/</url>
      
        <content type="html"><![CDATA[<h2 id="题意"><a href="#题意" class="headerlink" title="题意"></a>题意</h2><p><a href="https://www.luogu.com.cn/problem/P2467" target="_blank" rel="noopener">题面</a></p><p>求长度 $n$ 的交错序列的方案数</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>长度为 $i$ 的序列对于长度为 $i-1$ 的序列来说多了<strong>最大值</strong> $i$ ，所有我们可以枚举这个最大值的位置</p><p>为保证是交错序列，那么最大值位置的前驱和后继都必须是“山谷”</p><p>从最大值的位置 $j$ 劈开，问题该状态便可以转化成两个子状态：</p><p>长度为 $j$ 的结尾下降的序列方案数和长度为 $i-1-j$ 的开头上升的序列方案数</p><p>结尾下降和开头上升本质相同</p><p>最后方案数要乘上组合 $C_{i-1}^j$ （从 1 至 $i-1$ 中选出 $j$ 个数组成最大值前面的序列，离散化后方案数相同）</p><h2 id="状态表示-amp-转移方程"><a href="#状态表示-amp-转移方程" class="headerlink" title="状态表示 &amp; 转移方程"></a>状态表示 &amp; 转移方程</h2><p>设 <code>f[i]</code>表示长度为 $i$ 的交错序列的方案数</p><p>显然，开头上升和开头下降的方案一样多，开头上升的方案数就是总方案数的一半</p><script type="math/tex; mode=display">\huge f[i] = \sum_{j=0}^{i-1}\frac{f[j]}{2}\cdot\frac{f[i-1-j]}{2}\cdot C_{i-1}^{j}</script><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><p><code>f[1] = 1</code>，除以2不就。。。</p><p>其实长度为1的序列可以看成两种情况（“山谷”或“山峰”）</p><p>至于<code>f[0]</code>，当序列最大值置于最左侧（$j=0$）时方案数不能乘0啊</p><p>所以<code>f[0] = f[1] = 2</code></p><h3 id="取模"><a href="#取模" class="headerlink" title="取模"></a>取模</h3><p>问题来了，$p$ 不为质数，不能求2的逆元，且 $a=b (mod p)$ 不等价于 $\frac{a}{2}=\frac{b}{2} (mod p)$</p><p>怎样除以 2 ？</p><p>因为 $x mod p=(x mod 2p) mod p$ （ $x$ 为 $mod 2p$ 意义下的偶数）</p><p>所以 $\frac{x}{2} mod p=(\frac{x mod 2p}{2}) mod p$</p><p>过程中模 $2p$ 的意义下随便除以2，最后再模 $p$ 输出即可</p><h3 id="空间"><a href="#空间" class="headerlink" title="空间"></a>空间</h3><p><del>似乎、听说、大概</del>递推组合数的数组空间开不下，滚呗</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">read(n), read(p);</span><br><span class="line">c[<span class="number">0</span>][<span class="number">0</span>] = c[<span class="number">1</span>][<span class="number">0</span>] = c[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">f[<span class="number">0</span>] = f[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">ll p2 = p * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i; ++j)</span><br><span class="line">        c[i&amp;<span class="number">1</span>][j] = (c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j] + c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j<span class="number">-1</span>]) % p2;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i - <span class="number">1</span>; ++j)</span><br><span class="line">        f[i] = (<span class="number">1l</span>l * c[i&amp;<span class="number">1</span>^<span class="number">1</span>][j] * f[j] / <span class="number">2</span> % p2 * f[i<span class="number">-1</span>-j] / <span class="number">2</span> + f[i]) % p2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, f[n] % p);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 左偏树</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B7%A6%E5%81%8F%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>左偏树本质是堆，在满足父亲比两个儿子的$val$都大（小）的时候保证</p><script type="math/tex; mode=display">dist[ls] >= dist[rs]</script><script type="math/tex; mode=display">dist[x] = dist[rs] + 1</script><p>于是就支持$merge$快速合并</p><p>$pop$就乱搞，合并两子树就行</p><p>可以用并查集维护所在堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ch[N][<span class="number">2</span>], dist[N], fa[N], val[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x || !y)</span><br><span class="line"><span class="keyword">return</span> x | y;</span><br><span class="line"><span class="keyword">if</span> (val[x] &gt; val[y])</span><br><span class="line">swap(x, y);</span><br><span class="line">ch[x][<span class="number">1</span>] = merge(ch[x][<span class="number">1</span>], y);</span><br><span class="line"><span class="keyword">if</span> (dist[ch[x][<span class="number">0</span>]] &lt; dist[ch[x][<span class="number">1</span>]])</span><br><span class="line">swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">dist[x] = dist[ch[x][<span class="number">1</span>]] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">val[x] = <span class="number">-1</span>, fa[ch[x][<span class="number">0</span>]] = fa[ch[x][<span class="number">1</span>]] = fa[x] = merge(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集初始化</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    fa[i] = i;</span><br><span class="line"></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="keyword">int</span> fx = find(x), fy = find(y);</span><br><span class="line">fa[fx] = fa[fy] = merge(fx, fy);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 左偏树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OI学习规划</title>
      <link href="/2020/01/17/2020-01-17-OI%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/"/>
      <url>/2020/01/17/2020-01-17-OI%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dp</span><br><span class="line">数据结构</span><br><span class="line">数学</span><br><span class="line">图论</span><br><span class="line">搜索</span><br><span class="line">字符串</span><br><span class="line">计算几何</span><br><span class="line">思想</span><br><span class="line">杂项</span><br></pre></td></tr></table></figure><p>目前一段时间的规划，随时添加</p><hr><h2 id="dp"><a href="#dp" class="headerlink" title="dp"></a>dp</h2><ul><li><del>普通</del>dp</li><li>背包dp</li><li>树形dp</li><li>区间dp</li><li>状压dp</li><li>数位dp</li><li>计数dp</li><li>*插头dp</li><li>*动态dp</li></ul><h3 id="dp优化"><a href="#dp优化" class="headerlink" title="dp优化"></a>dp优化</h3><ul><li>数据结构</li><li>单调队列</li><li>斜率优化</li><li>二进制拆分多重背包</li><li>四边形不等式</li></ul><hr><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul><li>基础数据结构<ul><li>队列／栈</li><li>哈希表</li><li>堆</li></ul></li><li>单调栈／单调队列</li><li>并查集</li><li>ST表</li><li>树状数组</li><li>线段树<ul><li>zkw线段树</li><li>动态开点</li></ul></li><li>左偏树</li><li>Trie树</li><li>平衡树<ul><li>Treap／fhq Treap</li><li>Splay</li><li>替罪羊树</li><li>zyf树</li></ul></li><li>K-D Tree</li><li>可持久化数据结构<ul><li>Trie</li><li>线段树（主席树）</li><li>平衡树</li></ul></li><li>LCT</li><li>树套树<ul><li>线段树套线段树</li><li>线段树套平衡树</li></ul></li><li>虚树</li></ul><hr><h2 id="数学"><a href="#数学" class="headerlink" title="数学"></a>数学</h2><ul><li>快速幂</li><li>高精度运算</li></ul><h3 id="数论"><a href="#数论" class="headerlink" title="数论"></a>数论</h3><ul><li>gcd／lcm</li><li>扩展欧几里德</li><li>欧拉定理／费马小定理</li><li>裴蜀定理</li><li>乘法逆元<ul><li>exgcd</li><li>快速幂</li><li>线性求逆元</li></ul></li><li>中国剩余定理</li><li>卢卡斯定理</li><li>*莫比乌斯反演</li><li>*杜教筛</li></ul><h3 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h3><ul><li>高斯消元</li><li>线性基</li><li>牛顿迭代法</li></ul><h3 id="组合数学"><a href="#组合数学" class="headerlink" title="组合数学"></a>组合数学</h3><ul><li>列表／枚举／瞎搞</li><li>卡特兰数</li><li>斯特林数</li><li>康托展开</li><li>容斥原理</li><li>抽屉原理</li></ul><h3 id="概率／期望"><a href="#概率／期望" class="headerlink" title="概率／期望"></a>概率／期望</h3><h3 id="多项式"><a href="#多项式" class="headerlink" title="多项式"></a>多项式</h3><ul><li>FFT</li><li>NTT</li><li>。。。全家桶</li></ul><h3 id="群论"><a href="#群论" class="headerlink" title="群论"></a>群论</h3><hr><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><ul><li>拓扑排序</li><li>最小生成树<ul><li>Kruskal</li><li>Prim</li></ul></li><li>最短路<ul><li>Dijkstra</li><li>SPFA</li><li>Floyd</li></ul></li><li>二分图匹配<ul><li>匈牙利算法</li><li>最大流</li></ul></li><li>Tarjan<ul><li>强连通分量</li><li>割点/割边</li></ul></li></ul><h3 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h3><ul><li>最大流<ul><li>Dinic</li></ul></li><li>最小割</li><li>费用流</li><li>上下界网络流</li></ul><h3 id="树论"><a href="#树论" class="headerlink" title="树论"></a>树论</h3><ul><li>LCA<ul><li>倍增</li><li>树链剖分</li><li>LCT</li></ul></li><li>树的重心</li><li>树分治<ul><li>点分治</li><li>边分治</li></ul></li><li>树链剖分</li></ul><hr><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><ul><li>双向搜索</li><li>迭代加深</li><li>A*</li><li>IDA*</li><li>Dancing Links</li></ul><hr><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>Hash</li><li>Trie树</li><li>KMP匹配</li><li>Manacher</li><li>AC自动机</li><li>后缀数组</li><li>后缀自动机</li></ul><hr><h2 id="计算几何"><a href="#计算几何" class="headerlink" title="计算几何"></a>计算几何</h2><p>咕咕咕</p><hr><h2 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h2><ul><li>分治</li><li>贪心</li><li>二分</li><li>前缀和/差分</li><li>打表找规律</li><li>手玩</li></ul><hr><h2 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h2><ul><li>I/O优化</li><li>离散化</li><li>CDQ分治</li><li>整体二分</li><li>莫队算法</li><li>分数规划</li></ul><hr><p>我好菜啊，什么都不会~</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>板子 主席树</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E4%B8%BB%E5%B8%AD%E6%A0%91/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E4%B8%BB%E5%B8%AD%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>我太懒了，上板子</p><p><strong><a href="https://www.luogu.com.cn/problem/P3834" target="_blank" rel="noopener">luogu P3834</a> code</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Seg_Tree</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt, n;</span><br><span class="line"><span class="keyword">int</span> rt[N], sum[N&lt;&lt;<span class="number">5</span>], ls[N&lt;&lt;<span class="number">5</span>], rs[N&lt;&lt;<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">sum[suc] = sum[ls[suc]] + sum[rs[suc]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">sum[suc] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">build(ls[suc] = ++cnt, l, mid), build(rs[suc] = ++cnt, mid+<span class="number">1</span>, r);</span><br><span class="line">push_up(suc);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> pre, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">ls[suc] = ls[pre], rs[suc] = rs[pre], sum[suc] = sum[pre] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt;= mid)</span><br><span class="line">update(ls[suc] = ++cnt, ls[pre], l, mid, x);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">update(rs[suc] = ++cnt, rs[pre], mid+<span class="number">1</span>, r, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l &gt;= r)</span><br><span class="line"><span class="keyword">return</span> l;</span><br><span class="line"><span class="keyword">int</span> t = sum[ls[v]] - sum[ls[u]], mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= t)</span><br><span class="line"><span class="keyword">return</span> query(ls[u], ls[v], l, mid, k);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> query(rs[u], rs[v], mid+<span class="number">1</span>, r, k - t);</span><br><span class="line">&#125;</span><br><span class="line">&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">read(a[i]), b[i] = a[i];</span><br><span class="line">sort(b+<span class="number">1</span>, b+n+<span class="number">1</span>);</span><br><span class="line">tr.n = unique(b+<span class="number">1</span>, b+n+<span class="number">1</span>) - b - <span class="number">1</span>;</span><br><span class="line">tr.build(tr.rt[<span class="number">0</span>] = ++tr.cnt, <span class="number">1</span>, tr.n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = lower_bound(b+<span class="number">1</span>, b+tr.n+<span class="number">1</span>, a[i]) - b;</span><br><span class="line">tr.update(tr.rt[i] = ++tr.cnt, tr.rt[i<span class="number">-1</span>], <span class="number">1</span>, tr.n, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> l, r, k;</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line">read(l), read(r), read(k);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, b[tr.query(tr.rt[l<span class="number">-1</span>], tr.rt[r], <span class="number">1</span>, tr.n, k)]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 主席树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 CDQ分治</title>
      <link href="/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-CDQ%E5%88%86%E6%B2%BB/"/>
      <url>/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-CDQ%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>咕了几个月的玩意。。。</p><p>先贴几个板子，总结后面补 /youl</p><hr><p>P1908 逆序对</p><p><a href="https://www.luogu.com.cn/problem/P3374" target="_blank" rel="noopener">P2274 树状数组1</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">ll id, val, type;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id == x.id ? type &lt; x.type : id &lt; x.id;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">CDQ(l, mid), CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">int</span> x = l, y = mid+<span class="number">1</span>, k = l;</span><br><span class="line">ll sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= mid &amp;&amp; y &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[x] &lt; a[y]) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[x].type == <span class="number">1</span>)</span><br><span class="line">sum += a[x].val;</span><br><span class="line">t[k++] = a[x++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (a[y].type == <span class="number">2</span>)</span><br><span class="line">ans[a[y].val] -= sum;</span><br><span class="line"><span class="keyword">if</span> (a[y].type == <span class="number">3</span>)</span><br><span class="line">ans[a[y].val] += sum;</span><br><span class="line">t[k++] = a[y++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (x &lt;= mid)</span><br><span class="line">t[k++] = a[x++];</span><br><span class="line"><span class="keyword">while</span> (y &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (a[y].type == <span class="number">2</span>)</span><br><span class="line">ans[a[y].val] -= sum;</span><br><span class="line"><span class="keyword">if</span> (a[y].type == <span class="number">3</span>)</span><br><span class="line">ans[a[y].val] += sum;</span><br><span class="line">t[k++] = a[y++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= r; i++)</span><br><span class="line">a[i] = t[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, t; i &lt;= n; i++)</span><br><span class="line">    t = read(), a[++cnta] = (Node)&#123;i, t, <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">    ll c = read(), x = read(), y = read();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>)</span><br><span class="line">        a[++cnta] = (Node)&#123;x, y, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        a[++cnta] = (Node)&#123;x<span class="number">-1</span>, ++cntq, <span class="number">2</span>&#125;;</span><br><span class="line">        a[++cnta] = (Node)&#123;y, cntq, <span class="number">3</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.luogu.com.cn/problem/P3810" target="_blank" rel="noopener">P3810 陌上花开</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> a, b, c, cnt, ans;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> ==(<span class="keyword">const</span> Node &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, bn, maxk;</span><br><span class="line"><span class="keyword">int</span> cnt[N];</span><br><span class="line">Node a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp1d</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (x.a == y.a)</span><br><span class="line"><span class="keyword">return</span> x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b;</span><br><span class="line"><span class="keyword">return</span> x.a &lt; y.a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2d</span><span class="params">(Node x, Node y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Bit_tree</span> &#123;</span>...&#125; tr;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CDQ</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">CDQ(l, mid), CDQ(mid+<span class="number">1</span>, r);</span><br><span class="line">sort(a+l, a+mid+<span class="number">1</span>, cmp2d);</span><br><span class="line">sort(a+mid+<span class="number">1</span>, a+r+<span class="number">1</span>, cmp2d);</span><br><span class="line"><span class="keyword">int</span> i = l, j = mid + <span class="number">1</span>, k = l;</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; a[i].b &lt;= a[j].b)</span><br><span class="line">tr.add(a[i].c, a[i].cnt), i++;</span><br><span class="line">a[j].ans += tr.query(a[j].c), j++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (j = l; j &lt; i; ++j)</span><br><span class="line">tr.add(a[j].c, -a[j].cnt);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(bn), read(maxk);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i)</span><br><span class="line">read(b[i].a), read(b[i].b), read(b[i].c);</span><br><span class="line">sort(b+<span class="number">1</span>, b+bn+<span class="number">1</span>, cmp1d);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= bn; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (b[i] == b[i<span class="number">-1</span>])</span><br><span class="line">a[n].cnt++;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">a[++n] = b[i], a[n].cnt++;</span><br><span class="line">&#125;</span><br><span class="line">CDQ(<span class="number">1</span>, n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">cnt[a[i].ans + a[i].cnt - <span class="number">1</span>] += a[i].cnt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bn; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, cnt[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CDQ分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 FFT/NTT</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-FFTNTT/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-FFTNTT/</url>
      
        <content type="html"><![CDATA[<h2 id="Rader排序"><a href="#Rader排序" class="headerlink" title="Rader排序"></a>Rader排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (lim = <span class="number">1</span>; lim &lt;= n; lim &lt;&lt;= <span class="number">1</span>, len++);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">calc_rev</span><span class="params">(<span class="keyword">int</span> lim, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; lim; ++i)</span><br><span class="line">rev[i] = (rev[i&gt;&gt;<span class="number">1</span>] &gt;&gt; <span class="number">1</span>) | ((i &amp; <span class="number">1</span>) &lt;&lt; (len - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="FFT"><a href="#FFT" class="headerlink" title="FFT"></a>FFT</h2><h3 id="封装复数"><a href="#封装复数" class="headerlink" title="封装复数"></a>封装复数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Complex</span> &#123;</span></span><br><span class="line"><span class="keyword">double</span> x, y;</span><br><span class="line">Complex(<span class="keyword">double</span> xx = <span class="number">0</span>, <span class="keyword">double</span> yy = <span class="number">0</span>) &#123;</span><br><span class="line">x = xx, y = yy;</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> +(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(x + t.x, y + t.y);</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> -(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(x - t.x, y - t.y);</span><br><span class="line">&#125;</span><br><span class="line">Complex <span class="keyword">operator</span> *(<span class="keyword">const</span> Complex &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> Complex(x * t.x - y * t.y, y * t.x + x * t.y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="FFT-1"><a href="#FFT-1" class="headerlink" title="FFT()"></a>FFT()</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> Pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">FFT</span><span class="params">(Complex *f, <span class="keyword">int</span> lim, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">swap(f[i], f[rev[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">Complex <span class="title">wn</span><span class="params">(<span class="built_in">cos</span>(Pi / mid), opt * <span class="built_in">sin</span>(Pi / mid))</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += mid &lt;&lt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="function">Complex <span class="title">w</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, w = w * wn) &#123;</span><br><span class="line">Complex tx = f[i+j], ty = w * f[i+mid+j];</span><br><span class="line">f[i+j] = tx + ty, f[i+mid+j] = tx - ty;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">-1</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            f[i].x /= n, f[i].y /= n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三次变两次优化"><a href="#三次变两次优化" class="headerlink" title="三次变两次优化"></a>三次变两次优化</h3><p>把 f2 放到 f1 的虚部上，DFT一遍，平方，再把虚部取出来除以2即可</p><h2 id="NTT"><a href="#NTT" class="headerlink" title="NTT"></a>NTT</h2><p>用 int 时注意模好</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> G = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> invG = <span class="number">332748118</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">NTT</span><span class="params">(<span class="keyword">int</span> *f, <span class="keyword">int</span> lim, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line"><span class="keyword">if</span> (i &lt; rev[i])</span><br><span class="line">swap(f[i], f[rev[i]]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> mid = <span class="number">1</span>; mid &lt; lim; mid &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> wn = power(opt == <span class="number">1</span> ? G : invG, (MOD - <span class="number">1</span>) / (mid &lt;&lt; <span class="number">1</span>));</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; i += (mid &lt;&lt; <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="keyword">int</span> w = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; mid; ++j, w = (<span class="number">1l</span>l * w * wn) % MOD) &#123;</span><br><span class="line">LL tx = f[i+j], ty = (<span class="number">1l</span>l * w * f[i+mid+j]) % MOD;</span><br><span class="line">f[i+j] = (<span class="number">0l</span>l + tx + ty) % MOD;</span><br><span class="line">f[i+mid+j] = (<span class="number">0l</span>l + tx - ty + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">if</span> (opt == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> invlim = power(lim, MOD - <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lim; ++i)</span><br><span class="line">            f[i] = <span class="number">1l</span>l * f[i] * invlim % MOD;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FFT/NTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蒟蒻的zz码风</title>
      <link href="/2020/01/17/2020-01-17-%E8%92%9F%E8%92%BB%E7%9A%84zz%E7%A0%81%E9%A3%8E/"/>
      <url>/2020/01/17/2020-01-17-%E8%92%9F%E8%92%BB%E7%9A%84zz%E7%A0%81%E9%A3%8E/</url>
      
        <content type="html"><![CDATA[<p>自认为码风就像代码的脸，无论是调试还是写题解都极其重要</p><p>下面是我的码风，莫喷</p><h2 id="空格-amp-tab"><a href="#空格-amp-tab" class="headerlink" title="空格 &amp; tab"></a>空格 &amp; tab</h2><p><strong>松散胜于紧凑</strong></p><ul><li>tab宽度4</li><li>运算符前后加空格</li><li><code>,</code> 后加空格</li><li>嫌挤的地方加空格</li><li>大括号不换行（少说这个，引起战争）</li></ul><p>大概一个 a+b 写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; a + b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码块分布"><a href="#代码块分布" class="headerlink" title="代码块分布"></a>代码块分布</h2><p>意思相近的语句、函数写到一块</p><p>大块数据结构包装起来</p><p>各个代码块间加空行（我乱加空行的怪癖改不掉）</p><p>顺序嘛：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快读</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> TT&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(TT &amp;x)</span> </span>&#123; <span class="comment">/*...*/</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 宏定义/结构体定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ... ...</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量定义</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = ...;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量定义</span></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数/包装用的结构体</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>当然我喜欢总体套一个 namespace ，看<a href="https://banana.blog.luogu.org/tong-guo-namespace-fang-zhi-ming-ming-chong-tu" target="_blank" rel="noopener">这里</a></p><h2 id="压行"><a href="#压行" class="headerlink" title="压行"></a>压行</h2><p>曾经我是痛恨压行的，如今自己成为了曾经讨厌的人。。。</p><p><strong>代码还是简洁的好</strong></p><p>不过自认为压行并不是凑到一块那么简单</p><p>我曾见过这样的压行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=n+k+<span class="number">1</span>;++i)cur[i]=head[i];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(deep,<span class="number">0x3f</span>,<span class="keyword">sizeof</span>(deep));<span class="built_in">memset</span>(inq,<span class="number">0</span>,<span class="keyword">sizeof</span>(inq));</span><br><span class="line">    q.push(s);inq[s]=<span class="literal">true</span>;deep[s]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> u=q.front(),v;q.pop();inq[u]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=head[u];i;i=e[i].nxt)&#123;v=e[i].to;</span><br><span class="line">            <span class="keyword">if</span>(deep[v]&gt;deep[u]+<span class="number">1</span>&amp;&amp;e[i].flow)&#123;</span><br><span class="line">                deep[v]=deep[u]+<span class="number">1</span>;<span class="keyword">if</span>(!inq[v])&#123;q.push(v);inq[v]=<span class="literal">true</span>;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t]!=INF;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>不是我想针对谁，这样压行太拙劣了</del></p><p>压行要有原则和规范</p><ul><li><p>一行内尽量不出现多个<code>;</code></p></li><li><p><code>{</code> 后不要写东西， <code>}</code>另起一行（大括号一般使用时）</p></li><li><p>不好理解或过于复杂的代码不压行</p></li><li><p><strong>熟练运用 C++ 语言特性来缩减语句</strong></p><ul><li><code>for/while</code> 等里面只有一句时不加大括号</li><li>用<code>,</code>连接较短语句，作为一句（有时候还能少个大括号呢）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt;= n; ++i)</span><br><span class="line">   read(u), read(v), add(u, v);</span><br></pre></td></tr></table></figure><ul><li>多用三目运算符代替简单的 <code>if/else</code> 判断</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">get(fa) == get(x) ? rotate(fa) : rotate(x);</span><br><span class="line">(tag ? a1 : a2)[i] = x;<span class="comment">// 雾</span></span><br></pre></td></tr></table></figure><ul><li>多使用结构体的整体赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">e[++cnt] = (Edge)&#123;head[u], v&#125;;</span><br></pre></td></tr></table></figure><ul><li>运用<code>&amp;&amp;</code> <code>||</code>的短路特性</li><li>部分<code>()</code> <code>[]</code>中嵌套一些简单赋值</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> ((v = e[i].to) != fa)</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure></li></ul><p><del>显然我的压行优越得多</del></p><hr><p>总之敲代码要心情愉悦~</p><p>最后附上我美轮美奂的 vscode</p><blockquote><p>update 2020.1.18</p><p>有人说“美轮美奂”不应该在这用，好吧我语文不好，<del>只好说把我的VSCODE比喻为华丽的建筑</del></p></blockquote><p><img src="https://s2.ax1x.com/2019/12/15/QfFSPJ.jpg" alt=""></p><p>欢迎交流互鉴</p><hr><p><del>平写题解都没见你bb这么多</del></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>板子 Link-Cut Tree</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Link-Cut-Tree/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Link-Cut-Tree/</url>
      
        <content type="html"><![CDATA[<p>多敲多理解，适合小黄鸭调试的数据结构</p><p>发现还是不要包装每个节点的好，好看还常数小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Link_Cut_Tree</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fa[N], ch[N][<span class="number">2</span>], sum[N], val[N], rev[N];</span><br><span class="line">    <span class="keyword">int</span> stk[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">not_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ch[fa[x]][<span class="number">0</span>] == x || ch[fa[x]][<span class="number">1</span>] == x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        sum[x] = sum[ch[x][<span class="number">0</span>]] ^ sum[ch[x][<span class="number">1</span>]] ^ val[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        swap(ch[x][<span class="number">0</span>], ch[x][<span class="number">1</span>]), rev[x] ^= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rev[x]) &#123;</span><br><span class="line">            rev[x] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">                reverse(ch[x][<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span> (ch[x][<span class="number">1</span>])</span><br><span class="line">                reverse(ch[x][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> f = fa[x], gf = fa[f], w = which(x), y = ch[x][w^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (not_root(f))</span><br><span class="line">            ch[gf][which(f)] = x;</span><br><span class="line">        ch[x][w^<span class="number">1</span>] = f, ch[f][w] = y;</span><br><span class="line">        <span class="keyword">if</span> (y)</span><br><span class="line">            fa[y] = f;</span><br><span class="line">        fa[f] = x, fa[x] = gf;</span><br><span class="line">        push_up(f);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> top = <span class="number">0</span>, f = x;</span><br><span class="line">        stk[++top] = x;</span><br><span class="line">        <span class="keyword">while</span> (not_root(f))</span><br><span class="line">            stk[++top] = f = fa[f];</span><br><span class="line">        <span class="keyword">while</span> (top)</span><br><span class="line">            push_down(stk[top--]);</span><br><span class="line">        <span class="keyword">while</span> (not_root(x)) &#123;</span><br><span class="line">            f = fa[x];</span><br><span class="line">            <span class="keyword">if</span> (not_root(f))</span><br><span class="line">                which(x) == which(f) ? rotate(f) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">access</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; x; y = x, x = fa[x])</span><br><span class="line">            splay(x), ch[x][<span class="number">1</span>] = y, push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x), splay(x), reverse(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">find_root</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        access(x), splay(x);</span><br><span class="line">        <span class="keyword">while</span> (ch[x][<span class="number">0</span>])</span><br><span class="line">            push_down(x), x = ch[x][<span class="number">0</span>];</span><br><span class="line">        splay(x);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x), access(y), splay(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">link</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x);</span><br><span class="line">        <span class="keyword">if</span> (find_root(y) != x)</span><br><span class="line">            fa[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">cut</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        make_root(x);</span><br><span class="line">        <span class="keyword">if</span> (find_root(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][<span class="number">0</span>])</span><br><span class="line">            fa[y] = ch[x][<span class="number">1</span>] = <span class="number">0</span>, push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; lct;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 图论 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 点分治</title>
      <link href="/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-%E7%82%B9%E5%88%86%E6%B2%BB/"/>
      <url>/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-%E7%82%B9%E5%88%86%E6%B2%BB/</url>
      
        <content type="html"><![CDATA[<p>用于某些统计树上路径的题</p><p>每次找树的重心为根（$O(n)$）</p><p>处理每个点到根的距离等信息（$O(n)$）</p><p>统计答案（$O(n)$或$O(nlogn)$等）</p><p>划分根的各个子树，分治下去（总共分治$logn$层）</p><hr><h2 id="模板部分"><a href="#模板部分" class="headerlink" title="模板部分"></a>模板部分</h2><p>getroot() 找树的重心</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getroot</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">    sz[u] = <span class="number">1</span>, maxs[u] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) </span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to] &amp;&amp; e[i].to != fa) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            getroot(v, u, size);</span><br><span class="line">            sz[u] += sz[v];</span><br><span class="line">            maxs[u] = max(maxs[u], sz[v]);</span><br><span class="line">        &#125;</span><br><span class="line">    maxs[u] = max(maxs[u], size - sz[u]);</span><br><span class="line">    <span class="keyword">if</span> (!root || maxs[u] &lt; maxs[root])</span><br><span class="line">        root = u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getdis() 处理各点的距离</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 带染色</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">getdis</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> fa, <span class="keyword">int</span> dis, <span class="keyword">int</span> color)</span> </span>&#123;</span><br><span class="line">    t[++tot] = u;</span><br><span class="line">    d[u] = dis, col[u] = color;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa &amp;&amp; !vis[e[i].to])</span><br><span class="line">            v = e[i].to, getdis(v, u, d[u] + e[i].val, color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>统计答案时会重复，同一子树中的两个点是不能成点对的</p><p>有两种方式，将各个子树染色，或是通过容斥原理减去子树的一部分答案</p><p>solve() 分治</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    vis[u] = <span class="literal">true</span>;</span><br><span class="line">    ans += calc(u, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt) </span><br><span class="line">        <span class="keyword">if</span> (!vis[e[i].to]) &#123;</span><br><span class="line">            v = e[i].to, root = <span class="number">0</span>;</span><br><span class="line">            ans -= calc(v, e[i].val);<span class="comment">// 染色的话不加这句话</span></span><br><span class="line">            getroot(v, <span class="number">0</span>, sz[v]);</span><br><span class="line">            solve(root);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="统计答案"><a href="#统计答案" class="headerlink" title="统计答案"></a>统计答案</h2><p>calc() 每道题是不同的</p><p>以<a href="https://www.luogu.com.cn/problem/P3806" target="_blank" rel="noopener">模板题</a>为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一棵有n个点的树，询问树上距离为k的点对是否存在</span><br></pre></td></tr></table></figure><p>将每个点的深度处理出来后，按深度排序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tot = <span class="number">0</span>;</span><br><span class="line">t[++tot] = u;</span><br><span class="line">d[u] = dis, col[u] = u;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].nxt)</span><br><span class="line">    <span class="keyword">if</span> (!vis[e[i].to])</span><br><span class="line">        v = e[i].to, getdis(v, u, d[u]+e[i].val, v);</span><br><span class="line">sort(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, cmp);</span><br></pre></td></tr></table></figure><p>此时又有两种方法：</p><ul><li>双指针扫</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = tot;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[t[l]] + d[t[r]] &gt; k)</span><br><span class="line">        r--;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (d[t[l]] + d[t[r]] &lt; k)</span><br><span class="line">        l++;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (col[t[l]] == col[t[r]])</span><br><span class="line">        d[t[r]] == d[t[r<span class="number">-1</span>]] ? r-- : l++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        ans = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二分查找</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r;</span><br><span class="line"><span class="keyword">while</span> (l &lt; tot &amp;&amp; d[t[l]] + d[t[tot]] &lt; k)</span><br><span class="line">    l++;</span><br><span class="line"><span class="keyword">while</span> (l &lt; tot) &#123;</span><br><span class="line">    <span class="keyword">if</span> (d[t[l]] &gt; k - d[t[l]])</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    d[<span class="number">0</span>] = k - d[t[l]];</span><br><span class="line">    r = lower_bound(t+<span class="number">1</span>, t+tot+<span class="number">1</span>, <span class="number">0</span>, cmp) - t;</span><br><span class="line">    <span class="keyword">while</span> (r &lt;= tot &amp;&amp; d[t[l]] + d[t[r]] == k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (col[t[l]] != col[t[r]])</span><br><span class="line">            ans = <span class="literal">true</span>;</span><br><span class="line">        r++;</span><br><span class="line">    &#125;</span><br><span class="line">    l++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复杂度上限在于排序（$O(nlogn)$）</p><p>如果可以的话，可以桶排，降到（$O(n)$）</p><hr><h2 id="一些题目"><a href="#一些题目" class="headerlink" title="一些题目"></a>一些题目</h2><p><a href="https://www.luogu.com.cn/problem/P4178" target="_blank" rel="noopener">P4178</a>树上长度小于等于k的路径</p><p><a href="https://www.luogu.com.cn/problem/P4149" target="_blank" rel="noopener">P4149</a>长度为k的路径最小边数</p><p>我菜，好多还没做过。。。</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 点分治 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 WBLT</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-WBLT/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-WBLT/</url>
      
        <content type="html"><![CDATA[<p>本质上是平衡线段树</p><p>叶子节点维护原数列，非叶子节点维护子树最大值</p><p>比splay好写多了</p><p>我数组版+各种封装的巨大常数+单旋，luogu上跑347ms，开O2后161ms，还算可以</p><p>没时间总结了，贴个板子走人</p><p>强烈安利 Blog：<a href="https://www.luogu.com.cn/blog/qwaszx/leafy-tree-hu-wblt-xue-xi-bi-ji?tdsourcetag=s_pctim_aiomsg" target="_blank" rel="noopener">qwaszx 的博客</a></p><h2 id="维护平衡"><a href="#维护平衡" class="headerlink" title="维护平衡"></a>维护平衡</h2><p>WBLT 可以通过旋转或者拍扁重建（类似替罪羊树）的方式维护平衡</p><p>我<del>只会</del>喜欢旋转，而且为了方便我就只写单旋</p><p>单旋复杂度不对但是不好卡（慢是慢一点）</p><p>有时间再更双旋吧</p><p>每次 insert/delete 后回溯更新信息时 maintain 一下</p><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><blockquote><p>update 2020.2.19 贴个封装少的</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WBLT</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> cnt, root;</span><br><span class="line"><span class="keyword">int</span> val[M], sz[M], ls[M], rs[M];</span><br><span class="line"></span><br><span class="line">    WBLT() &#123;</span><br><span class="line">    new_node(root, <span class="number">1e9</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_leaf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(ls[x] || rs[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span>;</span><br><span class="line">val[x] = max(val[ls[x]], val[rs[x]]);</span><br><span class="line">sz[x] = sz[ls[x]] + sz[rs[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">x = ++cnt;</span><br><span class="line">val[x] = k, sz[x] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!opt) &#123;</span><br><span class="line"><span class="keyword">int</span> rson = rs[x];</span><br><span class="line">rs[x] = ls[x], ls[x] = ls[rs[x]];</span><br><span class="line">ls[rs[x]] = rs[rs[x]], rs[rs[x]] = rson;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> lson = ls[x];</span><br><span class="line">ls[x] = rs[x], rs[x] = rs[ls[x]];</span><br><span class="line">rs[ls[x]] = ls[ls[x]], ls[ls[x]] = lson;</span><br><span class="line">&#125;</span><br><span class="line">push_up(ls[x]), push_up(rs[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (sz[ls[x]] &gt;= sz[rs[x]] * <span class="number">4</span>) rotate(x, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (sz[rs[x]] &gt;= sz[ls[x]] * <span class="number">4</span>) rotate(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">new_node(ls[x], min(val[x], k));</span><br><span class="line">new_node(rs[x], max(val[x], k));</span><br><span class="line">push_up(x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= val[ls[x]]) insert(ls[x], k);</span><br><span class="line"><span class="keyword">else</span> insert(rs[x], k);</span><br><span class="line">push_up(x), maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line"><span class="keyword">if</span> (!fa) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> son = ls[fa] == x ? rs[fa] : ls[fa];</span><br><span class="line">val[fa] = val[son], sz[fa] = sz[son];</span><br><span class="line">ls[fa] = ls[son], rs[fa] = rs[son];</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= val[ls[x]]) erase(ls[x], x, k);</span><br><span class="line"><span class="keyword">else</span> erase(rs[x], x, k);</span><br><span class="line">push_up(x), maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x))</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + (k &gt; val[x]);</span><br><span class="line"><span class="keyword">if</span> (k &lt;= val[ls[x]]) <span class="keyword">return</span> rank(ls[x], k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> sz[ls[x]] + rank(rs[x], k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) <span class="keyword">return</span> x;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= sz[ls[x]]) <span class="keyword">return</span> k_th(ls[x], k);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> k_th(rs[x], k - sz[ls[x]]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> k, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> rk = rank(rt, k), rk2 = rank(rt, k+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">if</span> (!opt &amp;&amp; rk == <span class="number">1</span>) <span class="keyword">return</span> -INF;</span><br><span class="line"><span class="keyword">if</span> (opt &amp;&amp; rk2 &gt; sz[rt]) <span class="keyword">return</span> INF;</span><br><span class="line"><span class="keyword">return</span> val[k_th(rt, opt ? rk2 : rk - <span class="number">1</span>)];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="Luogu-P3369-code"><a href="#Luogu-P3369-code" class="headerlink" title="Luogu P3369 code"></a>Luogu P3369 code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/*Orz*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WBLT</span> &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val, size, ls, rs;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> root, cnt;</span><br><span class="line">Node tr[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">is_leaf</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !(tr[x].ls || tr[x].rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">tr[x].val = max(tr[tr[x].ls].val, tr[tr[x].rs].val);</span><br><span class="line">tr[x].size = tr[tr[x].ls].size + tr[tr[x].rs].size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">new_node</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">x = ++cnt;</span><br><span class="line">tr[x].val = val, tr[x].size = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">bool</span> opt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!opt) &#123;</span><br><span class="line"><span class="keyword">int</span> rs = tr[x].rs;</span><br><span class="line">tr[x].rs = tr[x].ls;</span><br><span class="line">tr[x].ls = tr[tr[x].rs].ls;</span><br><span class="line">tr[tr[x].rs].ls = tr[tr[x].rs].rs;</span><br><span class="line">tr[tr[x].rs].rs = rs;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> ls = tr[x].ls;</span><br><span class="line">tr[x].ls = tr[x].rs;</span><br><span class="line">tr[x].rs = tr[tr[x].ls].rs;</span><br><span class="line">tr[tr[x].ls].rs = tr[tr[x].ls].ls;</span><br><span class="line">tr[tr[x].ls].ls = ls;</span><br><span class="line">&#125;</span><br><span class="line">push_up(tr[x].ls), push_up(tr[x].rs);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">maintain</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x))</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (tr[tr[x].ls].size &gt;= tr[tr[x].rs].size * <span class="number">4</span>)</span><br><span class="line">rotate(x, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (tr[tr[x].rs].size &gt;= tr[tr[x].ls].size * <span class="number">4</span>)</span><br><span class="line">rotate(x, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> &amp;x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line">new_node(tr[x].ls, min(tr[x].val, val));</span><br><span class="line">new_node(tr[x].rs, max(tr[x].val, val));</span><br><span class="line">push_up(x);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val &lt;= tr[tr[x].ls].val)</span><br><span class="line">insert(tr[x].ls, val);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">insert(tr[x].rs, val);</span><br><span class="line">push_up(x), maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line"><span class="keyword">if</span> (tr[x].val == val) &#123;</span><br><span class="line"><span class="keyword">if</span> (x == tr[fa].ls)</span><br><span class="line">tr[fa] = tr[tr[fa].rs];</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">tr[fa] = tr[tr[fa].ls];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val &lt;= tr[tr[x].ls].val)</span><br><span class="line">del(tr[x].ls, x, val);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">del(tr[x].rs, x, val);</span><br><span class="line">push_up(x), maintain(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> + (val &gt; tr[x].val);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (val &lt;= tr[tr[x].ls].val)</span><br><span class="line"><span class="keyword">return</span> rank(tr[x].ls, val);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> tr[tr[x].ls].size + rank(tr[x].rs, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (is_leaf(x))</span><br><span class="line"><span class="keyword">return</span> tr[x].val;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= tr[tr[x].ls].size)</span><br><span class="line"><span class="keyword">return</span> k_th(tr[x].ls, k);</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line"><span class="keyword">return</span> k_th(tr[x].rs, k - tr[tr[x].ls].size);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">WBLT t;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line">t.new_node(t.root, <span class="number">1e9</span>);</span><br><span class="line"><span class="keyword">int</span> opt, x;</span><br><span class="line"><span class="keyword">while</span> (n--) &#123;</span><br><span class="line">read(opt), read(x);</span><br><span class="line"><span class="keyword">switch</span> (opt) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">t.insert(t.root, x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">t.del(t.root, <span class="number">0</span>, x);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.rank(t.root, x));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.k_th(t.root, x));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.k_th(t.root, t.rank(t.root, x) - <span class="number">1</span>));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, t.k_th(t.root, t.rank(t.root, x+<span class="number">1</span>)));</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BANANA::main();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 AC自动机</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>匹配多个模式串</p><p>本质上是trie tree + kmp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AC_automaton</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> tr[N][<span class="number">26</span>], fail[N], end[N], tot[M];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">memset</span>(tr, <span class="number">0</span>, <span class="keyword">sizeof</span> tr);</span><br><span class="line">        <span class="built_in">memset</span>(fail, <span class="number">0</span>, <span class="keyword">sizeof</span> fail);</span><br><span class="line">        <span class="built_in">memset</span>(end, <span class="number">0</span>, <span class="keyword">sizeof</span> end);</span><br><span class="line">        <span class="built_in">memset</span>(tot, <span class="number">0</span>, <span class="keyword">sizeof</span> tot);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!tr[p][s[i]-<span class="string">'a'</span>])</span><br><span class="line">                tr[p][s[i]-<span class="string">'a'</span>] = ++cnt;</span><br><span class="line">            p = tr[p][s[i]-<span class="string">'a'</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        end[p] = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i)</span><br><span class="line">            <span class="keyword">if</span> (tr[<span class="number">0</span>][i])</span><br><span class="line">                q.push(tr[<span class="number">0</span>][i]);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.front();</span><br><span class="line">            q.pop();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tr[x][i])</span><br><span class="line">                    fail[tr[x][i]] = tr[fail[x]][i], q.push(tr[x][i]);</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    tr[x][i] = tr[fail[x]][i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">(<span class="keyword">char</span> *s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, len = <span class="built_in">strlen</span>(s);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">            p = tr[p][s[i]-<span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j; j = fail[j])</span><br><span class="line">                tot[end[j]]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>先这样，有时间再补充</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AC自动机 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 Dinic</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dinic/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dinic/</url>
      
        <content type="html"><![CDATA[<h2 id="网络最大流"><a href="#网络最大流" class="headerlink" title="网络最大流"></a>网络最大流</h2><p>记得加当前弧优化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, cnt = <span class="number">1</span>, s, t;</span><br><span class="line"><span class="keyword">int</span> head[N], deep[N], cur[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">bfs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cur[i] = head[i];</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(deep, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> deep);</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">    q.push(s), inq[s] = <span class="literal">true</span>;</span><br><span class="line">    deep[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front();</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            <span class="keyword">int</span> v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (deep[v] &gt; deep[u] + <span class="number">1</span> &amp;&amp; e[i].flow) &#123;</span><br><span class="line">                deep[v] = deep[u] + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (!inq[v])</span><br><span class="line">                    q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> deep[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> flow)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (u == t || !flow)</span><br><span class="line">        <span class="keyword">return</span> flow;</span><br><span class="line">    <span class="keyword">int</span> rlow, v, re = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">        v = e[i].to;</span><br><span class="line">        <span class="keyword">if</span> (deep[v] == deep[u] + <span class="number">1</span> &amp;&amp; e[i].val &amp;&amp; (rlow = dfs(v, min(flow, e[i].val)))) &#123;</span><br><span class="line">            e[i].val -= rlow, e[i^<span class="number">1</span>].val += rlow;</span><br><span class="line">            flow -= rlow, re += rlow;</span><br><span class="line">            <span class="keyword">if</span> (!flow) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!re) deep[u] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxflow = <span class="number">0</span>, lowflow;</span><br><span class="line">    <span class="keyword">while</span> (bfs())</span><br><span class="line">        <span class="keyword">if</span> (lowflow = dfs(s, INF))</span><br><span class="line">            maxflow += lowflow;</span><br><span class="line">    <span class="keyword">return</span> maxflow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="费用流"><a href="#费用流" class="headerlink" title="费用流"></a>费用流</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n, m, cnt, s, t, maxflow, mincost;</span><br><span class="line"><span class="keyword">int</span> head[N], prev[N], pree[N], dis[N], flow[N];</span><br><span class="line">Edge e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"><span class="keyword">bool</span> inq[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w, <span class="keyword">int</span> f)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v, w, f&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    <span class="built_in">memset</span>(inq, <span class="number">0</span>, <span class="keyword">sizeof</span> inq);</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dis);</span><br><span class="line">    <span class="built_in">memset</span>(flow, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> flow);</span><br><span class="line">    q.push(s), inq[s] = <span class="literal">true</span>;</span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.front(), v;</span><br><span class="line">        q.pop();</span><br><span class="line">        inq[u] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">            v = e[i].to;</span><br><span class="line">            <span class="keyword">if</span> (e[i].flow &gt; <span class="number">0</span> &amp;&amp; dis[v] &gt; dis[u] + e[i].cost) &#123;</span><br><span class="line">                dis[v] = dis[u] + e[i].cost;</span><br><span class="line">                prev[v] = u, pree[v] = i;</span><br><span class="line">                flow[v] = min(flow[u], e[i].flow);</span><br><span class="line">                <span class="keyword">if</span> (!inq[v])</span><br><span class="line">                    q.push(v), inq[v] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> flow[t] != INF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dinic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (SPFA()) &#123;</span><br><span class="line">        maxflow += flow[t];</span><br><span class="line">        mincost += flow[t] * dis[t];</span><br><span class="line">        <span class="keyword">int</span> x = t;</span><br><span class="line">        <span class="keyword">while</span> (x != s) &#123;</span><br><span class="line">            e[pree[x]].flow -= flow[t];</span><br><span class="line">            e[pree[x]^<span class="number">1</span>].flow += flow[t];</span><br><span class="line">            x = prev[x];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加边注意</span></span><br><span class="line">add(u, v, w, f), add(v, u, <span class="number">0</span>, -f);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络最大流 </tag>
            
            <tag> 费用流 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P5662 【纪念品】</title>
      <link href="/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P5662-%E3%80%90%E7%BA%AA%E5%BF%B5%E5%93%81%E3%80%91/"/>
      <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P5662-%E3%80%90%E7%BA%AA%E5%BF%B5%E5%93%81%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P5662" target="_blank" rel="noopener">题面</a></p><p>最后一次考pj了，居然炸了</p><p>s组day1把我心态考崩了，下午j组写了200分就开始颓废，<del>估计要被学弟们嘲笑了QAQ</del></p><hr><p>好了，开始<em>事后诸葛</em></p><p>n个物品，t天价格，数据范围不大，但是直接推转移方程不太可行</p><p>想到<strong>背包</strong>（考场上脑子里“背包”两字都没出现）</p><hr><p>先考虑$n=1$的情况：</p><p>可以把t天的价格中，相邻两天的价格差当作一个物品（$price=a[i],value=a[i+1]-a[i]$）</p><p><code>f[i]</code>表示花费i金币的最大收益（不包括本金）</p><p>可以自己手玩一下，同时选物品$i$和$i+1$收益就是$a[i+2]-a[i]$，可以连续起来</p><p>每一天可以买卖多个，所以是完全背包</p><p>注意每天结束之后更新m，毕竟收益也可以用</p><hr><p>现在拓展到多个纪念品：</p><p>每一天都有n个物品，每个物品的价格还是本身，收益是下一天的减这一天的价格</p><p>每一天把n个物品做完全背包，之后更新m</p><p>最后得到的m就是答案</p><p>坑点是每天背包之前清空f数组</p><hr><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">/*...*/</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> t, n, m;</span><br><span class="line"><span class="keyword">int</span> a[N][N], f[M];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(t), read(n), read(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            read(a[i][j]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= t; ++i) &#123;</span><br><span class="line">        <span class="built_in">memset</span>(f, <span class="number">0</span>, <span class="keyword">sizeof</span> f);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = a[i][j]; k &lt;= m; ++k)</span><br><span class="line">                f[k] = max(f[k], f[k - a[i][j]] + a[i+<span class="number">1</span>][j] - a[i][j]);</span><br><span class="line">        m = max(m, f[m] + m);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>话说今年pj比去年水的多，比tg良心</p>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 背包DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSP2019 游记</title>
      <link href="/2020/01/17/2020-01-17-CSP2019-%E6%B8%B8%E8%AE%B0/"/>
      <url>/2020/01/17/2020-01-17-CSP2019-%E6%B8%B8%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="day0"><a href="#day0" class="headerlink" title="day0"></a>day0</h2><p>大早上迷迷糊糊开始坐车，高铁上和Luan学长邻座，rp++</p><p>睡了一路<del>因为想干的事情太多了于是就什么都不干</del>，下车终于不困了，rp++</p><p>下午试机，发现键盘很爽，rp++ </p><p>发现VMware里的noilinux没有vmtools，没法全屏，有点担忧，rp—</p><p>虽然是第二次来燕大，回宾馆又差点迷路了QAQ，rp—</p><p>晚饭吃的和去年一样的自助，那种按斤算的，很饱，rp++</p><p>晚上板子敲不下去，开始作死调dp，终于过了，rp++</p><hr><h2 id="day1-morning"><a href="#day1-morning" class="headerlink" title="day1 morning"></a>day1 morning</h2><p>早上起来，状态不是很好，rp—</p><p>考场现看的，考试区域没看</p><p>于是我跟着一群人来到了燕大西校区，而我应该在东校区考的</p><p>差点死了<code>rp &gt;&gt;= 1</code></p><p>感谢好心人捎我们回去，rp++</p><p>进了考场，发了题</p><p>密码是什么“认真思考”，还有个<code>?</code></p><p>打错一次密码，rp—</p><p>看题，<code>rp = 0</code></p><h3 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h3><p>开始理解错题意，调了半个小时错解</p><p>写完之后发现<code>n=64</code>时wa了</p><p>好吧这是一道<code>unsigned long long</code>题</p><h3 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h3><p>括号序列一类的问题早忘了怎么写。。。</p><p>敲了$n^2$暴力，预估50pts</p><p>想着敲完T3暴力回来想正解</p><h3 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h3><p>又一道树上问题？？？</p><p>敲了$n!$暴力，预估10pts</p><p>好吧码力太渣，暴力都调了半天，<del>我没救了</del></p><p>敲完想到了贪心做法（估计也不对），但时间只剩40min</p><p>赌一把吧。。。（咔嗒咔嗒键盘声）</p><p>码力太渣*2，写不出来，心态也崩了</p><p>好吧浪费了40min，最后5min收拾收拾交卷</p><hr><p>day1估分：$100+50+10=160$，一年白学了</p><p>day1两道树论，预感极差</p><p>背的板子全没用上，<del>是我太菜不会用？</del></p><p>md不该杠T3的</p><p>参照去年的难度，不指望day2翻盘</p><p>回宾馆上Luogu，发现：</p><blockquote><p>人均210，我不是人</p></blockquote><p>不想考下午的CSP-J了，我想散散心，<del>现在心里想不开</del></p><hr><h2 id="day1-afternoon"><a href="#day1-afternoon" class="headerlink" title="day1 afternoon"></a>day1 afternoon</h2><p>完了pj也炸了</p><p>开考前2分钟机房停电</p><p>延迟了半小时</p><p>开题发现不妙啊</p><p>T1T2半小时切了</p><p>T3<del>似乎某个学长讲过（雾</del></p><p>推了半天，用$n^2$dp套点东西</p><p>搞出来$O(nmt^2)$的暴力dp</p><p><del>考场上想平衡树维护凸包来斜率优化1e9-&gt;1e8，我是不是没救了</del></p><p>第二步分组背包不会写了QAQ（时间不够有点紧张）</p><p>T4想了个错解，算是死了</p><p>于是T3T4全靠暴力拿点可怜分了</p><p>早知道不考这东西了，200出头真丢人</p><hr><p>晚饭去了一个人不多的餐厅，那个牛肉面很难吃</p><p>晚上又开始无所事事。。。</p><p>其实好慌的，day2翻盘太难了</p><p>day2加油！！！</p><hr><h2 id="day2"><a href="#day2" class="headerlink" title="day2"></a>day2</h2><p>早上起来肚子疼，状态极差</p><p>永远不要想着day2翻盘，到了day2你都不知道盘是什么样子</p><p>T1貌似计数dp，写了半天不对</p><p>T2貌似还是dp，反正样例都没过去</p><p>md，dp题怎么暴力啊（我还是最菜的）</p><p>实在不行写T3吧，写了好像40分的暴力</p><p>最后T1T2搞半天没半小时写的T3暴力分高</p><p>好颓废啊，这一年真的白学了</p><hr><p>$CCF$用实力证明了$CSP$和$NOIP$没有关系</p><p>Luogu 上评分两黑两紫。。。</p><p>真的是三年降一档</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>算是来旅游的吧</p><p>起码有点教训：</p><ul><li>码力渣，细节处理不行，常见问题不会解决，明年必须刷题600+吧</li><li>三年降一档，能力必须在考试难度以上</li><li>dp需要练，快速得出状态表示和转移方程很重要</li><li>不能轻视每一场考试，考试期间注意身体</li></ul><p><strong>立个flag，明年$CSP$ 必须400+</strong></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>板子 Dijkstra / SPFA / Floyd</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dijkstra--SPFA--Floyd/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dijkstra--SPFA--Floyd/</url>
      
        <content type="html"><![CDATA[<h2 id="Dijkstra（堆优化）"><a href="#Dijkstra（堆优化）" class="headerlink" title="Dijkstra（堆优化）"></a>Dijkstra（堆优化）</h2><ul><li>取没有访问过的堆顶</li><li>标记为访问过</li><li>松弛各边</li><li>将未访问过的邻点塞进堆里</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> d, p;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Node &amp;x) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x.d &lt; d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Dijkstra</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        d[i] = INF;</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line">q.push((Node)&#123;<span class="number">0</span>, s&#125;);</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">Node x = q.top();</span><br><span class="line">q.pop();</span><br><span class="line"><span class="keyword">if</span> (v[x.p])</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">v[x.p] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x.p]; i; i = e[i].nxt) &#123;</span><br><span class="line"><span class="keyword">int</span> y = e[i].to;</span><br><span class="line"><span class="keyword">if</span> (d[y] &gt; d[x.p] + e[i].w) &#123;</span><br><span class="line">d[y] = d[x.p] + e[i].w;</span><br><span class="line"><span class="keyword">if</span> (!v[y])</span><br><span class="line">q.push((Node)&#123;d[y], y&#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SPFA"><a href="#SPFA" class="headerlink" title="SPFA"></a>SPFA</h2><ul><li>取队头</li><li>标记为出队</li><li>松弛各边</li><li>将队外的邻点怼进队里，标记为入队</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">d[i] = INF;</span><br><span class="line">d[s] = <span class="number">0</span>;</span><br><span class="line">q.push(s);</span><br><span class="line">vis[s] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="keyword">int</span> u = q.front();</span><br><span class="line">q.pop();</span><br><span class="line">vis[u] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u], v; i; i = e[i].next) &#123;</span><br><span class="line">v = e[i].to;</span><br><span class="line"><span class="keyword">if</span> (d[v] &gt; d[u] + e[i].val) &#123;</span><br><span class="line">d[v] = d[u] + e[i].val;</span><br><span class="line"><span class="keyword">if</span> (!vis[v]) &#123;</span><br><span class="line">q.push(v);</span><br><span class="line">vis[v] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h2><p>$k,i,j$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= n; ++k)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 Splay</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Splay/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Splay/</url>
      
        <content type="html"><![CDATA[<h2 id="members-amp-初始化"><a href="#members-amp-初始化" class="headerlink" title="members &amp; 初始化"></a>members &amp; 初始化</h2><p>每个节点：</p><ul><li><code>val</code> 值</li><li><code>size</code> 子树大小</li><li><code>fa</code> 父亲</li><li><code>ch[2]</code> 左/右儿子</li><li><code>cnt</code> 元素个数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val, size, fa, ch[<span class="number">2</span>], cnt;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> tot, root;<span class="comment">// 元素总数、根</span></span><br><span class="line">Node tr[N];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">Splay() &#123;</span><br><span class="line">    tot = root = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 为了后面便于操作，插入一个最大值、最小值</span></span><br><span class="line">    insert(INF), insert(-INF);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有一些常用函数：</p><p><strong>push_up()</strong> 更新子树大小</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    tr[x].size = tr[tr[x].ch[<span class="number">0</span>]].size + tr[tr[x].ch[<span class="number">1</span>]].size + tr[x].cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>which()</strong> 判断是其父亲的左/右儿子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x == tr[tr[x].fa].ch[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>BST核心</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = tr[p].ch[val &gt; tr[p].val];</span><br></pre></td></tr></table></figure><h2 id="insert-插入"><a href="#insert-插入" class="headerlink" title="insert() 插入"></a>insert() 插入</h2><p>从root开始走</p><p>如果有相同值的点，<code>cnt++</code></p><p>否则建新点</p><p>splay到根</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> p = root, fa = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p &amp;&amp; tr[p].val != val)</span><br><span class="line">        fa = p, p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">    <span class="keyword">if</span> (p)</span><br><span class="line">        tr[p].cnt++;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p = ++tot;</span><br><span class="line">        tr[p].val = val;</span><br><span class="line">        tr[p].fa = fa;</span><br><span class="line">        tr[p].ch[<span class="number">0</span>] = tr[p].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        tr[p].size = tr[p].cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (fa)</span><br><span class="line">            tr[fa].ch[val &gt; tr[fa].val] = p;</span><br><span class="line">    &#125;</span><br><span class="line">    splay(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="find-查找值的位置"><a href="#find-查找值的位置" class="headerlink" title="find() 查找值的位置"></a>find() 查找值的位置</h2><p>没有节点直接返回</p><p>从根开始走就行，返回的是最接近val的节点</p><p>splay到根</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">while</span> (tr[p].ch[val &gt; tr[p].val] &amp;&amp; val != tr[p].val)</span><br><span class="line">        p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">    splay(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="next-查找前驱、后继"><a href="#next-查找前驱、后继" class="headerlink" title="next() 查找前驱、后继"></a>next() 查找前驱、后继</h2><p>find一下这个值，这个值已经splay到根了</p><p>如果根满足，直接返回</p><p>否则往大/小走一步，在反方向走到底</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// opt 0前驱，1后继</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">    find(val);</span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">if</span> ((!opt &amp;&amp; tr[p].val &lt; val) || (opt &amp;&amp; tr[p].val &gt; val))</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    p = tr[p].ch[opt];</span><br><span class="line">    <span class="keyword">while</span> (tr[p].ch[opt^<span class="number">1</span>])</span><br><span class="line">        p = tr[p].ch[opt^<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="delete-删除值"><a href="#delete-删除值" class="headerlink" title="delete() 删除值"></a>delete() 删除值</h2><p>找到该值的前驱、后继</p><p>splay前驱到根，后继到根的右儿子</p><p>后继的左儿子就是该节点</p><p>要么<code>cnt--</code>，要么后继的左儿子改为0</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = next(val, <span class="number">0</span>), nxt = next(val, <span class="number">1</span>);</span><br><span class="line">    splay(last, <span class="number">0</span>), splay(nxt, last);</span><br><span class="line">    <span class="keyword">int</span> x = tr[nxt].ch[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">if</span> (tr[x].cnt &gt; <span class="number">1</span>)</span><br><span class="line">        tr[x].cnt--, splay(x, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        tr[nxt].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rotate-旋转"><a href="#rotate-旋转" class="headerlink" title="rotate() 旋转"></a>rotate() 旋转</h2><p>先求出x的父亲、爷爷，以及x的方向</p><blockquote><p>爷爷把我当儿子，我把爷爷当爹</p><p>父亲把我另一个儿子当儿子，他也把我父亲当爹</p><p>我的父亲当我另一个儿子，父亲把我当爹</p></blockquote><p>更新fa和x的size</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa = tr[x].fa, gfa = tr[fa].fa, w = which(x);</span><br><span class="line">    tr[gfa].ch[which(fa)] = x, tr[x].fa = gfa;</span><br><span class="line">    tr[fa].ch[w] = tr[x].ch[w^<span class="number">1</span>], tr[tr[x].ch[w^<span class="number">1</span>]].fa = fa;</span><br><span class="line">    tr[x].ch[w^<span class="number">1</span>] = fa, tr[fa].fa = x;</span><br><span class="line">    push_up(fa), push_up(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="splay-核心操作"><a href="#splay-核心操作" class="headerlink" title="splay() 核心操作"></a>splay() 核心操作</h2><p>如果x的fa不是终点，循环：</p><pre><code>如果爷爷也不是终点：    如果x和fa三点共线（方向一致），旋转fa，否则旋转x再次旋转x</code></pre><p>如果旋转到根，更新root</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fa;</span><br><span class="line">    <span class="keyword">while</span> (tr[x].fa != goal) &#123;</span><br><span class="line">        fa = tr[x].fa;</span><br><span class="line">        <span class="keyword">if</span> (tr[fa].fa != goal)</span><br><span class="line">            which(x) == which(fa) ? rotate(fa) : rotate(x);</span><br><span class="line">        rotate(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!goal)</span><br><span class="line">        root = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="k-th-排名为k的值"><a href="#k-th-排名为k的值" class="headerlink" title="k_th() 排名为k的值"></a>k_th() 排名为k的值</h2><p>如果从根开始</p><p>如果左儿子大小$\ge x$，走左儿子</p><p>如果左儿子大小加上当前点大小$&lt;x$，x减去它，走右儿子</p><p>剩下的就返回该点</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    x++;<span class="comment">// 树中有个最小值</span></span><br><span class="line">    <span class="keyword">int</span> p = root;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> ls = tr[p].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (tr[ls].size &gt;= x)</span><br><span class="line">            p = ls;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].size + tr[p].cnt &lt; x)</span><br><span class="line">            x -= tr[ls].size + tr[p].cnt, p = tr[p].ch[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> tr[p].val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rank-查找x的排名"><a href="#rank-查找x的排名" class="headerlink" title="rank() 查找x的排名"></a>rank() 查找x的排名</h2><p>find该值</p><p>此时根的左儿子的大小就是排名（减去最小值再加上该点）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    find(val);</span><br><span class="line">    <span class="keyword">return</span> tr[tr[root].ch[<span class="number">0</span>]].size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>时刻注意树中有最大值和最小值</p><h2 id="luogu-P3369-code"><a href="#luogu-P3369-code" class="headerlink" title="luogu P3369 code"></a>luogu P3369 code</h2><blockquote><p>update on 2020某一天</p><p>这个写法很丑很慢，Splay 里面的节点就不要包装了吧</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">    x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line">    <span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">    x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x7fffffff</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Splay</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val, size, fa, ch[<span class="number">2</span>], cnt;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">int</span> tot, root;</span><br><span class="line">    Node tr[N];</span><br><span class="line"></span><br><span class="line">    Splay() &#123;</span><br><span class="line">        tot = root = <span class="number">0</span>;</span><br><span class="line">        insert(INF), insert(-INF);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        tr[x].size = tr[tr[x].ch[<span class="number">0</span>]].size + tr[tr[x].ch[<span class="number">1</span>]].size + tr[x].cnt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">which</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x == tr[tr[x].fa].ch[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = root, fa = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (p &amp;&amp; tr[p].val != val)</span><br><span class="line">            fa = p, p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">        <span class="keyword">if</span> (p)</span><br><span class="line">            tr[p].cnt++;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p = ++tot;</span><br><span class="line">            tr[p].val = val;</span><br><span class="line">            tr[p].fa = fa;</span><br><span class="line">            tr[p].ch[<span class="number">0</span>] = tr[p].ch[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">            tr[p].size = tr[p].cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (fa)</span><br><span class="line">                tr[fa].ch[val &gt; tr[fa].val] = p;</span><br><span class="line">        &#125;</span><br><span class="line">        splay(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> last = next(val, <span class="number">0</span>), nxt = next(val, <span class="number">1</span>);</span><br><span class="line">        splay(last, <span class="number">0</span>), splay(nxt, last);</span><br><span class="line">        <span class="keyword">int</span> x = tr[nxt].ch[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (tr[x].cnt &gt; <span class="number">1</span>)</span><br><span class="line">            tr[x].cnt--, splay(x, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tr[nxt].ch[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">rotate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa = tr[x].fa, gfa = tr[fa].fa, w = which(x);</span><br><span class="line">        tr[gfa].ch[which(fa)] = x, tr[x].fa = gfa;</span><br><span class="line">        tr[fa].ch[w] = tr[x].ch[w^<span class="number">1</span>], tr[tr[x].ch[w^<span class="number">1</span>]].fa = fa;</span><br><span class="line">        tr[x].ch[w^<span class="number">1</span>] = fa, tr[fa].fa = x;</span><br><span class="line">        push_up(fa), push_up(x);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">splay</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> goal = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> fa;</span><br><span class="line">        <span class="keyword">while</span> (tr[x].fa != goal) &#123;</span><br><span class="line">            fa = tr[x].fa;</span><br><span class="line">            <span class="keyword">if</span> (tr[fa].fa != goal)</span><br><span class="line">                which(x) == which(fa) ? rotate(fa) : rotate(x);</span><br><span class="line">            rotate(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!goal)</span><br><span class="line">            root = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">int</span> p = root;</span><br><span class="line">        <span class="keyword">while</span> (tr[p].ch[val &gt; tr[p].val] &amp;&amp; val != tr[p].val)</span><br><span class="line">            p = tr[p].ch[val &gt; tr[p].val];</span><br><span class="line">        splay(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> val, <span class="keyword">int</span> opt)</span> </span>&#123;</span><br><span class="line">        find(val);</span><br><span class="line">        <span class="keyword">int</span> p = root;</span><br><span class="line">        <span class="keyword">if</span> ((!opt &amp;&amp; tr[p].val &lt; val) || (opt &amp;&amp; tr[p].val &gt; val))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        p = tr[p].ch[opt];</span><br><span class="line">        <span class="keyword">while</span> (tr[p].ch[opt^<span class="number">1</span>])</span><br><span class="line">            p = tr[p].ch[opt^<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">k_th</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">int</span> p = root;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> ls = tr[p].ch[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (tr[ls].size &gt;= x)</span><br><span class="line">                p = ls;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tr[ls].size + tr[p].cnt &lt; x)</span><br><span class="line">                x -= tr[ls].size + tr[p].cnt, p = tr[p].ch[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="keyword">return</span> tr[p].val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        find(val);</span><br><span class="line">        <span class="keyword">return</span> tr[tr[root].ch[<span class="number">0</span>]].size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Splay tree;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">int</span> opt, x;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        read(opt), read(x);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                tree.insert(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                tree.del(x);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tree.rank(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tree.k_th(x));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tree.tr[tree.next(x, <span class="number">0</span>)].val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, tree.tr[tree.next(x, <span class="number">1</span>)].val);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 平衡树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 Tarjan</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Tarjan/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Tarjan/</url>
      
        <content type="html"><![CDATA[<p>Tarjan是个好东西</p><p>求强连通分量，可以用来缩点等等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[N], dfn[N], low[N], col[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++tot;</span><br><span class="line"><span class="built_in">stack</span>[++top] = u;</span><br><span class="line">vis[u] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">v = e[i].to;</span><br><span class="line"><span class="keyword">if</span> (!dfn[v])</span><br><span class="line">Tarjan(v), low[u] = min(low[u], low[v]);</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (vis[v])</span><br><span class="line">low[u] = min(low[u], low[v]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (dfn[u] == low[u]) &#123;</span><br><span class="line">scc++;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">v = <span class="built_in">stack</span>[top--];</span><br><span class="line">vis[v] = <span class="literal">false</span>;</span><br><span class="line">col[v] = scc;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (v != u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缩点"><a href="#缩点" class="headerlink" title="缩点"></a><a href="https://www.luogu.org/record/20159280" target="_blank" rel="noopener">缩点</a></h3><p>搞出强连通分量后，重新建图，该干啥干啥</p><p><a href="https://www.luogu.org/problem/P2515" target="_blank" rel="noopener">P2515</a></p><p><a href="https://www.luogu.org/problem/T103252?contestId=22368" target="_blank" rel="noopener">T103252</a></p><p><a href="https://www.luogu.com.cn/problem/P2746" target="_blank" rel="noopener">P2746</a></p><h2 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h2><p>和求强连通分量不太一样</p><p><code>low[x]</code>表示 $dfs$ 下去最早遇到的割点</p><p>当 $v$ 已经访问过时，用 $dfn[v]$ 更新 $low[u]$ （为什么？画两个连环就知道了）</p><p>当 $u$ 为根时只要统计子树个数即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Tarjan</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> rt)</span> </span>&#123;</span><br><span class="line">dfn[u] = low[u] = ++tot;</span><br><span class="line"><span class="keyword">int</span> v, ch = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[u]; i; i = e[i].nxt) &#123;</span><br><span class="line">v = e[i].to;</span><br><span class="line"><span class="keyword">if</span> (!dfn[v]) &#123;</span><br><span class="line">Tarjan(v, rt), low[u] = min(low[u], low[v]);</span><br><span class="line"><span class="keyword">if</span> (u != rt &amp;&amp; low[v] &gt;= dfn[u])<span class="comment">// 环在u的子树里，u为割点</span></span><br><span class="line">cut[u] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (u == rt)</span><br><span class="line">ch++;</span><br><span class="line">&#125;</span><br><span class="line">low[u] = min(low[u], dfn[v]);<span class="comment">// 注意这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (u == rt &amp;&amp; ch &gt;= <span class="number">2</span>)</span><br><span class="line">cut[u] = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 缩它</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    <span class="keyword">if</span> (!dfn[i])</span><br><span class="line">        Tarjan(i, i);<span class="comment">// i = rt</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tarjan </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 kmp</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-kmp/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-kmp/</url>
      
        <content type="html"><![CDATA[<h2 id="处理b串的nxt"><a href="#处理b串的nxt" class="headerlink" title="处理b串的nxt[]"></a>处理b串的nxt[]</h2><p>i从2开始，j从0开始</p><p>i和j+1匹配不上，j跳nxt</p><p>匹配就<code>j++</code></p><p><code>nxt[i] = j</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, j = <span class="number">0</span>; i &lt;= blen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; b[j+<span class="number">1</span>] != b[i])</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (b[j+<span class="number">1</span>] == b[i])</span><br><span class="line">        ++j;</span><br><span class="line">    nxt[i] = j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="kmp匹配"><a href="#kmp匹配" class="headerlink" title="kmp匹配"></a>kmp匹配</h2><p>i从a的1-len，j从0开始</p><p><code>a[i]</code>和<code>b[j+1]</code>匹配不上就j跳nxt</p><p>否则<code>j++</code></p><p>j到blen则匹配完一次，跳nxt</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= alen; ++i) &#123;</span><br><span class="line">    <span class="keyword">while</span> (j &amp;&amp; b[j+<span class="number">1</span>] != a[i])</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    <span class="keyword">if</span> (b[j+<span class="number">1</span>] == a[i])</span><br><span class="line">        ++j;</span><br><span class="line">    <span class="keyword">if</span> (j == blen) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i - blen + <span class="number">1</span>);</span><br><span class="line">        ans++;</span><br><span class="line">        j = nxt[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 字符串 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kmp匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 倍增LCA</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%80%8D%E5%A2%9ELCA/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%80%8D%E5%A2%9ELCA/</url>
      
        <content type="html"><![CDATA[<p>先$dfs$一遍预处理：</p><p>$deep[x]$：x的深度</p><p>$fa[x][i]$：x的第$2^i$个祖先（倍增数组）</p><p>记住<code>fa[x][i] = fa[fa[x][i-1]][i-1]</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">fa[x][<span class="number">0</span>] = last;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; <span class="number">1</span> &lt;&lt; i &lt;= deep[x]; ++i)</span><br><span class="line">fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line"><span class="keyword">if</span> (e[i].to != last)</span><br><span class="line">dfs(e[i].to, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理$log[]$数组，递推一下就好：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">lg[i] = lg[i<span class="number">-1</span>] + (<span class="number">1</span> &lt;&lt; lg[i<span class="number">-1</span>] == i);</span><br></pre></td></tr></table></figure><hr><p>求$LCA$ </p><p>让深度大的往上跳，直到两点同一深度</p><p>然后两个点同时往上跳，直到父亲相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (deep[a] &lt; deep[b])</span><br><span class="line">swap(a, b);</span><br><span class="line"><span class="keyword">while</span> (deep[a] &gt; deep[b])</span><br><span class="line">a = fa[a][lg[deep[a]-deep[b]]<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = lg[deep[a]]; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (fa[a][i] != fa[b][i])</span><br><span class="line">a = fa[a][i], b = fa[b][i];</span><br><span class="line"><span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 并查集</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B9%B6%E6%9F%A5%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>就这么水一篇博客？？？</p><hr><p>含路径压缩的找father函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fa[x] == x ? x : fa[x] = find(fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意提前把father赋为自己！！！</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    fa[i] = i;</span><br></pre></td></tr></table></figure><p>我太弱了，更nb的操作还不会，555</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 欧拉线性筛</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B/</url>
      
        <content type="html"><![CDATA[<p>未访问的是质数</p><p>之后从质数表开始</p><p>把$i*pri[j]$标为访问过</p><p>如果$i$是$pri[j]$的倍数就跳出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i])</span><br><span class="line">        pri.push_back(i);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">        vis[pri[j]*i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>欧拉线性筛$\varphi(x)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[i])</span><br><span class="line">        pri[++tot] = i, phi[i] = i - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>, k; j &lt;= tot &amp;&amp; (k = pri[j] * i) &lt;= n; ++j) &#123;</span><br><span class="line">        tag[k] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j])</span><br><span class="line">            phi[k] = phi[i] * phi[pri[j]];</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            phi[k] = phi[i] * pri[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p><del>粘过来的</del>线性筛$d(x)$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vis[i] = d[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!vis[i]) </span><br><span class="line">        pri.push_back(i), d[i] = <span class="number">2</span>, a[i] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">        vis[i*pri[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (i % pri[j]) </span><br><span class="line">            d[i*pri[j]] = d[i] * d[pri[j]], a[i*pri[j]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            d[i*pri[j]] = d[i] / (a[i] + <span class="number">1</span>) * (a[i] + <span class="number">2</span>);</span><br><span class="line">            a[i*pri[j]] = a[i]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 欧拉线性筛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1373 【小a和uim之大逃离】</title>
      <link href="/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1373-%E3%80%90%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%E3%80%91/"/>
      <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1373-%E3%80%90%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1373" target="_blank" rel="noopener">题目</a></p><p>奇怪的递推（DP），居然没有自己做出来QAQ</p><hr><h2 id="初始思路"><a href="#初始思路" class="headerlink" title="初始思路"></a>初始思路</h2><p>用<code>f[i][j][x][y]</code>表示取到 点$i,j$时，小a有$x$魔液，uim有$y$魔液，的方案数</p><p>显然MLE，且复杂度不优秀，$O(nmk^2)$</p><h2 id="优化表示方式"><a href="#优化表示方式" class="headerlink" title="优化表示方式"></a>优化表示方式</h2><p>答案要求两人差为零的方案数，所以只考虑两者魔液之差</p><p>用<code>f[i][j][x][p]</code>表示表示取到 点$i,j$时，两人之差为$x$，由$p$（小a或uim）取最后一堆的方案数</p><h2 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 小a</span><br><span class="line">f[i][j][x][0] +&#x3D; f[i-1][j][x-a[i][j]][1]&#x2F;&#x2F; 上边</span><br><span class="line">f[i][j][x][0] +&#x3D; f[i][j-1][x-a[i][j]][1]&#x2F;&#x2F; 左边</span><br><span class="line">&#x2F;&#x2F; uim</span><br><span class="line">f[i][j][x][1] +&#x3D; f[i-1][j][x+a[i][j]][0]</span><br><span class="line">f[i][j][x][1] +&#x3D; f[i][j-1][x+a[i][j]][0]</span><br></pre></td></tr></table></figure><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>注意模的是<code>k+1</code>，所以我一开始<code>k++</code></p><p>因为只能由小a取第一堆，初始值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f[i][j][a[i][j]][0] &#x3D; 1</span><br></pre></td></tr></table></figure><p>只能由uim取最后一堆，答案为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ans +&#x3D; f[i][j][0][1]</span><br></pre></td></tr></table></figure><p>空间开到<code>f[805][805][20][2]</code>左右，不然容易MLE</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">805</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, k;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="keyword">int</span> a[N][N], f[N][N][<span class="number">20</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mod</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (x + k) % k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(m), read(k);</span><br><span class="line">    k++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">            read(a[i][j]), a[i][j] %= k;</span><br><span class="line">            f[i][j][a[i][j]][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; k; ++x) &#123;</span><br><span class="line">                f[i][j][x][<span class="number">0</span>] = (f[i][j][x][<span class="number">0</span>] + f[i<span class="number">-1</span>][j][mod(x-a[i][j])][<span class="number">1</span>] + f[i][j<span class="number">-1</span>][mod(x-a[i][j])][<span class="number">1</span>]) % MOD;</span><br><span class="line">                f[i][j][x][<span class="number">1</span>] = (f[i][j][x][<span class="number">1</span>] + f[i<span class="number">-1</span>][j][mod(x+a[i][j])][<span class="number">0</span>] + f[i][j<span class="number">-1</span>][mod(x+a[i][j])][<span class="number">0</span>]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            (ans += f[i][j][<span class="number">0</span>][<span class="number">1</span>]) %= MOD;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BANANA::main();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递推DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>板子 高斯消元</title>
      <link href="/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/"/>
      <url>/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/</url>
      
        <content type="html"><![CDATA[<p>我选择的是简单好写的高斯-约旦消法</p><blockquote><p>1.选择一个尚未被选过的未知数作为主元，选择一个包含这个主元的方程。</p><p>2.将这个方程主元的系数化为1。</p><p>3.通过加减消元，消掉其它方程中的这个未知数。</p><p>4.重复以上步骤，直到把所有式子变成形如: a*1+b*0+c*0……=d</p></blockquote><p>code:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Gauss</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 找到该列的最大值</span></span><br><span class="line"><span class="keyword">int</span> mx = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">abs</span>(a[j][i]) &gt; <span class="built_in">abs</span>(a[mx][i]))</span><br><span class="line">mx = j;</span><br><span class="line"><span class="keyword">if</span> (a[mx][i] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;<span class="comment">// 返回无解</span></span><br><span class="line">        <span class="comment">// 交换行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt;= n + <span class="number">1</span>; ++j)</span><br><span class="line">swap(a[i][j], a[mx][j]);</span><br><span class="line">        <span class="comment">// 加减消元</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)<span class="comment">// 注意是1~n</span></span><br><span class="line"><span class="keyword">if</span> (j != i) &#123;</span><br><span class="line"><span class="keyword">double</span> d = a[j][i] / a[i][i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = i + <span class="number">1</span>; k &lt;= n + <span class="number">1</span>; ++k)</span><br><span class="line">a[j][k] -= a[i][k] * d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, a[i][n+<span class="number">1</span>] / a[i][i]);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线性代数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1967 【货车运输】</title>
      <link href="/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1967-%E3%80%90%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%E3%80%91/"/>
      <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1967-%E3%80%90%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P1967" target="_blank" rel="noopener">题面</a></p><p>因为一些容量小的边不会被经过，考虑先建出<strong>最大生成树</strong></p><p>题目转化成在树上求两点间路径最小权值</p><p>利用$LCA$求最短路径</p><p>另外搞一个倍增数组$minn[x][i]$，表示x到第$2^i$个祖先之间路径最小权值</p><p>转移：<code>minn[x][i] = min(minn[x][i-1], minn[fa[x][i-1]][i-1]);</code></p><hr><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">5e4</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge_</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> x, y, w;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> Edge_ &amp;t) <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> w &gt; t.w;<span class="comment">// 从大到小排</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> nxt, to, w;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, q, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], col[N], fa[N][<span class="number">30</span>], <span class="built_in">log</span>[N], deep[N], minn[N][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line">Edge_ e_[M];</span><br><span class="line">Edge e[M&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">e[++cnt] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> t = a;</span><br><span class="line">a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集找father</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> col[x] == x ? x : col[x] = find(col[x]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大生成树</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">col[i] = i;</span><br><span class="line">sort(e_+<span class="number">1</span>, e_+m+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line"><span class="keyword">if</span> (find(e_[i].x) != find(e_[i].y)) &#123;</span><br><span class="line">col[find(e_[i].x)] = e_[i].y;</span><br><span class="line">add(e_[i].x, e_[i].y, e_[i].w), add(e_[i].y, e_[i].x, e_[i].w);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LCA预处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">vis[x] = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">log</span>[deep[x]]; ++i)</span><br><span class="line">fa[x][i] = fa[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[x][i] = min(minn[fa[x][i<span class="number">-1</span>]][i<span class="number">-1</span>], minn[x][i<span class="number">-1</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = head[x], y; i; i = e[i].nxt) &#123;</span><br><span class="line">y = e[i].to;</span><br><span class="line"><span class="keyword">if</span> (!vis[y]) &#123;</span><br><span class="line">deep[y] = deep[x] + <span class="number">1</span>, fa[y][<span class="number">0</span>] = x, minn[y][<span class="number">0</span>] = e[i].w;</span><br><span class="line">dfs(y);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">LCA</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (find(x) != find(y))</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> ans = INF;</span><br><span class="line"><span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">swap(x, y);</span><br><span class="line"><span class="keyword">while</span> (deep[x] &gt; deep[y]) &#123;</span><br><span class="line">ans = min(ans, minn[x][<span class="built_in">log</span>[deep[x]-deep[y]]<span class="number">-1</span>]);</span><br><span class="line">x = fa[x][<span class="built_in">log</span>[deep[x]-deep[y]]<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (x == y)</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="built_in">log</span>[deep[x]]; ~i; --i)</span><br><span class="line"><span class="keyword">if</span> (fa[x][i] != fa[y][i]) &#123;</span><br><span class="line">ans = min(ans, min(minn[x][i], minn[y][i]));</span><br><span class="line">x = fa[x][i], y = fa[y][i];</span><br><span class="line">&#125;</span><br><span class="line">ans = min(ans, min(minn[x][<span class="number">0</span>], minn[y][<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> ans;<span class="comment">// 返回路径上最小值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">read(e_[i].x), read(e_[i].y), read(e_[i].w);</span><br><span class="line"></span><br><span class="line">Kruskal();</span><br><span class="line">    <span class="comment">// 递推log数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">log</span>[i] = <span class="built_in">log</span>[i<span class="number">-1</span>] + ((<span class="number">1</span> &lt;&lt; <span class="built_in">log</span>[i<span class="number">-1</span>]) == i);</span><br><span class="line">    <span class="comment">// 注意图不一定联通</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (!vis[i]) &#123;</span><br><span class="line">deep[i] = <span class="number">1</span>;</span><br><span class="line">fa[i][<span class="number">0</span>] = i;</span><br><span class="line">minn[i][<span class="number">0</span>] = INF;</span><br><span class="line">dfs(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read(q);</span><br><span class="line"><span class="keyword">int</span> x, y;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= q; ++i) &#123;</span><br><span class="line">read(x), read(y);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, LCA(x, y));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BANANA::main();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LCA </tag>
            
            <tag> 倍增 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2279 【[HNOI2003]消防局的设立】</title>
      <link href="/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P2279-%E3%80%90HNOI2003%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%E3%80%91/"/>
      <url>/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P2279-%E3%80%90HNOI2003%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%E3%80%91/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P2279" target="_blank" rel="noopener">题目</a></p><p>第一道连状态都不会表示的$dp$</p><p>转移方程推到吐。。。</p><h2 id="状态表示"><a href="#状态表示" class="headerlink" title="状态表示"></a>状态表示</h2><p>每一个点$x$都有五个状态：</p><blockquote><p><code>f[x][0]</code>：覆盖到x的爷爷和x整棵子树（向上2层），最少个数</p><p><code>f[x][1]</code>：覆盖到x的父亲和x整棵子树（向上1层），最少个数</p><p><code>f[x][2]</code>：覆盖x整棵子树（向上0层），最少个数</p><p><code>f[x][3]</code>：覆盖所有x的儿子及其子树（向上-1层），最少个数</p><p><code>f[x][4]</code>：覆盖所有x的孙子及其子树（向上-2层），最少个数</p></blockquote><hr><ul><li><code>f[x][0]</code>：覆盖到x的爷爷和x整棵子树（向上2层），最少个数</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/83nui5b4.png" alt=""></p><ul><li><code>f[x][1]</code>：覆盖到x的父亲和x整棵子树（向上1层），最少个数</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/6lhd8icf.png" alt=""></p><ul><li><code>f[x][2]</code>：覆盖x整棵子树（向上0层），最少个数</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/sxrk7lgi.png" alt=""></p><ul><li><code>f[x][3]</code>：覆盖所有x的儿子及其子树（向上-1层），最少个数</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/zdnxa2p1.png" alt=""></p><ul><li><code>f[x][4]</code>：覆盖所有x的孙子及其子树（向上-2层），最少个数</li></ul><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/djsdjzke.png" alt=""></p><h2 id="转移方程"><a href="#转移方程" class="headerlink" title="转移方程"></a>转移方程</h2><p>y，z是x的儿子</p><p>$f[x][0] = 1 + \sum{f[y][4]}$<br>$f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})$<br>$f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})$<br>$f[x][3] = \sum{f[y][2]}$<br>$f[x][4] = \sum{f[y][3]}$</p><p>显然<code>f[x][i]</code>一定包含<code>f[x][i+1]</code></p><p>易得<code>f[x][0] &gt;= f[x][1] &gt;= f[x][2] &gt;= f[x][3] &gt;= f[x][4]</code></p><p>所以转移时保证满足条件的前提下尽量选最低层的状态</p><hr><ul><li>$f[x][0] = 1 + \sum{f[y][4]}$ </li></ul><p>要覆盖到爷爷的话必须选x，并贪心地选y的第五种状态</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/ogxjicaf.png" alt=""></p><ul><li>$f[x][1] = min(f[y][0] + \sum{(y!=z)f[z][3]})$</li></ul><p>x的儿子中有一个一定覆盖的爷爷，同时覆盖到兄弟（因为y一定是选了），其他的儿子只需要覆盖的自己的儿子即可</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/86y5d7hh.png" alt=""></p><ul><li>$f[x][2] = min(f[y][1] + \sum{(y!=z)f[z][2]})$</li></ul><p>同理，有一个儿子覆盖到父亲，但无法覆盖到y的兄弟，所以其他儿子要覆盖到自己</p><ul><li>$f[x][3] = \sum{f[y][2]}$</li></ul><p>让每个儿子覆盖到自己即可</p><ul><li>$f[x][4] = \sum{f[y][3]}$</li></ul><p>让每个儿子覆盖到自己的儿子</p><hr><p>注意：</p><p><strong><code>f[x][i]</code>包含<code>f[x][i+1]</code>，若<code>f[x][i]</code>比<code>f[x][i+1]</code>更优，<code>f[x][i+1]</code>应更新</strong></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1005</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], f[N][<span class="number">5</span>];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> fa)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 记录f[y][2], f[y][3]的总和，后面容斥即可</span></span><br><span class="line">    <span class="keyword">int</span> sum2 = <span class="number">0</span>, sum3 = <span class="number">0</span>, y, tot;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs(y, x);</span><br><span class="line">            sum2 += f[y][<span class="number">2</span>], sum3 += f[y][<span class="number">3</span>];</span><br><span class="line">            tot++;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 没有儿子特判</span></span><br><span class="line">    <span class="keyword">if</span> (!tot) &#123;</span><br><span class="line">        f[x][<span class="number">0</span>] = f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x][<span class="number">0</span>] = <span class="number">1</span>, f[x][<span class="number">1</span>] = f[x][<span class="number">2</span>] = N;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            f[x][<span class="number">0</span>] += f[y][<span class="number">4</span>];</span><br><span class="line">            f[x][<span class="number">1</span>] = min(f[x][<span class="number">1</span>], f[y][<span class="number">0</span>] + sum3 - f[y][<span class="number">3</span>]);</span><br><span class="line">            f[x][<span class="number">2</span>] = min(f[x][<span class="number">2</span>], f[y][<span class="number">1</span>] + sum2 - f[y][<span class="number">2</span>]);</span><br><span class="line">            f[x][<span class="number">3</span>] += f[y][<span class="number">2</span>];</span><br><span class="line">            f[x][<span class="number">4</span>] += f[y][<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">// 检查最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">        f[x][i] = min(f[x][i], f[x][i<span class="number">-1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>, x; i &lt;= n; ++i)</span><br><span class="line">        read(x), add(x, i), add(i, x);</span><br><span class="line">    dfs(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, f[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2054 【[AHOI2005]洗牌】</title>
      <link href="/2019/12/25/sol_P2054/"/>
      <url>/2019/12/25/sol_P2054/</url>
      
        <content type="html"><![CDATA[<p>洗牌???</p><p><del>吐槽一下题目的图片，差点误导了我</del></p><p>这么麻烦的题面当然先模拟啦。。。</p><p>打表发现每次洗牌后第 $i$ 张牌会转移到第 $2*i \%(n+1)$ 的位置上</p><p>即在$\mod{n+1}$意义下，$i$ 和 $2i$ 是同余的</p><p>so，可以列出一个同余方程：</p><p>$i * 2^{m} \equiv l\pmod {n+1}$</p><p>再转化为</p><script type="math/tex; mode=display">2 ^ {m} * i + (n+1) * k = l</script><script type="math/tex; mode=display">2^{m} * \frac{i}{l} + (n+1) * \frac{k}{l} = 1</script><p>此时利用$exgcd$完美地算出$\frac{i}{l}$，乘上$l$即可</p><p><strong>注意：</strong>范围1e10，如果直接乘会gg，要用快速乘，和快速幂差不多</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;<span class="comment">// 快读</span></span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;<span class="comment">// 开long long</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速乘</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将乘法变为加法，二进制优化，边加边模</span></span><br><span class="line">ll ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">ans = (ans + a) % p;</span><br><span class="line">a = (a + a) % p;</span><br><span class="line">b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速幂，其实只要写针对2的整次幂就行，这里犯懒。。。</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">q_pow</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">ll ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (b) &#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>)</span><br><span class="line">ans = mul(ans, a, p) % p;</span><br><span class="line">a = mul(a, a, p) % p, b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标配扩欧</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;g)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!b)</span><br><span class="line">x = <span class="number">1</span>, y = <span class="number">0</span>, g = a;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">exgcd(b, a%b, y, x, g);</span><br><span class="line">y -= a / b * x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ll n, m, l, x, y, g, t;</span><br><span class="line">read(n), read(m), read(l);</span><br><span class="line">t = q_pow(<span class="number">2</span>, m, n+<span class="number">1</span>);<span class="comment">// 2的m次幂</span></span><br><span class="line">exgcd(t, n+<span class="number">1</span>, x, y, g);</span><br><span class="line">x = (x % (n+<span class="number">1</span>) + n+<span class="number">1</span>) % (n+<span class="number">1</span>);<span class="comment">// 注意exgcd后解可能为负</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, mul(x, l, n+<span class="number">1</span>));<span class="comment">// 乘上l</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P2704 【[NOI2001]炮兵阵地】</title>
      <link href="/2019/12/25/sol_P2704/"/>
      <url>/2019/12/25/sol_P2704/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P2704" target="_blank" rel="noopener">题目</a></p><p><del>珍爱头发，远离状压</del></p><p>首先如果没做过状压的话，出门<a href="https://www.luogu.org/problem/P1879" target="_blank" rel="noopener">右转</a></p><hr><p>这道题。。。数据范围很状压</p><p><del>显然</del>，把每一行的地图（有山为1，否则为0）压到一个数里</p><p>把枚举的状态压成有炮为1，否则为0</p><p><strong>把有解的情况存下来</strong>，便于枚举，并预处理每种情况的炮兵个数</p><p>现在<strong>用$f_{i,j,k}$表示第$i$行是状态$j$，是由状态$k$转移来的，最大的炮兵个数</strong></p><p>单独处理第一行和第二行</p><p>后面$dp$的时候注意:</p><p>如何使一列中的每三行只有一个炮兵？</p><p>保证$k1$ &amp; $k2$, $k2$ &amp; $k3$, $k1$ &amp; $k3$都为0即可（显然）</p><p>另外，空间有点。。。建议<strong>滚动数组</strong></p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> M = <span class="number">1</span>&lt;&lt;<span class="number">11</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">105</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m, maxn, ans;</span><br><span class="line"><span class="keyword">int</span> mp[N], f[<span class="number">3</span>][M][M];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; d, v;<span class="comment">// 可行状态的对应的炮兵个数</span></span><br><span class="line"><span class="keyword">char</span> in[<span class="number">15</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算每种情况的炮兵个数</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> re = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">30</span>; ++i)</span><br><span class="line"><span class="keyword">if</span> (x &amp; (<span class="number">1</span> &lt;&lt; i))</span><br><span class="line">re++;</span><br><span class="line"><span class="keyword">return</span> re;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n), read(m);</span><br><span class="line">maxn = (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, in);</span><br><span class="line">        <span class="comment">//处理地图</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line"><span class="keyword">if</span> (in[j] == <span class="string">'H'</span>)</span><br><span class="line">mp[i] |= <span class="number">1</span> &lt;&lt; j;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 预处理可行状态</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= maxn; ++i)</span><br><span class="line"><span class="keyword">if</span> ((i &amp; (i &gt;&gt; <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (i &amp; (i &gt;&gt; <span class="number">2</span>)) == <span class="number">0</span>)</span><br><span class="line">d.push_back(i), v.push_back(count(i));</span><br><span class="line">    <span class="comment">// 单独处理一二行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line"><span class="keyword">if</span> ((d[i] &amp; mp[<span class="number">0</span>]) == <span class="number">0</span>)<span class="comment">// 一贯的保证可行</span></span><br><span class="line">f[<span class="number">0</span>][d[i]][<span class="number">0</span>] = v[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line"><span class="keyword">if</span> ((d[i] &amp; mp[<span class="number">1</span>]) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)</span><br><span class="line"><span class="keyword">if</span> ((d[j] &amp; d[i]) == <span class="number">0</span>)</span><br><span class="line">f[<span class="number">1</span>][d[i]][d[j]] = max(f[<span class="number">1</span>][d[i]][d[j]], f[<span class="number">0</span>][d[j]][<span class="number">0</span>] + v[i]);</span><br><span class="line">    <span class="comment">// 愉快的dp</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i)<span class="comment">// 行数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)<span class="comment">// 该行</span></span><br><span class="line"><span class="keyword">if</span> ((d[j] &amp; mp[i]) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; d.size(); ++k)<span class="comment">// 上一行</span></span><br><span class="line"><span class="keyword">if</span> ((d[k] &amp; d[j]) == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; d.size(); ++l)<span class="comment">// 上二行</span></span><br><span class="line"><span class="keyword">if</span> ((d[l] &amp; d[k]) == <span class="number">0</span> &amp;&amp; (d[l] &amp; d[j]) == <span class="number">0</span>)</span><br><span class="line">f[i%<span class="number">3</span>][d[j]][d[k]] = max(f[i%<span class="number">3</span>][d[j]][d[k]], f[(i<span class="number">-1</span>)%<span class="number">3</span>][d[k]][d[l]] + v[j]);<span class="comment">// 重点</span></span><br><span class="line">    <span class="comment">// 统计最后一行的最大值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; d.size(); ++j)</span><br><span class="line">ans = max(ans, f[(n<span class="number">-1</span>)%<span class="number">3</span>][d[i]][d[j]]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
          <category> DP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压DP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P3538 【[POI2012]OKR-A Horrible Poem】</title>
      <link href="/2019/12/25/sol_P3538/"/>
      <url>/2019/12/25/sol_P3538/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.luogu.org/problem/P3538" target="_blank" rel="noopener">题面</a></p><p>判断字符串循环节最方便的是$hash$</p><p>不会的请<a href="https://www.luogu.org/problem/P3370" target="_blank" rel="noopener">出门左转P3370</a></p><p>我们先把字符串$hash$一遍</p><p><img src="https://cdn.luogu.com.cn/upload/image_hosting/olzrdhcj.png" alt=""></p><p>如图，如果设循环节长度为$3$时，$s1$和$s2$的$hash$值是相等的</p><p>所以只需要找最小的$len$使得$hash(l+len,r)=hash(l,r-len)$</p><hr><p>另外，<strong>循环节的长度的循环次数都一定是总长的约数</strong></p><p>我的做法是把<strong>总长除掉循环次数</strong></p><p>先把$len$分解质因数</p><p>（线性筛质数，并记录下每个数的最小质因子加速分解，<del>这已经是常规操作了</del>）</p><p>因为最小循环节的倍数也是循环节</p><p>所以从$len$开始试除每个质因子并判断（你可以理解为$len$的因子分为循环节的因子和循环次数的因子，要把循环次数的因子除掉）</p><p>具体的看代码吧。。。</p><hr><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ll MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">5e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">ll g[N], hash[N], <span class="built_in">pow</span>[N];<span class="comment">// g记录最小质因子，pow存进制的整数次幂</span></span><br><span class="line"><span class="keyword">char</span> s[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;ll&gt; pri;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线性筛</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">euler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i])</span><br><span class="line">pri.push_back(i), g[i] = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123;</span><br><span class="line">vis[pri[j]*i] = <span class="literal">true</span>, g[pri[j]*i] = pri[j];</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提取hash值</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">calc</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ((hash[r] - hash[l<span class="number">-1</span>] * <span class="built_in">pow</span>[r-l+<span class="number">1</span>]) % MOD + MOD) % MOD;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line">euler();</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, s+<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// hash</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">hash[i] = (hash[i<span class="number">-1</span>] * <span class="number">29</span> + s[i] - <span class="string">'a'</span> + <span class="number">1</span>) % MOD;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 预处理整数次幂</span></span><br><span class="line"><span class="built_in">pow</span>[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="built_in">pow</span>[i] = (<span class="built_in">pow</span>[i<span class="number">-1</span>] * <span class="number">29</span>) % MOD;</span><br><span class="line"></span><br><span class="line">read(m);</span><br><span class="line"><span class="keyword">while</span> (m--) &#123;</span><br><span class="line"><span class="keyword">int</span> l, r, len, ans;</span><br><span class="line">read(l), read(r), ans = len = r - l + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 一点点常数优化</span></span><br><span class="line"><span class="keyword">if</span> (calc(l+<span class="number">1</span>, r) == calc(l, r<span class="number">-1</span>)) &#123;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"1"</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 重点</span></span><br><span class="line"><span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (calc(l+ans/g[len], r) == calc(l, r-ans/g[len]))<span class="comment">// 判断</span></span><br><span class="line">ans /= g[len];<span class="comment">// 除掉循环次数的因子</span></span><br><span class="line">len /= g[len];<span class="comment">//分解</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 字符串 </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题解 P4167 【[Violet]樱花】</title>
      <link href="/2019/12/25/sol_P4167/"/>
      <url>/2019/12/25/sol_P4167/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a><a href="https://www.luogu.org/problem/P4167" target="_blank" rel="noopener">题目</a>描述</h3><p>求不定方程</p><script type="math/tex; mode=display">\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}</script><p>的正整数解(x,y)的数目。</p><hr><p>先开始<del>万恶的</del>推式子。。。</p><p>原式：</p><script type="math/tex; mode=display">\frac{1}{x} + \frac{1}{y} = \frac{1}{n!}</script><p>通个分：</p><script type="math/tex; mode=display">xy - n!x - n!y= 0</script><p>补点东西：</p><script type="math/tex; mode=display">xy - n!x - n!y + (n!)^2= (n!)^2</script><script type="math/tex; mode=display">(n! - x)(n! - y) = (n!)^2</script><p>此时答案就是$(n!)^2$的约数个数</p><hr><p>统计$n!$的约数个数：</p><p>把1~n质因数分解，统计各质因子的幂数和即可</p><p>再用唯一分解定理统计</p><p>注意线性筛素数时记录每一个数的最小质因子，分解就具体看代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e6</span> + <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> MOD = <span class="number">1e9</span> + <span class="number">7</span>;</span><br><span class="line"></span><br><span class="line">ll n, ans;</span><br><span class="line"><span class="keyword">int</span> cnt[N], g[N];</span><br><span class="line"><span class="keyword">bool</span> vis[N];</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pri;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">make_prime</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (!vis[i])</span><br><span class="line">pri.push_back(i), g[i] = pri.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123;</span><br><span class="line">vis[i*pri[j]] = <span class="literal">true</span>;</span><br><span class="line">g[i*pri[j]] = j;</span><br><span class="line"><span class="keyword">if</span> (i % pri[j] == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">read(n);</span><br><span class="line">make_prime();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> x = i;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">1</span>)</span><br><span class="line">cnt[g[x]]++, x /= pri[g[x]];</span><br><span class="line">&#125;</span><br><span class="line">ans = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pri.size(); ++i)</span><br><span class="line"><span class="keyword">if</span> (cnt[i])</span><br><span class="line">ans = (ans * (cnt[i] * <span class="number">2</span> + <span class="number">1</span>)) % MOD;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, ans);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 线段树/树状数组</title>
      <link href="/2019/12/25/%E6%80%BB%E7%BB%93-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"/>
      <url>/2019/12/25/%E6%80%BB%E7%BB%93-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>虽然是总结，但是真的讲不出点啥，贴个板子就溜</p><p>毕竟就我自己看</p><h2 id="树状数组"><a href="#树状数组" class="headerlink" title="树状数组"></a>树状数组</h2><p>单点修改，区间查询</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x &amp; -x)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt;= n; i += lowbit(i))</span><br><span class="line">tr[i] += k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = x; i; i -= lowbit(i))</span><br><span class="line">ans += tr[i];</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改</span></span><br><span class="line">update(x, k)</span><br><span class="line"><span class="comment">// 查询l到r区间和</span></span><br><span class="line">query(r) - query(l<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><blockquote><p>单点修改，区间查询好像还能CDQ分治</p></blockquote><p>进阶操作：区间修改，单点查询</p><p>用树状数组维护差分序列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 区间修改</span></span><br><span class="line">update(l, k)</span><br><span class="line">update(r+<span class="number">1</span>, -k)</span><br><span class="line"><span class="comment">// 单点查询</span></span><br><span class="line">query(x)</span><br></pre></td></tr></table></figure><h2 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h2><p>区间修改，区间查询</p><p>要开4倍空间</p><p>每个节点的l，r可以存下来，也可以现算（卡空间的话）</p><p>包装起来比较优美</p><p>最好动态开点（存$lson$和$rson$），当成二叉堆存也行（比较难调，还丑）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Leave</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, sum, lazy;</span><br><span class="line">    &#125;;</span><br><span class="line">    Leave tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> cnt;</span><br><span class="line">    <span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        tr[suc].sum = tr[tr[suc].ls].sum + tr[tr[suc].rs].sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = tr[suc].ls, rs = tr[suc].rs, mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[ls].lazy += tr[suc].lazy;</span><br><span class="line">        tr[ls].sum += (mid - L + <span class="number">1</span>) * tr[suc].lazy;</span><br><span class="line">        tr[rs].lazy += tr[suc].lazy;</span><br><span class="line">        tr[rs].sum += (R - mid) * tr[suc].lazy;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            tr[suc].sum = val[L];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[suc].ls = ++cnt, tr[suc].rs = ++cnt;</span><br><span class="line">        build(tr[suc].ls, L, mid), build(tr[suc].rs, mid+<span class="number">1</span>, R);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= L &amp;&amp; R &lt;= cr) &#123;</span><br><span class="line">            tr[suc].sum += (R - L + <span class="number">1</span>) * k;</span><br><span class="line">            tr[suc].lazy += k;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= mid)</span><br><span class="line">            change(tr[suc].ls, L, mid, cl, cr, k);</span><br><span class="line">        <span class="keyword">if</span> (cr &gt; mid)</span><br><span class="line">            change(tr[suc].rs, mid+<span class="number">1</span>, R, cl, cr, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= L &amp;&amp; R &lt;= qr)</span><br><span class="line">            <span class="keyword">return</span> tr[suc].sum;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].ls, L, mid, ql, qr);</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr);</span><br><span class="line">        <span class="keyword">return</span> query(tr[suc].ls, L, mid, ql, qr) + query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>线段树基本上都套板子，会魔改的只有$push_up()$和$query()$的合并操作</p><h3 id="没有lazy-tag的暴力修改"><a href="#没有lazy-tag的暴力修改" class="headerlink" title="没有lazy tag的暴力修改"></a>没有lazy tag的暴力修改</h3><h4 id="区间开根"><a href="#区间开根" class="headerlink" title="区间开根"></a>区间开根</h4><p><a href="https://www.luogu.org/problem/SP2713" target="_blank" rel="noopener">SP2713</a></p><p>每个数开方几次就会变成1，暴力修改即可</p><p>打tag记录区间是否都为1</p><h4 id="区间改成约数"><a href="#区间改成约数" class="headerlink" title="区间改成约数"></a>区间改成约数</h4><p><a href="https://www.luogu.org/problem/CF920F" target="_blank" rel="noopener">CF920F</a></p><p>同上</p><h3 id="线段树维护序列操作"><a href="#线段树维护序列操作" class="headerlink" title="线段树维护序列操作"></a>线段树维护序列操作</h3><blockquote><p>基本上都是多了维护前缀答案和后缀答案，从而利于合并</p></blockquote><h4 id="区间最大子段和"><a href="#区间最大子段和" class="headerlink" title="区间最大子段和"></a>区间最大子段和</h4><p><a href="https://www.luogu.org/problem/SP1043" target="_blank" rel="noopener">SPOJ1043</a></p><p><a href="https://www.luogu.org/problem/SP1716" target="_blank" rel="noopener">SPOJ1716</a></p><p>记录每个节点的最大子段和，最大前缀，最大后缀，区间和</p><h4 id="区间涂色"><a href="#区间涂色" class="headerlink" title="区间涂色"></a>区间涂色</h4><p><a href="https://www.luogu.org/problem/P2894" target="_blank" rel="noopener">P2894</a></p><p>维护前缀空房数和后缀空房数，同上</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树状数组 </tag>
            
            <tag> 线段树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>总结 树链剖分</title>
      <link href="/2019/12/25/%E6%80%BB%E7%BB%93-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"/>
      <url>/2019/12/25/%E6%80%BB%E7%BB%93-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/</url>
      
        <content type="html"><![CDATA[<p>咕了很久，敲完才体会到什么是“出题人<del>毫无意义地</del>强行把代码增加5KB”</p><hr><p>首先，树剖是把一棵树划分成多条轻重链，然后用线段树维护这些链</p><p><a href="https://www.luogu.org/problem/P3384" target="_blank" rel="noopener">模板题</a></p><p>通过基础的树剖，可以做以下操作：</p><ul><li>将树从x到y最短路径上的权值都加上z </li><li>求树从x到y最短路径上的权值和 </li><li>将以x为根节点的子树内权值都加上z </li><li>求将以x为根节点的子树内的权值和</li></ul><h2 id="具体做法"><a href="#具体做法" class="headerlink" title="具体做法:"></a>具体做法:</h2><h3 id="dfs1"><a href="#dfs1" class="headerlink" title="dfs1"></a>dfs1</h3><p>遍历一遍树，求出每个点的：</p><p>$fa[x]$：父亲</p><p>$deep[x]$：深度</p><p>$sz[x]$：子树大小</p><p>$son[x]$：重儿子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    fa[x] = last;</span><br><span class="line">    deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y, maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != last) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs1(y, x);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; maxson)</span><br><span class="line">                maxson = sz[y], son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="dfs2"><a href="#dfs2" class="headerlink" title="dfs2"></a>dfs2</h3><p>第二遍遍历要划分轻重链，先求出：</p><p>$id[x]$：x的$dfs$序</p><p>$top[x]$：x所在链的起始点</p><p>注意先走重儿子，再遍历轻儿子，使得重链每个点的$dfs$序一定是连续的</p><p>根据$dfs$序的性质，x的子树每个点的$dfs$序也是连续的</p><p>因此可以用线段树维护得到的$dfs$序（记得把权值转移到$dfs$序上）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top_)</span> </span>&#123;</span><br><span class="line">    id[x] = ++cnt;</span><br><span class="line">    top[x] = top_;</span><br><span class="line">    segtree.val[id[x]] = val[x];<span class="comment">// 转移权值</span></span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top_);<span class="comment">// 先重儿子</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[x] &amp;&amp; e[i].to != son[x])</span><br><span class="line">            dfs2(e[i].to, e[i].to);<span class="comment">// 轻儿子新开一条链</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h3><p>直接在$dfs$序上建立线段树，套模板即可</p><p>这里就不贴code了</p><blockquote><p>update on 2020.1.21</p><p>听学长讲，对于每个链单独开一棵线段树可以减小常数</p></blockquote><hr><p>下面是<del>愉快的</del>各种操作。。。</p><h3 id="路径修改-查询"><a href="#路径修改-查询" class="headerlink" title="路径修改/查询"></a>路径修改/查询</h3><p>对于每个x和y</p><p>我们可以不停的让<strong>深度大的</strong>跳到所在链的顶部，在线段树上直接操作一个链</p><p>直到x和y在同一个链上，然后还是线段树操作</p><p>（注意，让深度小的往上跳，可能会错过最短路径）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);<span class="comment">// 选深度大的</span></span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;<span class="comment">// 不在同一条链时</span></span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);<span class="comment">//注意深度</span></span><br><span class="line">        segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], k);<span class="comment">// 注意顺序，链顶的id一定大于x的id</span></span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);<span class="comment">// 注意顺序</span></span><br><span class="line">    segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路径查询同理，就不贴了</p><blockquote><p>话说这里太容易出bug了 QAQ</p></blockquote><h3 id="子树修改-查询"><a href="#子树修改-查询" class="headerlink" title="子树修改/查询"></a>子树修改/查询</h3><p>因为以x为根的子树在$dfs$序上一定是连续的一段</p><p>线段树直接操作$id[x]$到$id[x]+sz[x]-1$的区间</p><p><code>segtree.change(1, 1, n, id[x], id[x]+sz[x]-1, z);</code></p><p>查询同理</p><hr><h3 id="LuoguP3384-AC代码"><a href="#LuoguP3384-AC代码" class="headerlink" title="LuoguP3384 AC代码"></a>LuoguP3384 AC代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(T &amp;x)</span> </span>&#123;</span><br><span class="line">x = <span class="number">0</span>; T k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) x = x * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line">x *= k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> nxt, to;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Segtree</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Leave</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> ls, rs, sum, lazy;</span><br><span class="line">    &#125;;</span><br><span class="line">    Leave tr[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> mod, cnt;</span><br><span class="line">    <span class="keyword">int</span> val[N];</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> suc)</span> </span>&#123;</span><br><span class="line">        tr[suc].sum = (tr[tr[suc].ls].sum + tr[tr[suc].rs].sum) % mod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ls = tr[suc].ls, rs = tr[suc].rs, mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        (tr[ls].lazy += tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[ls].sum += (mid - L + <span class="number">1</span>) * tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[rs].lazy += tr[suc].lazy) %= mod;</span><br><span class="line">        (tr[rs].sum += (R - mid) * tr[suc].lazy) %= mod;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        tr[suc].lazy = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (L == R) &#123;</span><br><span class="line">            tr[suc].sum = val[L];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        tr[suc].ls = ++cnt, tr[suc].rs = ++cnt;</span><br><span class="line">        build(tr[suc].ls, L, mid), build(tr[suc].rs, mid+<span class="number">1</span>, R);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> cl, <span class="keyword">int</span> cr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= L &amp;&amp; R &lt;= cr) &#123;</span><br><span class="line">            (tr[suc].sum += (R - L + <span class="number">1</span>) * k) %= mod;</span><br><span class="line">            (tr[suc].lazy += k) %= mod;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (cl &lt;= mid)</span><br><span class="line">            change(tr[suc].ls, L, mid, cl, cr, k);</span><br><span class="line">        <span class="keyword">if</span> (cr &gt; mid)</span><br><span class="line">            change(tr[suc].rs, mid+<span class="number">1</span>, R, cl, cr, k);</span><br><span class="line">        push_up(suc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> suc, <span class="keyword">int</span> L, <span class="keyword">int</span> R, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ql &lt;= L &amp;&amp; R &lt;= qr)</span><br><span class="line">            <span class="keyword">return</span> tr[suc].sum;</span><br><span class="line">        push_down(suc, L, R);</span><br><span class="line">        <span class="keyword">int</span> mid = (L + R) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (qr &lt;= mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].ls, L, mid, ql, qr);</span><br><span class="line">        <span class="keyword">if</span> (ql &gt; mid)</span><br><span class="line">            <span class="keyword">return</span> query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr);</span><br><span class="line">        <span class="keyword">return</span> (query(tr[suc].ls, L, mid, ql, qr) + query(tr[suc].rs, mid+<span class="number">1</span>, R, ql, qr)) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, Q, root, mod, cnt;</span><br><span class="line"><span class="keyword">int</span> head[N], val[N], deep[N], sz[N], fa[N], son[N], top[N], id[N];</span><br><span class="line">Edge e[N&lt;&lt;<span class="number">1</span>];</span><br><span class="line">Segtree segtree;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a;</span><br><span class="line">    a = b, b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> last)</span> </span>&#123;</span><br><span class="line">    fa[x] = last;</span><br><span class="line">    deep[x] = deep[last] + <span class="number">1</span>;</span><br><span class="line">    sz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> y, maxson = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != last) &#123;</span><br><span class="line">            y = e[i].to;</span><br><span class="line">            dfs1(y, x);</span><br><span class="line">            sz[x] += sz[y];</span><br><span class="line">            <span class="keyword">if</span> (sz[y] &gt; maxson)</span><br><span class="line">                maxson = sz[y], son[x] = y;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> top_)</span> </span>&#123;</span><br><span class="line">    id[x] = ++cnt;</span><br><span class="line">    top[x] = top_;</span><br><span class="line">    segtree.val[id[x]] = val[x];</span><br><span class="line">    <span class="keyword">if</span> (!son[x])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs2(son[x], top_);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = head[x]; i; i = e[i].nxt)</span><br><span class="line">        <span class="keyword">if</span> (e[i].to != fa[x] &amp;&amp; e[i].to != son[x])</span><br><span class="line">            dfs2(e[i].to, e[i].to);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">change_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x], k);</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y], k);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query_road</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &lt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (top[x] != top[y]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[top[x]] &lt; deep[top[y]])</span><br><span class="line">            swap(x, y);</span><br><span class="line">        (res += segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[top[x]], id[x])) %= mod;</span><br><span class="line">        x = fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (deep[x] &gt; deep[y])</span><br><span class="line">        swap(x, y);</span><br><span class="line">    (res += segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[y])) %= mod;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    read(n), read(Q), read(root), read(mod);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        read(val[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>, u, v; i &lt; n; ++i)</span><br><span class="line">        read(u), read(v), add(u, v), add(v, u);</span><br><span class="line">    dfs1(root, <span class="number">0</span>);</span><br><span class="line">    cnt = <span class="number">0</span>;</span><br><span class="line">    dfs2(root, root);</span><br><span class="line">    segtree.mod = mod, segtree.cnt = <span class="number">1</span>;</span><br><span class="line">    segtree.build(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> opt, x, y, z;</span><br><span class="line">    <span class="keyword">while</span> (Q--) &#123;</span><br><span class="line">        read(opt);</span><br><span class="line">        <span class="keyword">switch</span> (opt) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                read(x), read(y), read(z);</span><br><span class="line">                change_road(x, y, z);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                read(x), read(y);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, query_road(x, y));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                read(x), read(y);</span><br><span class="line">                segtree.change(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x]+sz[x]<span class="number">-1</span>, y);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                read(x);</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, segtree.query(<span class="number">1</span>, <span class="number">1</span>, n, id[x], id[x]+sz[x]<span class="number">-1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BANANA::main();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一次写的时候太艰辛了，调了半天发现是$swap()$写错了$qwq$</p>]]></content>
      
      
      <categories>
          
          <category> 总结 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树链剖分 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过namespace防止命名冲突</title>
      <link href="/2019/12/25/%E9%80%9A%E8%BF%87namespace%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81/"/>
      <url>/2019/12/25/%E9%80%9A%E8%BF%87namespace%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81/</url>
      
        <content type="html"><![CDATA[<p>不止一位学长讲述过一些选手因为”next””pipe”而暴毙的英雄事迹。。。</p><p>那么Linux下如何防止命名冲突？</p><p><del>或者仅仅是因为懒得想变量名</del></p><p><strong><em>听过学长的指导后，本文全程口糊，有不恰当处还请指出</em></strong></p><p>C++中有了<strong>命名空间</strong>这个东西，不同命名空间的元素可以同名</p><p>你平时写的<code>using namespace std;</code>就是代替了每次调用时的<code>std::</code>，相当于把std作为此程序的命名空间</p><p>我们可以创建自己的命名空间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> NAME &#123;<span class="comment">// NAME可以是你自己取的名字</span></span><br><span class="line">    <span class="comment">// code...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>里面的程序正常写就行</p><p>不过C++的运行端口是::main，所以main函数写在namespace里会找不到端口，无法运行</p><p>只把main写在外面？<del>这辈子都不会的</del></p><p>为了程序的优美性，可以namespace里写一个main，外面调用即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;<span class="comment">// inline是一点优化，自己百度。因为没必要必须返回0，可以是void</span></span><br><span class="line">        <span class="comment">// code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();<span class="comment">// 和std同理，通过BANANA::调用就没有冲突</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话写一大堆函数和全局变量的时候，main函数依然优美</p><p><strong>总之自己看着舒服就行</strong></p><p>另外，namespace是可以<strong>嵌套</strong>的，并且优先级是<strong>本层namespace &gt; 外层namespace</strong></p><p>调用时本层找不到就会从上一层找</p><p>于是我们照样写<code>using namespace std</code>，不受影响，<del>太棒了不用写烦人的std</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">namespace</span> OI &#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">sell</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt;<span class="string">"兜售小main包烤绿鸟"</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// cout照样用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 这里的a = 1</span></span><br><span class="line">        OI::sell();<span class="comment">// 调用其他namespace的元素同理</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了你还怕什么？</p><p>不过学长实测，如果你起linux,unix的变量名，还是会翻车，<del>他们太硬了</del></p><p>不过你可以随心所欲地打万能头了。。。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;</span><br><span class="line">    <span class="keyword">int</span> x1, x2, y1, y2;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pipe, next[<span class="number">105</span>];</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"小main包烤绿鸟还有人要么！！！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BANANA::main();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>祝大家敲代码愉快~</p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>题解 P1322 【logo语言】</title>
      <link href="/2019/12/24/sol_P1322/"/>
      <url>/2019/12/24/sol_P1322/</url>
      
        <content type="html"><![CDATA[<p><strong>这里是栈的做法</strong></p><p>递归快写吐了，决心用栈，结果调了半天。。。</p><p>应该都能想到，FD就加，BF就减，REPEAT就压栈，’]’就弹栈</p><p>手写栈比较舒服，<del>用STL的stack有点丑</del></p><p><strong>细节太重要了</strong></p><p>敲的时候应该注意：读入是否从有效字符开始（用char[]的注意）、’]’的读入、用过的那层栈要清空。。。</p><p><del>都是废话，自己写写就知道了</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cctype&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> BANANA &#123;<span class="comment">//防止命名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;<span class="comment">// 快读</span></span><br><span class="line"><span class="keyword">int</span> re = <span class="number">0</span>, k = <span class="number">1</span>; <span class="keyword">char</span> in = getchar();</span><br><span class="line"><span class="keyword">while</span> (!<span class="built_in">isdigit</span>(in)) &#123; <span class="keyword">if</span> (in == <span class="string">'-'</span>) k = <span class="number">-1</span>; in = getchar(); &#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">isdigit</span>(in)) re = re * <span class="number">10</span> + in - <span class="string">'0'</span>, in = getchar();</span><br><span class="line"><span class="keyword">return</span> re * k;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> <span class="built_in">stack</span>[<span class="number">305</span>], k[<span class="number">305</span>];<span class="comment">// stack：栈，k：这一层栈repeat的次数</span></span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">num</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;<span class="comment">// 把s串开头的数字提出来</span></span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; <span class="built_in">isdigit</span>(s[i]); i++)</span><br><span class="line">ans = ans * <span class="number">10</span> + s[i] - <span class="string">'0'</span>;</span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> top = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; s) &#123;<span class="comment">// ctrl+z结束</span></span><br><span class="line"><span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'F'</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="built_in">stack</span>[top] += num(s);</span><br><span class="line"><span class="keyword">int</span> len = s.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (s[len] == <span class="string">']'</span>)<span class="comment">// 结尾有']'要退栈</span></span><br><span class="line"><span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'B'</span>) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; s;</span><br><span class="line"><span class="built_in">stack</span>[top] -= num(s);</span><br><span class="line"><span class="keyword">int</span> len = s.size() - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (s[len] == <span class="string">']'</span>)</span><br><span class="line"><span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, len--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">'R'</span>) &#123;</span><br><span class="line">k[top] = read();</span><br><span class="line">top++;</span><br><span class="line"><span class="built_in">stack</span>[top] = <span class="number">0</span>;<span class="comment">// 用之前清空（之前因为这个WA了</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 特判"[]"里什么都没有的</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;<span class="comment">// 前面已经读入了'['，所以从0开始</span></span><br><span class="line"><span class="keyword">while</span> (s[i] == <span class="string">']'</span> &amp;&amp; i &lt; s.size())</span><br><span class="line"><span class="built_in">stack</span>[top<span class="number">-1</span>] += k[top<span class="number">-1</span>] * <span class="built_in">stack</span>[top], top--, i++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">abs</span>(<span class="built_in">stack</span>[<span class="number">1</span>]));<span class="comment">// 注意是距离（绝对值）</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">BANANA::main();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 题解 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
