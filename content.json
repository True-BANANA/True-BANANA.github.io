{"meta":{"title":"BANANA","subtitle":"","description":"","author":"BANANA","url":"http://True-BANANA.github.io","root":"/"},"pages":[{"title":"404 Not Found","date":"2019-12-29T11:31:11.538Z","updated":"2019-12-29T11:31:11.502Z","comments":true,"path":"404.html","permalink":"http://true-banana.github.io/404.html","excerpt":"","text":"**404 Not Found** **很抱歉，您访问的页面不存在** 可能是输入地址有误或该地址已被删除"},{"title":"关于","date":"2020-04-07T15:32:31.529Z","updated":"2020-04-07T15:32:31.518Z","comments":true,"path":"about/index.html","permalink":"http://true-banana.github.io/about/index.html","excerpt":"","text":"BANANA 是个初三狗，菜的真实 就读于河北省石家庄二中石门校区 每日被文化课压榨，只能偶尔翘晚自习来机房 /kk 迫于中考压力（其实是老师家长的压力）已经 AFO 了 至于这个 blog ，我这么懒的人只会慢慢荒废掉 CSDN有广告，博客园太丑（自己美化太麻烦，用 js 都要写理由申请） Luogu 博客很香，就是可 diy 性差 我的luogu博客 于是我颓废了三天搭了 hexo 博客 真的是随缘更新~ 大概就是算法总结和题解之类的 “板子 **”会只贴板子，“总结 **”会有一些讲解和经验 真希望有人来看啊 QAQ 也希望各位oi巨佬和我交换 友链 啊 BANANA 还是个忠实的死宅，喜欢看番、推galgame、追轻小说、打音游、听EDM……（我的时间就是这么 荒废的） 如果兴趣相投可以和我交朋友，并在我颓废的时候怼我"},{"title":"所有分类","date":"2019-12-26T12:40:52.948Z","updated":"2019-12-26T12:40:52.937Z","comments":true,"path":"categories/index.html","permalink":"http://true-banana.github.io/categories/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2020-01-20T07:52:03.359Z","updated":"2020-01-20T07:52:03.261Z","comments":true,"path":"friends/index.html","permalink":"http://true-banana.github.io/friends/index.html","excerpt":"","text":"随便放了一点，总之虐我的神仙太多了。。。 \\huge\\text{欢迎交换友链！！！}"},{"title":"","date":"2019-12-26T12:52:27.721Z","updated":"2019-12-26T12:52:27.698Z","comments":true,"path":"mylist/index.html","permalink":"http://true-banana.github.io/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-12-26T12:51:17.752Z","updated":"2019-12-26T12:51:17.736Z","comments":true,"path":"tags/index.html","permalink":"http://true-banana.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"博客迁移通知","slug":"2020-07-28-博客迁移通知","date":"2020-07-28T07:30:00.000Z","updated":"2020-07-28T07:53:17.936Z","comments":true,"path":"2020/07/28/2020-07-28-博客迁移通知/","link":"","permalink":"http://true-banana.github.io/2020/07/28/2020-07-28-%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E9%80%9A%E7%9F%A5/","excerpt":"","text":"RenaMoe’s Blog我在 gitee 搭了一个新 blog 访问速度更快，主题也更新了 欢迎访问和添加友链！","categories":[{"name":"随笔","slug":"随笔","permalink":"http://true-banana.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"回顾我的初中oi生涯","slug":"2020-04-07-回顾我的初中oi生涯","date":"2020-04-07T13:00:00.000Z","updated":"2020-04-09T13:06:13.540Z","comments":true,"path":"2020/04/07/2020-04-07-回顾我的初中oi生涯/","link":"","permalink":"http://true-banana.github.io/2020/04/07/2020-04-07-%E5%9B%9E%E9%A1%BE%E6%88%91%E7%9A%84%E5%88%9D%E4%B8%ADoi%E7%94%9F%E6%B6%AF/","excerpt":"","text":"声明：本文为博主真实感受，绝无 fake 之言 每句话加句号可是我很难得的正经语气~ 大概 2017 年 8 月，初一前的暑假知道了信息学竞赛，有点兴趣，也没什么概念。 当时还发现了洛谷这个网站，注册了账号，觉得里面好高深啊（当时连编程语言都不知道是啥），以至于 我的洛谷账号 是自豪的五位编号。 入学石门实验学校（这个我又爱又恨的学校）后，报了个 C 语言的校本课程。当时石门的几乎没有竞赛经验，学校微机老师每周随随便便教一节课，一个学期了 C 语法没学完。第二学期一个德行（甚至还收了钱），初一一道正经题没做过。 2018 年暑假，二中南校区组织培训，南校教练教大概普及难度，基本是上边念课件下边颓废，不够培训完已经能用 C++ 写题了。记得是一本通 oj 和洛谷上刷了三四十道题（尽是些入门题），也算是真正入门了。 上了初二，报了 NOIP2018 的普及组，考前两个月组织每天下午有一个多小时专门到小屋子里做题。并不是很努力，一直在吃暑假的老本，每次模拟考还不算垫底，较难的牛客模拟赛天天炸。lym 神犇次次 rk1，orz。十一国庆有个北校的培训，基本听不懂。 考试发挥还算稳定，拿了186，毕竟到那时我是个搜索还不一定写的对的菜鸡，dp 只写过 01 背包，只是刚初步养成代码思维，t1还写挂了30qwq。万幸的是我在 HE 弱省，1=分数线居然 140！！！ 那年石门有lym、lsq、ljz（我）拿了1=，南校找我们签了约，然而并没有免学费。不过从此开始了我的提高组学习（还啥都不会呢就跟着高一学提高？？？），得到了每周去三次南校机房自习一个多小时的机会。 我果然是啥都不会啊，2019年的寒假到北校培训，讲的提高组算法（简单的dp、线段树等数据结构、基本的数论线代之类的），然而对我来说是天书。做题量匮乏（就五十多道红橙题）的我相当于一个只会语法的入门菜鸡，听课发呆、课后颓废、考试爆零已经成了习惯。唯一的收获是思维提高了，对各种算法有了初步的印象。lym 太神仙了总是吊打高一学长，初三的 lsq 中途似乎退役学文化课去了 初二考后的时间基本维持在一个月三四道题的速度，简直毫无长进。 2019 年的暑假是我 oi 生涯的转折点。 刚放暑假就去了南校培训，有两天全天自习，恶补了些图论和数学（那时候才会链式前向星和最短路好羞耻），也体验了一天十道题的快感。水平还是很差，会一些黄绿题，蓝题还得看题解。 因为性格比较慢熟，水平差比较自卑，和高一学长关系比较冷淡，挺孤独的。 7月北校培训已经是提高组拔高的水平了，我更吃力了，很快就回到了寒假的颓废状态。我发现了自己的致命弱点——做题太少。培训完的时间终于开始养成假期坚持做题的习惯，可还是深深地体会到自己水平的低下。 后来 rl 教练联系我，问我参不参加准高一的培训，是刚退役的高三学长讲的面向基础的知识。我觉得从基础开始补。说是基础，其实进度很快，高三学长也比较热情地往难讲。在北校的一周对我来说还算轻松，毕竟同机房的高一学长刚会语法，我跟着刷题，提升了不少代码能力和基础算法（搜索、二分之类的）能力。lym 没有参加，落单的我开始结识一些高一的同学。 到了南校又培训了十几天，难度已经和那年寒假差不多了。自我感觉刚退役的高三学长讲的比老一辈的学长要更易于接受。我虽说浪费了整个初二，但水平也在那个机房属于领先，不由得变得轻浮起来。当时一整天只有下午讲课，可是我变得越来越颓废，一天做不了三四个蓝题，不过长进相比初二快很多。佩服 lhm 刘队长，每天切题十几道，异常的努力。 南校宿舍管的很松，晚上我便带电脑回宿舍。那时候迷上了动漫电影，每天下载一部晚上看到12点（宿舍没网啊），午休会看两三集下好的番。那时起从阳光的男初中生彻底堕落成恶心死宅。不过因为熬夜，早上经常犯困。而且在机房听歌耳机被没收了好羞耻。 这次培训让我的oi学习步入了正轨，终于能够把讲的听懂的落实到代码上了。刷题速度也正常了（暑假AC200了）。虽然不是很努力，但也是个不低的起步点。 8月后面还有北校高二的培训，依旧很难，我又自闭了。番倒是补了不少。 那时 NOIP 取消了，我感觉将来的 oi 生涯可能不会平静了。 上了初三，文化课压力直线上升。可我还是安排上了一周翘掉两三个晚自习去南校机房，我也成了班里经常性不交作业的人（我的座位在讲台正前面，以至于每天摊开空作业在老师眼皮底下听课）。临近 CSP，我的积极性也提上来了，对自己的要求严格起来。每次去机房都要求自己做两道以上蓝紫题（真是我为数不多的努力时刻）。那段时间渐渐融入了南校高一的机房（存真楼txdy！）。 其实当时我文化课并没有落下，因为我每天都在因期盼着去机房而努力提高学习效率，要说没有oi我的文化课也好不到哪里去。 CSP2019 发挥的并不是太好，二百多点分拿了tg2=，pj别提了，详细的看我 CSP2019 游记。这次CSP似乎二中发挥的都不太好，据我所知南校高二有不少很强的学长退役了，没退役的分数也不是很理想。回石家庄的路上大家心情都很沉重。 也许是意识到自己水平差距依然很大，考后我更用功了，虽然我面临着中考这一大难题。那段时间我只能靠努力维持文化课和oi的平衡。开始着手省选难度的内容，不得不说省选范围广难度又大啊。 期末考前半个月没去机房，虽然期末考了年级前十，心里却很空虚（要是 CSP 有1=多好啊）。 2020年寒假到北校培训省选内容，高二人数太少了，和第一批高一的一个机房。难度很大，毕竟是针对高二准备省选的学长，再次自闭。 之前北校培训一直走读，这次住宿还算愉快，经常和南校同机房的出去吃晚饭，一不小心又养成了爱喝奶茶的坏习惯。宿舍管的也不严，晚上总是肝题和推gal到凌晨两三点 这个寒假不安宁：羟基计划代替了自招，新冠病毒爆发。我初中开始走下坡路的转折点。 问题是寒假培训第二阶段取消了，学校开学也推迟了。 恰巧当时饮食和熬夜过于放纵，我感冒了……过年期间还发了一次烧，吓怕我了。不过过两周康复了。 寒假文化课作业一直翘着，直到网上开学也没交过作业，缓慢地学着oi，这种低效率的状态持续到二月底，班主任打电话过来了。我开始每天完成作业了，但是这意味着要AFO直到中考完。 HE是中高考大省，竞赛的话高中生可能有二中衡中等强校给你好的条件，初中则没个老师管你竞赛咋样。HE 的oier大多都是高中零基础开始的，这两年也吃了大亏。对于石门来说，啥样的竞赛奖项都不如好的中考成绩实在，这关系到学校的生源和老师的工资。我也是因为文化课没有掉太多，班主任之前没咋管我，但临近中考了，老师家长不愿让一个初三生在分心学oi。更重要的，南校只有中考上了600才免学费，私立的南校的学费一直是不小的负担。 在家状态极差，完成作业对于我简直是世界难题。最快最快（在课上也偷写作业）也要晚上十点半写完，然而十点就会被催去睡觉。我真是效率低的失败人士（不过作业真的比在学校还多）。这种烂状态咋挤时间学oi？久了也开始颓废了，作业越来越应付了，只是单纯的觉得学习没了奔头。 我每天看番、推galgame、追轻小说、打osu、刷知乎……然后抄完作业答案对着日历叹息。 这样下去文化课也学不好吧？我真的忍不了了，四月一号情绪激动地和父母诉说了，在家这样荒废时间还不如再学学oi。班主任也同意了（我当时借口是调整心态）。我仿佛获得了新生，刷题速度一度飙升。 这样又能维持的了多久？突然又不交作业的我被各科老师催来催去，我这个基本问题全在我身上的理由难以向老师表达。文化课不好好补补中考迟早药丸啊，初三第一学期的老本又能吃多久。期盼着早点开学，等来的却是一次又一次延迟的通知。 4月9号，决定了全身心回归文化课（线上考试的事情打乱了我要AC350的计划） To be continued… 我不过是一具懒惰的身躯包裹着的脆弱的心灵，回顾我颓废的初中生活，只有无意义的叹息。 从初中开始学oi，是我曾经的优势，也是我如今的遗憾。 OI is my faith! 感谢初中有oi相伴，高中我会更加努力的~","categories":[{"name":"随笔","slug":"随笔","permalink":"http://true-banana.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"总结 虚树","slug":"2020-04-06-总结-虚树","date":"2020-04-06T00:40:00.000Z","updated":"2020-04-06T01:18:29.385Z","comments":true,"path":"2020/04/06/2020-04-06-总结-虚树/","link":"","permalink":"http://true-banana.github.io/2020/04/06/2020-04-06-%E6%80%BB%E7%BB%93-%E8%99%9A%E6%A0%91/","excerpt":"","text":"某些树形dp的数据范围过大，有多次询问，每次询问选定关键点（关键点总和在 1e5~1e6 的范围） 例题：P2495 [SDOI2011]消耗战 此时会有很多点不需要参与dp，只要另外建出一棵包含有用点的虚树来 有一种增量构造的方法，难写难记（几个月前写的还没调出来），所以我干脆只学本文这种方法 推荐 shadowice1984 的博客 思路我们只要掌握了一棵树的dfs序，就可以模拟整个dfs过程 对于关键点序列 a，dfs 一遍，求出每个点的 dfs 序（入栈和出栈的） 1234567void dfs(int u, int last) &#123; pu[u] = ++dfu; for (int i = head[u], v; i; i = e[i].nxt) if ((v = e[i].to) != last) &#123; dfs(v, u); po[u] = ++dfu;&#125; 将关键点按dfs序排序，相邻两个点取 LCA，加入 a 序列，再把树根 1 加入 注意开个 bool 数组去重 最后把整个序列 a 复制一份，全部取负，加入序列 此时序列 a 中全是虚树节点，正数代表入栈点，负数代表出栈点 将 a 序列按照 dfs 序排序，cmp 中要区分出入栈： 123inline bool cmp(int x, int y) &#123; return (x &gt; 0 ? pu[x] : po[-x]) &lt; (y &gt; 0 ? pu[y] : po[-y]);&#125; 现在整个虚树的 dfs 序已经知道了，如果是简单的树形dp甚至不需要建树，直接模拟 dfs 遍历： 开一个栈，遍历 a 序列，如果是正数即入栈，进行 dfs 递归前的操作 负数说明出栈，进行 dfs 递归完各个子树后的操作 如果要建树，“dfs”时对于每个父子关系建边就行 1234567for (int i = 1, u, v; i &lt;= tot; ++i) &#123; if (a[i] &gt; 0) stk[++top] = a[i]; else &#123; v = stk[top--], u = stk[top]; Add_edge(u, v), Add_edge(v, u); &#125; &#125; 注意多次询问的一定要清空（在 a 序列上的点），不能用 $O(n)$ 的 memset code123456789101112131415161718192021222324252627282930313233343536373839int tot, top, cnt_e;int a[N&lt;&lt;1], stk[N];bool vis[N];inline void Add_edge(int u, int v) &#123;/*...*/&#125;void dfs(int u, int last) &#123; pu[u] = ++dfu; // 预处理LCA用的deep,fa... for (int i = head[u], v; i; i = e[i].nxt) if ((v = e[i].to) != last) &#123; dfs(v, u); po[u] = ++dfu;&#125;inline int LCA(int x, int y) &#123;/*...*/&#125;inline bool cmp(int x, int y) &#123; return (x &gt; 0 ? pu[x] : po[-x]) &lt; (y &gt; 0 ? pu[y] : po[-y]);&#125;inline void build_tree(int k) &#123; tot = top = cnt_e = 0; for (int i = 1; i &lt;= k; ++i) a[++tot] = array[i], vis[a[tot]] = true; sort(a+1, a+tot+1, cmp); for (int i = 1, lca; i &lt; k; ++i) &#123; lca = LCA(a[i], a[i+1]); if (!vis[lca]) a[++tot] = lca, vis[lca] = true; &#125; if (!vis[1]) a[++tot] = 1; k = tot; for (int i = 1; i &lt;= k; ++i) a[++tot] = -a[i]; sort(a+1, a+tot+1, cmp); for (int i = 1, u, v; i &lt;= tot; ++i) &#123; if (a[i] &gt; 0) stk[++top] = a[i]; else &#123; v = stk[top--], u = stk[top]; Add_edge(u, v), Add_edge(v, u); vis[v] = false; &#125; &#125;&#125; Luogu P2495 code顺便放上去 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;x) &#123;&#125;template&lt;typename TT&gt; inline void print(TT x, char end = '\\n') &#123;&#125;typedef long long LL;const int N = 25e4 + 9;struct Edge &#123; int nxt, to, val;&#125;;int n, m, cnt_e, dfu;int head[N], pu[N], po[N], fa[N][20], deep[N], mn[N], a[N&lt;&lt;1], stk[N];LL f[N];bool vis[N];Edge e[N&lt;&lt;1];inline void add_edge(int u, int v, int w) &#123; e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;&#125;void dfs(int u, int last) &#123; pu[u] = ++dfu; deep[u] = deep[last] + 1; fa[u][0] = last; for (int i = 1; 1 &lt;&lt; i &lt;= deep[u]; ++i) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int i = head[u], v; i; i = e[i].nxt) if ((v = e[i].to) != last) &#123; mn[v] = min(mn[u], e[i].val); dfs(v, u); &#125; po[u] = ++dfu;&#125;int LCA(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); for (int i = 19; ~i; --i) if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; for (int i = 19; ~i; --i) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return x == y ? x : fa[x][0];&#125;inline bool cmp(int x, int y) &#123; return (x &gt; 0 ? pu[x] : po[-x]) &lt; (y &gt; 0 ? pu[y] : po[-y]);&#125;int main() &#123; read(n); for (int i = 1, u, v, w; i &lt; n; ++i) read(u), read(v), read(w), add_edge(u, v, w), add_edge(v, u, w); mn[1] = 0x7fffffff; dfs(1, 0); read(m); int k, tot, top; while (m--) &#123; tot = top = 0; read(k); for (int i = 1; i &lt;= k; ++i) read(a[++tot]), vis[a[tot]] = true, f[a[tot]] = mn[a[tot]]; sort(a+1, a+k+1, cmp); for (int i = 1, lca; i &lt; k; ++i)&#123; lca = LCA(a[i], a[i+1]); if (!vis[lca]) a[++tot] = lca, vis[lca] = true; &#125; if (!vis[1]) a[++tot] = 1; k = tot; for (int i = 1; i &lt;= k; ++i) a[++tot] = -a[i]; sort(a+1, a+tot+1, cmp); for (int i = 1, u; i &lt;= tot; ++i) &#123; if (a[i] &gt; 0) stk[++top] = a[i]; else &#123; u = stk[top--]; if (u != 1) f[stk[top]] += min(f[u], (LL)mn[u]); else print(f[u]); f[u] = vis[u] = 0; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://true-banana.github.io/tags/LCA/"},{"name":"虚树","slug":"虚树","permalink":"http://true-banana.github.io/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"题解 P3233 [HNOI2014]世界树","slug":"题解 P3233 HNOI2014世界树","date":"2020-04-06T00:30:00.000Z","updated":"2020-04-06T00:35:02.473Z","comments":true,"path":"2020/04/06/题解 P3233 HNOI2014世界树/","link":"","permalink":"http://true-banana.github.io/2020/04/06/%E9%A2%98%E8%A7%A3%20P3233%20HNOI2014%E4%B8%96%E7%95%8C%E6%A0%91/","excerpt":"","text":"题目 给一棵树，每条边距离为1，q 次询问，每次选择 k 个关键点，树上每个点由距离最近的关键的管辖（距离相同选择编号最小的），求每个关键的管辖点数 $N,q\\le3\\times10^5,\\sum_{i=1}^q{k_i}\\le3\\times10^5$ 思路树形dp，看数据范围，需要建虚树来优化 考虑每次把关键点建出虚树 dp求出每个点 u 的 $belong_u$（管辖 u 的关键点），$dis_u$ （u 到 $belong_u$ 的距离） 类似最短路的松弛，注意第一遍dp统计儿子对父亲的贡献，第二遍统计父亲对儿子的贡献 12if (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v])) dis[u] = dis[v] + E[i].val, bl[u] = bl[v]; 第三遍dp统计答案，设 $f_u$ 表示原树中经过 u 增加 $belong_u$ 贡献的点数 在虚树上有两种情况： 以 u 为根的原树的子树中没有关键点，那么这棵子树都由 u 或 $belong_u$ 管辖 虚树上连接 u 和 v 的边（u 为 v 的父亲），代表原树中的一条链，又分两种情况： $belong_u=belong_v$，这一条链除了 v 点其它都是 u 的贡献（v 点及其子树为 v 的贡献） $belong_u\\not=belong_v$，这条链被分成两部分，通过倍增找出分界点，划分 u,v 贡献 把 u 贡献加到 $belong_u$ 的答案上即可 细节这题一堆全局变量数组（命名冲突好麻烦），比大数据结构难调 关于链上找分界点（属于 v 范围的最高点）： 先求出 $belong_u$ 和 $belong_v$ 的距离 d，deep[v] - (d / 2 - dis[v]) 即中间点的 deep 如果 u，v 中间有奇数个点，必定有一个点 x 到两个关键点的距离相等，要让 d - 1，倍增后中间点为 x 的儿子（对 d 为偶数没有影响），看两个关键点编号大小选择是否往上走 12345int d = deep[v] - deep[u] + dis[u] + dis[v] - 1, tmp = d / 2 - dis[v], mid = v;for (int j = 19; ~j; --j) if (deep[fa[mid][j]] &gt;= deep[v] - tmp) mid = fa[mid][j];if ((d &amp; 1) &amp;&amp; tmp &gt;= 0 &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][0];// tmp 可能为负 另外多测要清空 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123;&#125;template&lt;typename TT&gt; inline void print(TT x, char end = '\\n') &#123;&#125;const int N = 3e5 + 9;const int INF = 0x3f3f3f3f;struct Edge &#123; int nxt, to, val;&#125;;int n, cnt_e, Q, k, dfu, tot, top;int head[N], Head[N], pu[N], po[N];int deep[N], fa[N][20], size[N], a[N], t[N&lt;&lt;1], stk[N];int dis[N], bl[N], f[N], ans[N];Edge e[N&lt;&lt;1], E[N&lt;&lt;1];bool is[N];inline void add_edge(int u, int v, int w) &#123; e[++cnt_e] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt_e;&#125;inline void Add_edge(int u, int v, int w) &#123; E[++cnt_e] = (Edge)&#123;Head[u], v, w&#125;, Head[u] = cnt_e;&#125;void dfs(int u, int last) &#123; pu[u] = ++dfu; deep[u] = deep[last] + 1; fa[u][0] = last; size[u] = 1; for (int i = 1; 1 &lt;&lt; i &lt;= deep[u]; ++i) fa[u][i] = fa[fa[u][i-1]][i-1]; for (int i = head[u], v; i; i = e[i].nxt) if ((v = e[i].to) != last) dfs(v, u), size[u] += size[v]; po[u] = ++dfu;&#125;int LCA(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); for (int i = 19; ~i; --i) if (deep[fa[x][i]] &gt;= deep[y]) x = fa[x][i]; for (int i = 19; ~i; --i) if (fa[x][i] != fa[y][i]) x = fa[x][i], y = fa[y][i]; return x == y ? x : fa[x][0];&#125;inline bool cmp(int x, int y) &#123; return (x &gt; 0 ? pu[x] : po[-x]) &lt; (y &gt; 0 ? pu[y] : po[-y]);&#125;inline void build_tree(int kk) &#123; static bool vis[N]; tot = top = cnt_e = 0; for (int i = 1; i &lt;= kk; ++i) t[++tot] = a[i], vis[t[tot]] = true; sort(t+1, t+tot+1, cmp); for (int i = 1, lca; i &lt; kk; ++i) &#123; lca = LCA(t[i], t[i+1]); if (!vis[lca]) t[++tot] = lca, vis[lca] = true; &#125; if (!vis[1]) t[++tot] = 1; kk = tot; for (int i = 1; i &lt;= kk; ++i) t[++tot] = -t[i]; sort(t+1, t+tot+1, cmp); for (int i = 1, u, v; i &lt;= tot; ++i) &#123; if (t[i] &gt; 0) stk[++top] = t[i]; else &#123; v = stk[top--], u = stk[top]; Add_edge(u, v, deep[v] - deep[u]), Add_edge(v, u, deep[v] - deep[u]); vis[v] = false; &#125; &#125;&#125;void dp1(int u, int last) &#123; if (is[u]) dis[u] = 0, bl[u] = u; else dis[u] = INF; for (int i = Head[u], v; i; i = E[i].nxt) if ((v = E[i].to) != last) &#123; dp1(v, u); if (dis[u] &gt; dis[v] + E[i].val || (dis[u] == dis[v] + E[i].val &amp;&amp; bl[u] &gt; bl[v])) dis[u] = dis[v] + E[i].val, bl[u] = bl[v]; &#125;&#125;// 我把第二三遍dp合在一块了void dp2(int u, int last) &#123; f[u] = size[u];// 初值为子树size for (int i = Head[u], v; i; i = E[i].nxt) if ((v = E[i].to) != last) &#123; if (dis[v] &gt; dis[u] + E[i].val || (dis[v] == dis[u] + E[i].val &amp;&amp; bl[v] &gt; bl[u])) dis[v] = dis[u] + E[i].val, bl[v] = bl[u]; dp2(v, u); if (bl[u] == bl[v]) f[u] -= size[v]; else &#123; int d = deep[v] - deep[u] + dis[u] + dis[v] - 1, tmp = d / 2 - dis[v], mid = v; for (int j = 19; ~j; --j) if (deep[fa[mid][j]] &gt;= deep[v] - tmp) mid = fa[mid][j]; if ((d &amp; 1) &amp;&amp; tmp &gt;= 0 &amp;&amp; bl[u] &gt; bl[v]) mid = fa[mid][0];// tmp可能为负数 f[u] -= size[mid]; f[v] += size[mid] - size[v]; &#125; ans[bl[v]] += f[v]; &#125; if (u == 1) ans[bl[1]] += f[1];// 别落下根节点&#125;inline void main() &#123; read(n); for (int i = 1, u, v; i &lt; n; ++i) read(u), read(v), add_edge(u, v, 0), add_edge(v, u, 0); dfs(1, 0); read(Q); while (Q--) &#123; read(k); for (int i = 1; i &lt;= k; ++i) read(a[i]), is[a[i]] = true; build_tree(k); dp1(1, 0), dp2(1, 0); for (int i = 1; i &lt;= k; ++i) print(ans[a[i]], ' '), is[a[i]] = ans[a[i]] = 0; puts(\"\"); // 清空，用memset会TLE for (int i = 1; i &lt;= tot; ++i) if (t[i] &gt; 0) Head[t[i]] = dis[t[i]] = bl[t[i]] = 0; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://true-banana.github.io/tags/LCA/"},{"name":"树形DP","slug":"树形DP","permalink":"http://true-banana.github.io/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"虚树","slug":"虚树","permalink":"http://true-banana.github.io/tags/%E8%99%9A%E6%A0%91/"}]},{"title":"题解 P2014 [CTSC1997]选课","slug":"2020-04-04-题解-P2014-CTSC1997选课","date":"2020-04-04T13:52:00.000Z","updated":"2020-04-04T14:17:41.222Z","comments":true,"path":"2020/04/04/2020-04-04-题解-P2014-CTSC1997选课/","link":"","permalink":"http://true-banana.github.io/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P2014-CTSC1997%E9%80%89%E8%AF%BE/","excerpt":"","text":"题目 给一棵 n 个点的树，每个点有权值，选择一个点必须同时选择其父节点 求选 m 个点的最大权值和 思路树上背包问题 选择 m 个点使其总价值最大，典型的背包问题 先设 $f_{i,j}$，表示以 i 为根的子树中选择 j 个能够得到最大价值 再考虑树形dp的模型，要求一棵树的答案能够由其子树得到 把节点 u 看作背包枚举空间 j，把每个儿子 v 看做物品，枚举选择个数（重量）k，物品价值为 $f_{v,k}$ 转移方程： \\large f_{u,j}=f_{u,j-k}+f_{v,k}注意是01背包，j 要倒序枚举 如何保证选择一个点的同时选择其父节点？ 赋初值 $f_{u,1}=val_u$，手动模拟一下dp过程就懂了 code12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123;&#125;const int N = 309;struct Edge &#123; int nxt, to;&#125;;int n, m, cnt_e;int head[N], val[N], f[N][N];Edge e[N];inline void add_edge(int u, int v) &#123; e[++cnt_e] = (Edge)&#123;head[u], v&#125;, head[u] = cnt_e; &#125;void dp(int u) &#123; f[u][1] = val[u]; for (int i = head[u], v; i; i = e[i].nxt) &#123; v = e[i].to; dp(v); for (int j = m + 1; j; --j) for (int k = 0; k &lt; j; ++k) f[u][j] = max(f[u][j], f[u][j-k] + f[v][k]); &#125;&#125;int main() &#123; read(n), read(m); for (int i = 1, u; i &lt;= n; ++i) read(u), add_edge(u, i), read(val[i]); dp(0); printf(\"%d\\n\", f[0][m+1]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://true-banana.github.io/tags/%E6%A0%91%E5%BD%A2DP/"},{"name":"背包DP","slug":"背包DP","permalink":"http://true-banana.github.io/tags/%E8%83%8C%E5%8C%85DP/"}]},{"title":"题解 P5664 Emiya 家今天的饭","slug":"2020-04-04-题解-P5664-Emiya-家今天的饭","date":"2020-04-04T02:50:00.000Z","updated":"2020-04-04T03:44:41.663Z","comments":true,"path":"2020/04/04/2020-04-04-题解-P5664-Emiya-家今天的饭/","link":"","permalink":"http://true-banana.github.io/2020/04/04/2020-04-04-%E9%A2%98%E8%A7%A3-P5664-Emiya-%E5%AE%B6%E4%BB%8A%E5%A4%A9%E7%9A%84%E9%A5%AD/","excerpt":"","text":"题目 n 种烹饪方法，有 m 种食材，第 i 个方法的第 j 种食材有 $a_{i,j}$ 个 要求： 至少要做一道菜 一种方法最多做一道菜 做 k 道菜，每种食材使用次数不超过 $\\lfloor\\frac{k}{2}\\rfloor$ 次 求总方案数（$\\mod{998244353}$） 思路明显的计数DP 第三个限制很讨厌，先不管它 我们可以用总方案数减去不合法的方案 因为题目背景让我叙述不方便，建议把“方法”和“食材”想象成行和列 总方案数无视第三个条件时，只要考虑每个方法选或不选 设 $s_i$ 表示第 i 种方法的食材个数和，即 $\\sum_{k=1}^m{a_{i,k}}$ 设 $g_{i,j}$ 表示前 i 种方法选了 j 种的方案数 \\large g_{i,j}=g_{i-1,j}+g_{i-1,j-1}\\times s_i此时总方案数为 \\sum_{i=1}^n{g_{n,i}}复杂度 $O(n^2)$ 不合格方案数某种食材选择的个数超过的总菜数的一半即为不合格 因为最多只有一种食材的个数会超过一半 只要对于每一种食材 i，考虑第 i 种食材的个数与其它食材的个数关系 设 $f_{j,x,y}$ 表示前 j 种方法，食材 i 选了 x 个，其它选了 y 个 \\large f_{j,x,y}=f_{j-1,x,y}+f_{j-1,x-1,y}\\times a_{j,i}+f_{j-1,x,y-1}\\times(s_j-a_{j,i})每种食材dp一遍，复杂度 $O(mn^3)$，需要降维 又碰上这种套路：我们不需要知道 x，y 的具体数值，只需要知道他们的关系 设 $f_{j,k}$ 表示前 j 种方法，食材 i 选的个数比其它的多 k 个 \\large f_{j,k}=f_{j-1,k}+f_{j-1,k-1}\\times a_{j,i}+f_{j-1,k+1}\\times(s_j-a_{j,i})这样复杂度就是 $O(mn^2)$ 了 总共不合法方案数为 \\sum_{i=1}^n{f_{n,i}}细节DP $f_{j,k}$ 时，k 的范围为 -j ~ j，可能为负数，需要数组下标整体偏移 n，数组也要开 2n 倍 转移时 g[i][j] = (g[i-1][j] + sum[i][0] * g[i-1][j-1]) % MOD; 这么写爆 long long 要每个乘法前强制转 long long，或者直接全开 long long code1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;cstring&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123;&#125;typedef long long LL;const int N = 109;const int M = 2009;const int MOD = 998244353;int n, m;LL ans;LL a[N][M], sum[N][M], f[N][N&lt;&lt;1], g[N][N];inline void main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) read(a[i][j]), sum[i][0] = (sum[i][0] + a[i][j]) % MOD; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) sum[i][j] = (sum[i][0] - a[i][j] + MOD) % MOD; g[0][0] = 1; for (int i = 1; i &lt;= n; ++i) &#123; g[i][0] = 1; for (int j = 1; j &lt;= n; ++j) g[i][j] = (g[i-1][j] + sum[i][0] * g[i-1][j-1]) % MOD; &#125; for (int i = 1; i &lt;= m; ++i) &#123; memset(f, 0, sizeof f); f[0][n] = 1; for (int j = 1; j &lt;= n; ++j) for (int k = n - j; k &lt;= n + j; ++k) f[j][k] = (f[j-1][k] + a[j][i] * f[j-1][k-1] + sum[j][i] * f[j-1][k+1]) % MOD; for (int j = 1; j &lt;= n; ++j) ans = (ans + MOD - f[n][n+j]) % MOD; &#125; for (int i = 1; i &lt;= n; ++i) ans = (ans + g[n][i]) % MOD; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"递推DP","slug":"递推DP","permalink":"http://true-banana.github.io/tags/%E9%80%92%E6%8E%A8DP/"},{"name":"容斥","slug":"容斥","permalink":"http://true-banana.github.io/tags/%E5%AE%B9%E6%96%A5/"}]},{"title":"题解 P1966 火柴排队","slug":"2020-02-14-题解-P1966-火柴排队","date":"2020-02-14T09:30:00.000Z","updated":"2020-02-14T10:05:12.592Z","comments":true,"path":"2020/02/14/2020-02-14-题解-P1966-火柴排队/","link":"","permalink":"http://true-banana.github.io/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P1966-%E7%81%AB%E6%9F%B4%E6%8E%92%E9%98%9F/","excerpt":"","text":"题面 两个数列 $a,b$，求最少相邻两数交换多少次使得 $\\sum_{i=1}^n{(a_i-b_i)^2}$ 最小 思路先来简单地变换一下式子（见到这种狗式子一定要拆）： \\sum{(a_i-b_i)^2}=\\sum(a_i^2+b_i^2-2a_ib_i)$\\sum(a_i^2+b_i^2)$ 是不变的，所以要最大化 $\\sum{a_ib_i}$ 所以要让 $a,b$ 中排名第 k 的两个数在同一位置上 为啥？一点也不严谨的口胡证明： 假设有四个数 $x_1,x_2,y_1,y_2$，且 $x_1&lt;x_2,y_1&lt;y_2$ 那么 $x_1y_1+x_2y_2&gt;x_1y_2+x_2y_1$，这很显然吧 也就是说 $a,b$ 中最大两数乘积、次大两数乘积……的和是最大的 然后怎么做？ 让排名为 k 的 $a_i,b_j$ 两数在同一位置上，就是让 $b_j$ 到位置 $i$ 上 令 $b_j=i$，再将 $b$ 数组排序，$b_j$ 自然到位置 $i$ 上了 是相邻两数交换来排序的话，最少次数就是此时 $b$ 的逆序对数（挺好证吧） 直接上树状数组或者归并 code出题人还算良心，同一数列中两两各不相同，少了许多细节 评测记录 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123;/* fast read */&#125;const int N = 1e5 + 9;const int MOD = 99999997;int n, ans;int a[N], b[N], tmp[N];// 离散化inline void lsh(int *t) &#123; for (int i = 1; i &lt;= n; ++i) tmp[i] = t[i]; sort(tmp+1, tmp+n+1); int tot = unique(tmp+1, tmp+n+1) - tmp; for (int i = 1; i &lt;= n; ++i) t[i] = lower_bound(tmp+1, tmp+tot+1, t[i]) - tmp;&#125;// 树状数组，用于求逆序对struct Bit_Tree &#123; int tr[N]; #define lowbit(x) (x &amp; -x) inline void add(int x, int k) &#123; while (x &lt;= n) tr[x] += k, x += lowbit(x); &#125; inline int query(int x) &#123; int re = 0; while (x) re += tr[x], x -= lowbit(x); return re; &#125;&#125; tr;inline void main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); for (int i = 1; i &lt;= n; ++i) read(b[i]); // 离散化，同时也是得到每个数的排名 lsh(a), lsh(b); // 让 b 数列每个元素得到 a 中同一排名元素的坐标 for (int i = 1; i &lt;= n; ++i) tmp[a[i]] = i; for (int i = 1; i &lt;= n; ++i) b[i] = tmp[b[i]]; // 统计答案 for (int i = 1; i &lt;= n; ++i) &#123; // 每次加入一个数增加逆序对数：原个数 - 小于它的元素个数 ans = (ans + i - 1 - tr.query(b[i])) % MOD; tr.add(b[i], 1); &#125; printf(\"%d\\n\", ans);&#125;","categories":[{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://true-banana.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"}]},{"title":"题解 P2831 愤怒的小鸟","slug":"2020-02-14-题解-P2831-愤怒的小鸟","date":"2020-02-14T05:48:18.000Z","updated":"2020-02-14T07:20:31.041Z","comments":true,"path":"2020/02/14/2020-02-14-题解-P2831-愤怒的小鸟/","link":"","permalink":"http://true-banana.github.io/2020/02/14/2020-02-14-%E9%A2%98%E8%A7%A3-P2831-%E6%84%A4%E6%80%92%E7%9A%84%E5%B0%8F%E9%B8%9F/","excerpt":"","text":"题面 在坐标系第一象限有一些点，用一些经过原点、开口向下的抛物线 $y=ax^2+bx$ 覆盖所有点，最少需要多少条 思路注意到 $n\\le 18$，基本上是状压 DP 初始做法考虑压缩点的覆盖状态，设 $f[S]$ 表示集合 $S$ 被覆盖需要最少的抛物线数 每两个点确定一条抛物线（经过原点），预处理每条抛物线 $line_{i,j}$ 能覆盖的点集合 不难得出转移方程： f[S\\cup line_{i,j}]=f[S]+1\\\\ f[S\\cup i]=f[S]+1那么 $O(2^n)$ 枚举集合状态，再每个状态 $O(n^2)$ 枚举抛物线转移，复杂度 $O(Tn^2 2^n)$ 估算一下，计算量在 4e8 级别，不一定过 优化在每个状态 $S$，转移后至少覆盖一个点 从 i 出发枚举抛物线转移和从 j 出发枚举的顺序先后没有关系 先覆盖 i，和覆盖 j 后再覆盖 i，是一样的（如果 j 出发的抛物线能覆盖 i，从 i 出发也一定能覆盖 j） 于是每个状态我只从一个点出发枚举抛物线，复杂度降到 $O(Tn2^n)$，稳过 要预处理每个状态最小的未覆盖的点是哪个 提示从两个点的坐标 $(x_1,y_1),(x_2,y_2)$ 算出抛物线参数 $a,b$，要推一下公式： 解 $a$： \\begin{cases} y_1=ax_1^2+bx_1\\\\ y_2=ax_2^2+bx_2 \\end{cases}\\\\ \\begin{cases} \\frac{y_1}{x_1}=ax_1+b\\\\ \\frac{y_2}{x_2}=ax_2+b \\end{cases}\\\\ a(x_1-x_2)=\\frac{y_1}{x_1}-\\frac{y_2}{x_2}\\\\ a=\\frac{x_2y_1-x_1y_2}{x_1x_2(x_1-x_2)}解 $b$： \\begin{cases} y_1=ax_1^2+bx_1\\\\ y_2=ax_2^2+bx_2 \\end{cases}\\\\ \\begin{cases} \\frac{y_1}{x_1^2}=a+\\frac{b}{x_1}\\\\ \\frac{y_2}{x_2^2}=a+\\frac{b}{x_2} \\end{cases}\\\\ b(\\frac{1}{x_1}-\\frac{1}{x_2})=\\frac{y_1}{x_1^2}-\\frac{y_2}{x_2^2}\\\\ b=\\frac{x_1^2y_2-x_2^2y_1}{x_1x_2(x_1-x_2)}code提交记录 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cmath&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123;/* fast read */&#125;const int N = 20;const int MAXN = (1 &lt;&lt; 18) - 1;const int INF = 0x3f3f3f3f;const double eps = 1e-8;// 封装了抛物线，便于比较struct Line &#123; double a, b; bool operator ==(Line &amp;t) &#123; return fabs(a - t.a) &lt;= eps &amp;&amp; fabs(b - t.b) &lt;= eps; &#125;&#125;;int T, n, m, maxn;int low[MAXN], line[N][N], f[MAXN];double x[N], y[N];// 由推导的公式算抛物线inline Line get_line(int a, int b) &#123; return (Line)&#123; (x[b] * y[a] - x[a] * y[b]) / (x[a] * x[b] * (x[a] - x[b])), (x[a] * x[a] * y[b] - x[b] * x[b] * y[a]) / (x[a] * x[b] * (x[a] - x[b])) &#125;;&#125;int main() &#123; // 预处理最小未覆盖的点 for (int i = 0; i &lt;= MAXN; ++i) for (int j = 0; j &lt; N; ++j) if ((i &amp; (1 &lt;&lt; j)) == 0) &#123; low[i] = j + 1; break; &#125; read(T); while (T--) &#123; read(n), read(m); maxn = (1 &lt;&lt; n) - 1; for (int i = 1; i &lt;= n; ++i) scanf(\"%lf%lf\", &amp;x[i], &amp;y[i]); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) &#123; line[i][j] = 0;// 多测清空 if (fabs(x[i] - x[j]) &gt;= eps) &#123;// 横坐标相同则无解 Line t = get_line(i, j); if (t.a &gt; -eps) continue;// 解出来开口向上不算 line[i][j] |= (1 &lt;&lt; (i - 1)) | (1 &lt;&lt; (j - 1)); // 寻找在同一抛物线上的点 for (int k = 1; k &lt;= n; ++k) if (k != i &amp;&amp; k != j &amp;&amp; get_line(i, k) == t) line[i][j] |= 1 &lt;&lt; (k - 1); &#125; &#125; for (int i = 0; i &lt;= maxn; ++i) f[i] = INF;// 清空qwq f[0] = 0; for (int i = 0; i &lt; maxn; ++i) &#123; int x = low[i], j = 1 &lt;&lt; (x - 1); if (x &gt; n) continue; f[i|j] = min(f[i|j], f[i] + 1); // 只覆盖一个点 for (int y = 1; y &lt;= n; ++y) f[i|line[x][y]] = min(f[i|line[x][y]], f[i] + 1); // 通过抛物线转移 &#125; printf(\"%d\\n\", f[maxn]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://true-banana.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"板子 SA","slug":"2020-02-13-板子-SA","date":"2020-02-13T14:48:18.000Z","updated":"2020-02-13T14:28:49.735Z","comments":true,"path":"2020/02/13/2020-02-13-板子-SA/","link":"","permalink":"http://true-banana.github.io/2020/02/13/2020-02-13-%E6%9D%BF%E5%AD%90-SA/","excerpt":"","text":"先贴个板子，总结有时间在再说 基数排序$O(n)$ 的排序是不是很诱人，桶排改进而已 12345678910inline void qsort() &#123; for (int i = 1; i &lt;= m; ++i) tax[i] = 0; for (int i = 1; i &lt;= n; ++i) ++tax[rnk[i]]; for (int i = 1; i &lt;= m; ++i) tax[i] += tax[i-1]; for (int i = n; i; --i) sa[tax[rnk[tp[i]]]--] = tp[i];&#125; 后缀排序123456789101112131415161718inline void get_SA() &#123; for (int i = 1; i &lt;= n; ++i) rnk[i] = s[i], tp[i] = i; m = 127, qsort(); for (int w = 1, p = 0; w &lt;= n &amp;&amp; p &lt; n; m = p, w &lt;&lt;= 1) &#123; p = 0; for (int i = n - w + 1; i &lt;= n; ++i) tp[++p] = i; for (int i = 1; i &lt;= n; ++i) if (sa[i] &gt; w) tp[++p] = sa[i] - w; qsort(); swap(rnk, tp); rnk[sa[1]] = p = 1; for (int i = 2; i &lt;= n; ++i) rnk[sa[i]] = (tp[sa[i]] == tp[sa[i-1]] &amp;&amp; tp[sa[i]+w] == tp[sa[i-1]+w]) ? p : ++p; &#125;&#125; 求 height 数组12345678inline void get_height() &#123; for (int i = 1, k = 0, j; i &lt;= n; ++i) &#123; k = max(0, k - 1), j = sa[rnk[i]-1]; while (s[i+k] == s[j+k]) k++; ht[rnk[i]] = k; &#125;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"字符串","slug":"字符串","permalink":"http://true-banana.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SA","slug":"SA","permalink":"http://true-banana.github.io/tags/SA/"}]},{"title":"总结 SAM","slug":"2020-02-13-总结-SAM","date":"2020-02-13T10:48:18.000Z","updated":"2020-02-13T14:22:53.084Z","comments":true,"path":"2020/02/13/2020-02-13-总结-SAM/","link":"","permalink":"http://true-banana.github.io/2020/02/13/2020-02-13-%E6%80%BB%E7%BB%93-SAM/","excerpt":"","text":"$SAM: Suffix Automaton$ ，后缀自动机 难理解，但代码好写（当初敲完模板题没总结，现在忘光了QAQ） 总体上是 后缀 trie + parent tree ，构成一个可以表示所有子串的 DAG 福利：后缀自动机可视化 推荐博客： KesdiaelKen 的博客（我就是看这博客学会的） shadowice1984 的博客 xzyxzy 的博客 这博客主要是我总结自己不好理解的地方，不是很全面 声明：本文中图片大部分为 BANANA 从他人博客盗来的借鉴的，一些语言表达借鉴于 KesdiaelKen 的博客 ，若有侵权请 联系BANANA 删除 思路前置先了解几个概念： 后缀 trie ：把字符串的每一个后缀插入到 trie 树里 一个普通的后缀 trie ，有很大部分节点是可以压缩的 endpos 集合 ：一个子串在原串出现的位置（可能出现多次）的右端点集合 比如一个串“banana” $endpos(b)=\\{1\\}, endpos(a)=\\{2,4,6\\}$ $endpos(an)=\\{3,5\\}, endpos(ana)=\\{4,6\\}$ parent tree ：一个子串前面添加一个或几个字符，可以将他的 endpos 集合分割，endpos 集合之间便有了父子关系 parent tree 上每一个节点表示的 endpos 集合唯一地表示一个后缀集合 不好举例，自己手模吧 构造将后缀 trie 和 parent tree 结合起来便是 SAM 的 DAG 那么一条路径表示原串的一个子串，一个节点 x 表示根节点到 x 路径形成的所有串的 endpos 集合 SAM 常见的增量构造：将字符串从前到后一个一个字符插进去（离线构造窝不会） 先确定一些量： $fa[x]$ ：x 节点表示的集合在 parent tree 上的父亲 $len[x]$ ：x 节点表示的集合中最长的串的长度 如果设最短的串长为 $minlen[x]$ ，那么 $len[fa[x]]+1=minlen[x]$ ，即 parent tree 上的分割关系 我们考虑从后面插入一个字符 c，会有什么变化： 多出新串的后缀 新串后缀的 endpos 集合改变 那么在 trie 的意义上要把旧串所有后缀的后面加上字符 c 在 SAM 上实现就是先新建节点 np 然后把最后一个节点 p、它在 parent tree 的父亲以及祖先的 c 儿子设为该节点（相当于压缩地遍历旧串的所有后缀） 并且 $len[np]=len[p]+1$ 1234int p = last, np = last = ++cnt;len[np] = len[p] + 1;while (p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p]; 如果这些祖先都没有 c 儿子，到达最高的祖先就是根节点 说明字符 c 是一个新字符，parent tree 上根节点多一个儿子：只有位置 c 的 endpos 集合 1if (!p) fa[np] = 1; 那么如果有一个祖先 p 已经有了 c 儿子，设它为 q 说明旧串有子串的结尾是 c 字符，那么就要看这个 q 的 len 了 $len[q]=len[p]+1$ 说明 q 在插入时 p 就是最后一个节点了 那么根到 q 点表示的子串都是根到 np 表示的子串的后缀 在 parent tree 上，q 是 np 的父亲 $len[q]&gt;len[p]+1$ 在 parent tree 上，q 和 np 是兄弟 那么就新建一个 nq （复制一份 q ）作为它俩的父亲 将之前 p 及其祖先指向 q 的 c 儿子全指向 nq 即可 1234567891011int q = ch[p][c];if (len[q] == len[p] + 1) fa[np] = q;else &#123; int nq = ++cnt; memcpy(ch[nq], ch[q], sizeof ch[q]); len[nq] = len[p] + 1; fa[nq] = fa[q], fa[q] = fa[np] = nq; while (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p];&#125; code完整构造代码，看起来一堆 while 却是$O(n)$ 注意点数是 2n 规模 123456789101112131415161718192021222324252627struct Suffix_Automaton &#123; int cnt, last; int fa[N&lt;&lt;1], ch[N&lt;&lt;1][30], len[N&lt;&lt;1]; inline Suffix_Automaton() &#123; last = cnt = 1; &#125; inline void add(int c) &#123; int p = last, np = last = ++cnt; len[np] = len[p] + 1; while (p &amp;&amp; !ch[p][c]) ch[p][c] = np, p = fa[p]; if (!p) fa[np] = 1; else &#123; int q = ch[p][c]; if (len[q] == len[p] + 1) fa[np] = q; else &#123; int nq = ++cnt; memcpy(ch[nq], ch[q], sizeof ch[q]); len[nq] = len[p] + 1; fa[nq] = fa[q], fa[q] = fa[np] = nq; while (p &amp;&amp; ch[p][c] == q) ch[p][c] = nq, p = fa[p]; &#125; &#125; &#125;&#125; SAM; 应用 判断子串 直接在 SAM 上跑，跑完没到 NULL 即为子串 求不同子串个数 设 $f[i]$ 为从 i 点出发的子串， $f[i]=\\sum_{(i,j)\\in Edge}{f[j]+1}$ 好像还可以直接求 $\\sum{(len[i]-len[fa[i]])}$ ，因为 SAM上无重复子串 待更~ 题目BANANA 由于过菜，还不会写几道题~ P3804 【模板】后缀自动机 (SAM) 求出 S 的所有出现次数不为 1 的子串的出现次数乘上该子串长度的最大值 一个子串的出现次数即在 parent tree 上该子树的 size 暴力建出 parent tree，或者拓扑一下 DAG ，统计 P4070 [SDOI2016]生成魔咒 每次向后插入一个字符，并求每次操作后不同子串个数 显然 SAM 应用在求不同子串个数 $\\sum{(len[i]-len[fa[i]])}$ 每次只增加一个 len 影响总个数的节点，ans += len[x] - len[fa[x]]，于是每次 $O(1)$ 统计答案 大坑：“字符”范围 1e9 ，每个节点要用 map 存儿子 待更~","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"字符串","slug":"字符串","permalink":"http://true-banana.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"SAM","slug":"SAM","permalink":"http://true-banana.github.io/tags/SAM/"}]},{"title":"总结 OI中一些数学定理","slug":"2020-02-06-总结-OI中一些数学定理","date":"2020-02-06T13:48:18.000Z","updated":"2020-02-27T06:39:24.134Z","comments":true,"path":"2020/02/06/2020-02-06-总结-OI中一些数学定理/","link":"","permalink":"http://true-banana.github.io/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-OI%E4%B8%AD%E4%B8%80%E4%BA%9B%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86/","excerpt":"","text":"Matrix Tree 定理定义一个图 $G$ 的 $Kirchhoff$ 矩阵 $C=\\text{度数矩阵}-\\text{邻接矩阵}$ C_{i,j}= \\begin{cases} degree_i& (i=j)\\\\ -1& (i\\not=j\\ and\\ (i,j)\\in G(E))\\\\ 0& (i\\not=j\\ and\\ (i,j)\\notin G(E)) \\end{cases}将矩阵 $C$ 去掉任意一行和一列，该矩阵的行列式即图 $G$ 的 生成树个数 概率相关$P(A)$ ： $A$ 事件发生的概率 $E(X)$：随机变量 $X$ 的期望值，$E(X)=\\sum P(X=i)\\times i$ $P(A|B)$：$A$ 在 $B$ 发生的条件下发生的概率，$P(A|B)=\\frac{P(AB)}{P(B)}$ 全概率公式：$P(B)=\\sum_{i=1}^n{P(A_i)P(B|A_i)}$ 贝叶斯公式：$P(A_i|B)=\\frac{P(B|A_i)P(A_i)}{\\sum_{j=1}^n{P(B|A_j)P(A_j)}}$ （不会，不知道有没有用） 期望的性质： $E(X+Y)=E(X)+E(Y)$ $E(aX+b)=aE(X)+b$ $E(XY)=E(X)+E(Y)$ （ $x,y$ 相互独立） 辛普森积分 \\frac{b-a}{6}[f(a)+4f(\\frac{a+b}{2})+f(b)]自适应辛普森，分成左右分别套辛普森法则，不断拟合： 1234567891011inline double simpson(double l, double r) &#123; double mid = (l + r) / 2; return (f(l) + 4 * f(mid) + f(r)) * (r - l) / 6;&#125;double solve(double l, double r, double last, double eps) &#123; double mid = (l + r) / 2; double ln = simpson(l, mid), rn = simpson(mid, r); if (abs(ln + rn - last) &lt;= eps) return ln + rn + (ln + rn - last); return solve(l, mid, ln, eps/2) + solve(mid, r, rn, eps/2);&#125; 模性质模意义下加、减、乘随便做，除要转换成逆元 $a\\equiv b\\pmod p\\nRightarrow \\frac{a}{2}\\equiv \\frac{b}{2}\\pmod p$ 裴蜀定理对于不定方程：$ax+by=c$ 有（整数）解的充要条件为 $\\gcd⁡(a,b) | c$ 即一定存在 $x,y$ 满足 $ax+by=\\gcd(a,b)$ 推论：$a,b$ 互素等价于 $ax+by=1$ 有解 欧几里得算法gcd \\gcd(a,b)=\\gcd(a-b,b)1234567891011// 递归int gcd(int a, int b) &#123; return b ? gcd(b, a % b) : a;&#125;// 非递归int gcd(int a, int b) &#123; int t; while (b) t = a, a = b, b = t % a; return a;&#125; exgcd ax+by=\\gcd(a,b)\\\\ bx'+(a\\%b)y'=\\gcd(b,a\\%b)将 $a mod b$ 替换为 $a-\\lfloor\\frac{a}{b}\\rfloor b$ ，得 \\begin{align} bx'+(a\\%b)y'&=bx'+(a-\\lfloor\\frac{a}{b}\\rfloor b)y'\\\\ &=ay'+b(x'-\\lfloor\\frac{a}{b}\\rfloor y') \\end{align}则 $x,y$ 和 $x’,y’$ 的关系为 x=y',y=x'-\\lfloor\\frac{a}{b}\\rfloor y'当 $b=0$ 时，$x’=1$ ，$y$ 可以为任何值 12345678void exgcd(int a, int b, int &amp;x, int &amp;y, int &amp;gcd) &#123; if (!b) &#123; x = 1, y = 0, gcd = a; return; &#125; exgcd(b, a%b, y, x, gcd); y -= a / b * x;&#125; 整数唯一分解定理对于任意整数 $N (N\\ge2)$ \\large N=\\prod_{i=1}^k{p_i^{r_i}}\\quad (p_i\\text{为质数},r_i\\ge0)$N$ 的正约数集合：$\\large\\{\\prod_{i=1}^k{p_i^{b_i}}\\} (0\\le b_i\\le r_i)$ $N$ 的正约数个数：$\\large\\prod_{i=1}^k{(r_i+1)}$ $N$ 的正约数和：$\\large\\prod_{i=1}^k(\\sum_{j=0}^{r_i}p_i^j)$ 威尔逊定理$p$ 是质数的充要条件为: (p-1)!\\equiv -1\\pmod p费马小定理$p$ 为质数，且 $\\gcd(a,p)=1$ ，则： a^{p-1}\\equiv 1\\pmod p故 $a$ 在模 $p$ 下的乘法逆元为 $a^{p-2}$ 线性预处理逆元设 $p=i*k+r(0\\le r\\lt i)$ i*k+r\\equiv 0\\pmod p两边乘 $i^{-1}r^{-1}$ k*r^{-1}+i^{-1}\\equiv0\\pmod p\\\\ i^{-1}\\equiv -k*r^{-1}\\pmod p其中 $r=p\\%i,k=\\lfloor\\frac{p}{i}\\rfloor$ 123inv[0] = inv[1] = 1;for (int i = 1; i &lt;= n; ++i) inv[i] = (p - p / i) * inv[p%i] % p; 还有一种方法： 设 $s_i=\\prod_{j=1}^{i}a_i,invs_i=s_i^{-1}$ $O(\\log_2(mod))$ 预处理 $invs_n$ ，则 $invs_i=invs_{i+1}\\times a_{i+1}$ 12345678s[0] = 1;for (int i = 1; i &lt;= n; ++i) s[i] = s[i-1] * a[i] % p;invs[n] = power(s[n], p-2);for (int i = n - 1; i; --i) invs[i] = invs[i+1] * a[i+1] % p;for (int i = 1; i &lt;= n; ++i) inv[i] = invs[i] * s[i-1] % p; 欧拉函数 \\varphi(n)=\\sum_{i=1}^n[\\gcd(n, i)=1]若 $p$ 为素数，则 $\\varphi(p)=p-1$ 若 $\\gcd(a,b)=1$，则 $\\varphi(ab)=\\varphi(a)\\varphi(b)$ 基于素因数分解求 $\\varphi(n)$ ，复杂度 $O(\\sqrt{n})$ ： 12345678910111213int euler_phi(int n) &#123; int res = n; for (int i = 2; i * i &lt;= n; ++i) &#123; if (n % i == 0) &#123; res = res / i * (i - 1); while (n % i == 0) n /= i; &#125; &#125; if (n != 1) res = res / n * (n - 1); return res;&#125; 欧拉定理$a,p$ 为互质的正整数 a^{\\varphi(p)}\\equiv 1\\pmod p扩展欧拉定理若 $a,p$ 不一定互质，且 $x\\ge \\varphi(p)$ a^x\\equiv a^{x\\%\\varphi(p)+\\varphi(p)}\\pmod p中国剩余定理crt对于一元线性同余方程组： \\begin{cases} x\\equiv a_1\\pmod{m_1}\\\\ x\\equiv a_2\\pmod{m_2}\\\\ ……\\\\ x\\equiv a_n\\pmod{m_n} \\end{cases}其中 $m_i$ 两两互质 该方程组的通解为： M=\\prod_{i=1}^nm_i\\\\ M_i=\\frac{M}{m_i}\\\\ t_i=M_i^{-1}\\pmod{m_i}\\\\ x\\equiv \\sum_{i=1}^n{a_it_iM_i\\pmod M}excrt还不会，咕…… 拉格朗日插值对于一个给定 n 个点 $(x_i,y_i)$ 的多项式，可以 $O(n^2)$ 算出该多项式在 $x_k$ 的取值 f(x_k)=\\sum_{i=1}^n{y_i\\prod_{i\\not=j}\\frac{x_k-x_j}{x_i-x_j}}如果已知取值 $x_1$ 到 $x_n$ 是连续的话，可以预处理前缀积优化到 $O(n\\log n)$（逆元再线性处理就是 $O(n)$ ） 莫比乌斯函数 \\mu(n)= \\begin{cases} 1& (n=1)\\\\ (-1)^k& (n\\text{无平方数因数},n=\\prod_{i=1}^k{p_i})\\\\ 0& (n\\text{有大于1的平方数因数}) \\end{cases} \\sum_{d\\mid n}\\mu(d)= \\begin{cases} 1& (n=1)\\\\ 0& (n=0) \\end{cases}\\\\ \\sum_{d\\mid n}\\frac{\\mu(d)}{d}=\\frac{\\varphi(n)}{n}一些积性函数 $\\varphi(n)$：欧拉函数 $\\mu(n)$：莫比乌斯函数 $\\gcd(n,k)$：（$k$ 固定时）最小公因数 $d(n)$：$n$ 的约数个数 $\\sigma(n)$：$n$ 的约数和 $1(n)=1$ $id(n)=n$ $e(n)=\\begin{cases}1&amp;(n=1)\\\\0&amp;(n\\not=1)\\end{cases}$ 狄利克雷卷积 h=f\\times g\\\\ h(n)=\\sum_{i\\mid n}{f(i)*g(\\frac{n}{i})}两个数论函数的狄利克雷卷积结果仍是一个数论函数 两个积性函数的狄利克雷卷积仍是一个积性函数 狄利克雷卷积满足交换律、结合律 二项式定理Lucas定理 待补充……","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://true-banana.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"},{"name":"数论","slug":"数论","permalink":"http://true-banana.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"总结 BSGS","slug":"2020-02-06-总结-BSGS","date":"2020-02-06T10:48:18.000Z","updated":"2020-02-13T23:49:58.272Z","comments":true,"path":"2020/02/06/2020-02-06-总结-BSGS/","link":"","permalink":"http://true-banana.github.io/2020/02/06/2020-02-06-%E6%80%BB%E7%BB%93-BSGS/","excerpt":"","text":"B（拔）S（山）G（盖）S（世）没什么好总结的，就当水博客了 用途用于求这样的问题： 给出 $a, b, p$ a^x\\equiv b\\pmod p求 $x$ 的最小非负整数解 例题 Luogu P2485 思想先把 $x$ 拆分成 $i*t-j$ 的形式（$t=\\lceil\\sqrt{p}\\rceil$） a^{i*t-j}\\equiv b\\pmod p\\\\ a^{i*t}\\equiv b*a^j\\pmod p枚举 $j\\in [0,t]$ ，将 $b*a^j$ 放进哈希表（我这么懒肯定用 $map$ 水） 再枚举 $i\\in [0,t]$ ，从哈希表中查找 $a^{i\\ast t}$ ，找到即答案为 $i\\ast t-j$ 枚举 $i,j$ 都是 $O(\\sqrt{p})$ 的 是不是很 easy code这里只好放 P2485 的代码了 123456789101112131415161718192021222324map&lt;LL, LL&gt; m;inline LL BSGS(int a, int b, int p) &#123; m.clear(); b %= p; if (a % p == 0) &#123;// 恶心的特判 if (b == 0) return 1; else return -1; &#125; LL t = ceil(sqrt(p)); for (LL i = 0, bn = b; i &lt;= t; ++i) m[bn] = i, bn = bn * a % p; a = power(a, t); for (LL i = 0, an = 1, j; i &lt;= t; ++i) &#123; if (m.count(an)) &#123; j = m[an]; if (i * t - j &gt;= 0) return i * t - j; &#125; an = an * a % p; &#125; return -1;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"}],"tags":[{"name":"BSGS","slug":"BSGS","permalink":"http://true-banana.github.io/tags/BSGS/"}]},{"title":"板子 FWT","slug":"2020-01-29-板子-FWT","date":"2020-01-29T13:48:18.000Z","updated":"2020-02-07T05:24:05.524Z","comments":true,"path":"2020/01/29/2020-01-29-板子-FWT/","link":"","permalink":"http://true-banana.github.io/2020/01/29/2020-01-29-%E6%9D%BF%E5%AD%90-FWT/","excerpt":"","text":"快速沃尔什变换，用于处理 $C_k=\\sum_{i\\otimes j=k}A_i*B_j$ （$\\otimes$ 是集合运算符）几何卷积运算 对于 $A$ 求出 $fwt[A]$ ，使得 $fwt[C]=fwt[A]*fwt[B]$ ，于是就 $O(n)$ 了 我纯靠感性理解，更不会讲QAQ，这里只贴板子 几篇有帮助的博客： ACMLCZH的blog xht37的blog $or$ 或卷积$FWT$： fwt[a]=(fwt[a_0],\\ fwt[a_0]+fwt[a_1])$IFWT$： a=(a_0,\\ a_0-a_1)123456inline void FWT_or(int *f, int opt = 1) &#123; for (int mid = 1; mid &lt;&lt; 1 &lt;= n; mid &lt;&lt;= 1) for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) for (int j = 0; j &lt; mid; ++j) f[i+mid+j] = ((LL)f[i+j] * opt + f[i+mid+j] + MOD) % MOD;&#125; $and$ 与卷积非常相似呢，只管粘过来一改就好 $FWT$： fwt[a]=(fwt[a_0]+fwt[a_1],\\ fwt[a_1])$IFWT$： a=(a_0-a_1,\\ a_1)123456inline void FWT_and(int *f, int opt = 1) &#123; for (int mid = 1; mid &lt;&lt; 1 &lt;= n; mid &lt;&lt;= 1) for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) for (int j = 0; j &lt; mid; ++j) f[i+j] = ((LL)f[i+j] + f[i+mid+j] * opt + MOD) % MOD;&#125; $xor$ 异或卷积最恶心的 $FWT$： fwt[a]=(fwt[a_0]+fwt[a_1],\\ fwt[a_0]-fwt[a_1])$IFWT$： a=(\\frac{a_0+a_1}{2},\\ \\frac{a_0-a_1}{2})123456789inline void FWT_xor(int *f, int opt = 1) &#123; for (int mid = 1; mid &lt;&lt; 1 &lt;= n; mid &lt;&lt;= 1) for (int i = 0; i &lt; n; i += mid &lt;&lt; 1) for (int j = 0; j &lt; mid; ++j) &#123; int fx = f[i+j], fy = f[i+mid+j]; f[i+j] = (LL)opt * (fx + fy) % MOD; f[i+mid+j] = (LL)opt * (fx - fy + MOD) % MOD; &#125;&#125; （$IFWT$ 时，opt 应为 $2^{-1}$）","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"}],"tags":[{"name":"FWT","slug":"FWT","permalink":"http://true-banana.github.io/tags/FWT/"}]},{"title":"总结 多项式四则运算","slug":"2020-01-24-总结-多项式四则运算","date":"2020-01-24T09:22:18.000Z","updated":"2020-01-24T09:47:38.379Z","comments":true,"path":"2020/01/24/2020-01-24-总结-多项式四则运算/","link":"","permalink":"http://true-banana.github.io/2020/01/24/2020-01-24-%E6%80%BB%E7%BB%93-%E5%A4%9A%E9%A1%B9%E5%BC%8F%E5%9B%9B%E5%88%99%E8%BF%90%E7%AE%97/","excerpt":"","text":"前置知识：FFT/NTT见板子 FFT/NTT 多项式加减在系数表示法下直接逐位加减 多项式乘法两式先通过 DFT（FFT/NTT）化为点值表示法，逐位相乘，再 IDFT 回来 这里放个封装的： 1234567891011inline void mul(int *x, int *y, int lim) &#123; memset(X, 0, sizeof X), memset(Y, 0, sizeof Y);// 复制一份 for (int i = 0; i &lt; (lim &gt;&gt; 1); ++i) X[i] = x[i], Y[i] = y[i]; NTT(X, lim, 1), NTT(Y, lim, 1); for (int i = 0; i &lt; lim; ++i) X[i] = 1ll * X[i] * Y[i] % MOD; NTT(X, lim, -1); for (int i = 0; i &lt; lim; ++i) x[i] = X[i];&#125; 多项式求逆引用了 autoint 的 这篇博客 A\\times B\\equiv 1\\quad (mod\\ x^n)\\\\ A\\times B'\\equiv 1\\quad (mod\\ x^{\\frac{n}{2}})\\\\ A\\times (B-B')\\equiv 0\\quad (mod\\ x^{\\frac{n}{2}})\\\\ B-B'\\equiv 0\\quad (mod\\ x^{\\frac{n}{2}})\\\\ (B-B')^2\\equiv 0\\quad(mod\\ x^n)\\\\ A\\times(B^2-2BB'+B'^2)\\equiv 0\\quad(mod\\ x^n)\\\\ B-2B'+AB'^2\\equiv 0\\quad (mod\\ x^n)\\\\ B\\equiv 2B'-AB'^2\\quad (mod\\ x^n)据此可以倍增（可以把 B 数组滚动） 1234567891011121314151617inline void inv(int *x, int y[2][N], int &amp;cur, int lim) &#123; int base = 1, now = 2, len = 1; cur = 0; y[cur][0] = power(x[0], MOD - 2); while (base &lt;= lim &lt;&lt; 1) &#123; calc_rev(now, len); cur ^= 1; memset(y[cur], 0, sizeof y[cur]); for (int i = 0; i &lt; base; ++i) y[cur][i] = (y[cur^1][i] &lt;&lt; 1) % MOD; mul(y[cur^1], y[cur^1], now); mul(y[cur^1], x, now); for (int i = 0; i &lt; base; ++i) y[cur][i] = plus_mod(y[cur][i], MOD - y[cur^1][i]); base &lt;&lt;= 1, now &lt;&lt;= 1, len++; &#125;&#125; 咕咕咕。。。","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"}],"tags":[{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"http://true-banana.github.io/tags/FFT-NTT/"}]},{"title":"板子 K-D Tree","slug":"2020-01-20-板子-K-D-Tree","date":"2020-01-20T03:22:18.000Z","updated":"2020-01-20T03:54:43.528Z","comments":true,"path":"2020/01/20/2020-01-20-板子-K-D-Tree/","link":"","permalink":"http://true-banana.github.io/2020/01/20/2020-01-20-%E6%9D%BF%E5%AD%90-K-D-Tree/","excerpt":"","text":"用于处理高维空间组织点 大概就是在某个维度下从坐标中位数二分，最后形成一棵二叉树 插入删除会导致树不平衡，需要类似替罪羊树的拍扁重建 这里先放个 2-D 的吧，针对模板题P4169 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485const int N = 6e5 + 9;const double Alph = 0.75;// 平衡因子const int INF = 0x7fffffff;// 二维下的坐标及树节点struct Pos &#123; int x[2];&#125;;struct Node &#123; int minx[2], maxx[2], ls, rs, sz;// minx，maxx存坐标范围 Pos p;&#125;;int n, m, ans, root, cnt, nd;// nd为此时维度Pos a[N];Node tr[N];queue&lt;int&gt; trash;// 垃圾回收// 按照某个维度排序用cmpbool operator &lt;(Pos A, Pos B) &#123; return A.x[nd] &lt; B.x[nd];&#125;// 新建节点inline int new_node() &#123; int x; if (trash.empty()) x = ++cnt; else x = trash.front(), trash.pop(); return x;&#125;// 更新信息inline void push_up(int x) &#123; int ls = tr[x].ls, rs = tr[x].rs; // 范围 for (int i = 0; i &lt;= 1; ++i) &#123; tr[x].minx[i] = tr[x].maxx[i] = tr[x].p.x[i]; if (ls) tr[x].minx[i] = min(tr[x].minx[i], tr[ls].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[ls].maxx[i]); if (rs) tr[x].minx[i] = min(tr[x].minx[i], tr[rs].minx[i]), tr[x].maxx[i] = max(tr[x].maxx[i], tr[rs].maxx[i]); &#125; tr[x].sz = tr[ls].sz + tr[rs].sz + 1;&#125;// 建树（包括重建）int build(int l, int r, int d) &#123; if (l &gt; r) return 0; int x = new_node(), mid = (l + r) &gt;&gt; 1; nd = d, nth_element(a+l, a+mid, a+r+1), tr[x].p = a[mid];// 找中位数 tr[x].ls = build(l, mid-1, d^1), tr[x].rs = build(mid+1, r, d^1); push_up(x); return x;&#125;// 拍扁void pia(int x, int num) &#123; if (tr[x].ls) pia(tr[x].ls, num); a[num+tr[tr[x].ls].sz+1] = tr[x].p, trash.push(x);// 把点放入a数组便于建树 if (tr[x].rs) pia(tr[x].rs, num + tr[tr[x].ls].sz + 1);&#125;// 检查平衡inline void check(int &amp;x, int d) &#123; if (Alph * tr[x].sz &lt; tr[tr[x].ls].sz || Alph * tr[x].sz &lt; tr[tr[x].rs].sz) pia(x, 0), x = build(1, tr[x].sz, d);&#125;// 插入点void insert(Pos tp, int &amp;x, int d) &#123; if (!x) &#123; x = new_node(), tr[x].p = tp, tr[x].ls = tr[x].rs = 0, push_up(x); return; &#125; if (tp.x[d] &lt;= tr[x].p.x[d]) insert(tp, tr[x].ls, d^1); else insert(tp, tr[x].rs, d^1); push_up(x), check(x, d);&#125; 顺便放一下 K-D Tree 在该题的运用 12345678910111213141516171819202122232425262728293031323334353637// 求曼哈顿距离inline int dist(Pos A, Pos B) &#123; return abs(A.x[0] - B.x[0]) + abs(A.x[1] - B.x[1]);&#125;// 求点到矩形（K-D Tree上一个子树）的曼哈顿距离inline int getdis(Pos tp, int x) &#123; int sum = 0; for (int i = 0; i &lt;= 1; ++i) sum += max(0, tp.x[i] - tr[x].maxx[i]) + max(0, tr[x].minx[i] - tp.x[i]);// 不理解就手玩一下 return sum;&#125;void query(Pos tp, int x) &#123; ans = min(ans, dist(tp, tr[x].p)); int dl = INF, dr = INF; if (tr[x].ls) dl = getdis(tp, tr[x].ls); if (tr[x].rs) dr = getdis(tp, tr[x].rs); // 爆搜，先搜最优的 if (dl &lt; dr) &#123; if (dl &lt; ans) query(tp, tr[x].ls); if (dr &lt; ans) query(tp, tr[x].rs); &#125; else &#123; if (dr &lt; ans) query(tp, tr[x].rs); if (dl &lt; ans) query(tp, tr[x].ls); &#125;&#125;// queryans = INF, query(tp, root), printf(\"%d\\n\", ans); 我tcl，只会模板题","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"K-DTree","slug":"K-DTree","permalink":"http://true-banana.github.io/tags/K-DTree/"}]},{"title":"题解 P2467 [SDOI2010]地精部落","slug":"2020-01-19-题解-P2467-SDOI2010地精部落","date":"2020-01-19T09:22:18.000Z","updated":"2020-01-20T03:33:43.673Z","comments":true,"path":"2020/01/19/2020-01-19-题解-P2467-SDOI2010地精部落/","link":"","permalink":"http://true-banana.github.io/2020/01/19/2020-01-19-%E9%A2%98%E8%A7%A3-P2467-SDOI2010%E5%9C%B0%E7%B2%BE%E9%83%A8%E8%90%BD/","excerpt":"","text":"题意题面 求长度 $n$ 的交错序列的方案数 思路长度为 $i$ 的序列对于长度为 $i-1$ 的序列来说多了最大值 $i$ ，所有我们可以枚举这个最大值的位置 为保证是交错序列，那么最大值位置的前驱和后继都必须是“山谷” 从最大值的位置 $j$ 劈开，问题该状态便可以转化成两个子状态： 长度为 $j$ 的结尾下降的序列方案数和长度为 $i-1-j$ 的开头上升的序列方案数 结尾下降和开头上升本质相同 最后方案数要乘上组合 $C_{i-1}^j$ （从 1 至 $i-1$ 中选出 $j$ 个数组成最大值前面的序列，离散化后方案数相同） 状态表示 &amp; 转移方程设 f[i]表示长度为 $i$ 的交错序列的方案数 显然，开头上升和开头下降的方案一样多，开头上升的方案数就是总方案数的一半 \\huge f[i] = \\sum_{j=0}^{i-1}\\frac{f[j]}{2}\\cdot\\frac{f[i-1-j]}{2}\\cdot C_{i-1}^{j}细节边界f[1] = 1，除以2不就。。。 其实长度为1的序列可以看成两种情况（“山谷”或“山峰”） 至于f[0]，当序列最大值置于最左侧（$j=0$）时方案数不能乘0啊 所以f[0] = f[1] = 2 取模问题来了，$p$ 不为质数，不能求2的逆元，且 $a=b (mod p)$ 不等价于 $\\frac{a}{2}=\\frac{b}{2} (mod p)$ 怎样除以 2 ？ 因为 $x mod p=(x mod 2p) mod p$ （ $x$ 为 $mod 2p$ 意义下的偶数） 所以 $\\frac{x}{2} mod p=(\\frac{x mod 2p}{2}) mod p$ 过程中模 $2p$ 的意义下随便除以2，最后再模 $p$ 输出即可 空间似乎、听说、大概递推组合数的数组空间开不下，滚呗 code1234567891011read(n), read(p);c[0][0] = c[1][0] = c[1][1] = 1;f[0] = f[1] = 2;ll p2 = p * 2;for (int i = 2; i &lt;= n; ++i) &#123; for (int j = 1; j &lt;= i; ++j) c[i&amp;1][j] = (c[i&amp;1^1][j] + c[i&amp;1^1][j-1]) % p2; for (int j = 0; j &lt;= i - 1; ++j) f[i] = (1ll * c[i&amp;1^1][j] * f[j] / 2 % p2 * f[i-1-j] / 2 + f[i]) % p2;&#125;printf(\"%lld\\n\", f[n] % p);","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"递推DP","slug":"递推DP","permalink":"http://true-banana.github.io/tags/%E9%80%92%E6%8E%A8DP/"}]},{"title":"板子 左偏树","slug":"2020-01-17-板子-左偏树","date":"2020-01-17T11:52:18.000Z","updated":"2020-01-20T03:33:30.092Z","comments":true,"path":"2020/01/17/2020-01-17-板子-左偏树/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B7%A6%E5%81%8F%E6%A0%91/","excerpt":"","text":"左偏树本质是堆，在满足父亲比两个儿子的$val$都大（小）的时候保证 dist[ls] >= dist[rs]dist[x] = dist[rs] + 1于是就支持$merge$快速合并 $pop$就乱搞，合并两子树就行 可以用并查集维护所在堆 1234567891011121314151617181920212223242526272829int ch[N][2], dist[N], fa[N], val[N];int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]);&#125;int merge(int x, int y) &#123; if (!x || !y) return x | y; if (val[x] &gt; val[y]) swap(x, y); ch[x][1] = merge(ch[x][1], y); if (dist[ch[x][0]] &lt; dist[ch[x][1]]) swap(ch[x][0], ch[x][1]); dist[x] = dist[ch[x][1]] + 1; return x;&#125;inline void pop(int x) &#123; val[x] = -1, fa[ch[x][0]] = fa[ch[x][1]] = fa[x] = merge(ch[x][0], ch[x][1]);&#125;// 并查集初始化for (int i = 1; i &lt;= n; ++i) fa[i] = i;// mergeint fx = find(x), fy = find(y);fa[fx] = fa[fy] = merge(fx, fy);","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"左偏树","slug":"左偏树","permalink":"http://true-banana.github.io/tags/%E5%B7%A6%E5%81%8F%E6%A0%91/"}]},{"title":"OI学习规划","slug":"2020-01-17-OI学习规划","date":"2020-01-17T11:46:00.000Z","updated":"2020-04-07T13:05:57.502Z","comments":true,"path":"2020/01/17/2020-01-17-OI学习规划/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-OI%E5%AD%A6%E4%B9%A0%E8%A7%84%E5%88%92/","excerpt":"","text":"123456789dp数据结构数学图论搜索字符串计算几何思想杂项 目前一段时间的规划，随时添加 dp 普通dp 背包dp 树形dp 区间dp 状压dp 数位dp 计数dp *插头dp *动态dp dp优化 数据结构 单调队列 斜率优化 二进制拆分多重背包 四边形不等式 数据结构 基础数据结构 队列／栈 哈希表 堆 单调栈／单调队列 并查集 ST表 树状数组 线段树 zkw线段树 动态开点 左偏树 Trie树 平衡树 Treap／fhq Treap Splay 替罪羊树 zyf树 K-D Tree 可持久化数据结构 Trie 线段树（主席树） 平衡树 LCT 树套树 线段树套线段树 线段树套平衡树 虚树 数学 快速幂 高精度运算 数论 gcd／lcm 扩展欧几里德 欧拉定理／费马小定理 裴蜀定理 乘法逆元 exgcd 快速幂 线性求逆元 中国剩余定理 卢卡斯定理 *莫比乌斯反演 *杜教筛 线性代数 高斯消元 线性基 牛顿迭代法 组合数学 列表／枚举／瞎搞 卡特兰数 斯特林数 康托展开 容斥原理 抽屉原理 概率／期望多项式 FFT NTT 。。。全家桶 群论 图论 拓扑排序 最小生成树 Kruskal Prim 最短路 Dijkstra SPFA Floyd 二分图匹配 匈牙利算法 最大流 Tarjan 强连通分量 割点/割边 网络流 最大流 Dinic 最小割 费用流 上下界网络流 树论 LCA 倍增 树链剖分 LCT 树的重心 树分治 点分治 边分治 树链剖分 搜索 双向搜索 迭代加深 A* IDA* Dancing Links 字符串 Hash Trie树 KMP匹配 Manacher AC自动机 后缀数组 后缀自动机 计算几何咕咕咕 思想 分治 贪心 二分 前缀和/差分 打表找规律 手玩 杂项 I/O优化 离散化 CDQ分治 整体二分 莫队算法 分数规划 我好菜啊，什么都不会~","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[]},{"title":"板子 主席树","slug":"2020-01-17-板子-主席树","date":"2020-01-17T11:45:00.000Z","updated":"2020-02-14T11:18:36.623Z","comments":true,"path":"2020/01/17/2020-01-17-板子-主席树/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E4%B8%BB%E5%B8%AD%E6%A0%91/","excerpt":"","text":"我太懒了，上板子 luogu P3834 code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253struct Seg_Tree &#123; int cnt, n; int rt[N], sum[N&lt;&lt;5], ls[N&lt;&lt;5], rs[N&lt;&lt;5]; inline void push_up(int suc) &#123; sum[suc] = sum[ls[suc]] + sum[rs[suc]]; &#125; void build(int suc, int l, int r) &#123; sum[suc] = 0; if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; build(ls[suc] = ++cnt, l, mid), build(rs[suc] = ++cnt, mid+1, r); push_up(suc); &#125; void update(int suc, int pre, int l, int r, int x) &#123; ls[suc] = ls[pre], rs[suc] = rs[pre], sum[suc] = sum[pre] + 1; if (l &gt;= r) return; int mid = (l + r) &gt;&gt; 1; if (x &lt;= mid) update(ls[suc] = ++cnt, ls[pre], l, mid, x); else update(rs[suc] = ++cnt, rs[pre], mid+1, r, x); &#125; int query(int u, int v, int l, int r, int k) &#123; if (l &gt;= r) return l; int t = sum[ls[v]] - sum[ls[u]], mid = (l + r) &gt;&gt; 1; if (k &lt;= t) return query(ls[u], ls[v], l, mid, k); else return query(rs[u], rs[v], mid+1, r, k - t); &#125;&#125; tr;inline void main() &#123; read(n), read(m); for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i]; sort(b+1, b+n+1); tr.n = unique(b+1, b+n+1) - b - 1; tr.build(tr.rt[0] = ++tr.cnt, 1, tr.n); for (int i = 1; i &lt;= n; ++i) &#123; int x = lower_bound(b+1, b+tr.n+1, a[i]) - b; tr.update(tr.rt[i] = ++tr.cnt, tr.rt[i-1], 1, tr.n, x); &#125; int l, r, k; while (m--) &#123; read(l), read(r), read(k); printf(\"%d\\n\", b[tr.query(tr.rt[l-1], tr.rt[r], 1, tr.n, k)]); &#125;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"主席树","slug":"主席树","permalink":"http://true-banana.github.io/tags/%E4%B8%BB%E5%B8%AD%E6%A0%91/"}]},{"title":"总结 CDQ分治","slug":"2020-01-17-总结-CDQ分治","date":"2020-01-17T11:43:00.000Z","updated":"2020-01-20T03:32:25.059Z","comments":true,"path":"2020/01/17/2020-01-17-总结-CDQ分治/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-CDQ%E5%88%86%E6%B2%BB/","excerpt":"","text":"咕了几个月的玩意。。。 先贴几个板子，总结后面补 /youl P1908 逆序对 P2274 树状数组1 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152struct Node &#123; ll id, val, type; bool operator &lt;(const Node &amp;x) const &#123; return id == x.id ? type &lt; x.type : id &lt; x.id; &#125;&#125;;void CDQ(int l, int r) &#123; if (l == r) return; int mid = (l + r) / 2; CDQ(l, mid), CDQ(mid+1, r); int x = l, y = mid+1, k = l; ll sum = 0; while (x &lt;= mid &amp;&amp; y &lt;= r) &#123; if (a[x] &lt; a[y]) &#123; if (a[x].type == 1) sum += a[x].val; t[k++] = a[x++]; &#125; else &#123; if (a[y].type == 2) ans[a[y].val] -= sum; if (a[y].type == 3) ans[a[y].val] += sum; t[k++] = a[y++]; &#125; &#125; while (x &lt;= mid) t[k++] = a[x++]; while (y &lt;= r) &#123; if (a[y].type == 2) ans[a[y].val] -= sum; if (a[y].type == 3) ans[a[y].val] += sum; t[k++] = a[y++]; &#125; for (int i = l; i &lt;= r; i++) a[i] = t[i];&#125;......for (int i = 1, t; i &lt;= n; i++) t = read(), a[++cnta] = (Node)&#123;i, t, 1&#125;;for (int i = 1; i &lt;= m; i++) &#123; ll c = read(), x = read(), y = read(); if (c == 1) a[++cnta] = (Node)&#123;x, y, 1&#125;; else &#123; a[++cnta] = (Node)&#123;x-1, ++cntq, 2&#125;; a[++cnta] = (Node)&#123;y, cntq, 3&#125;; &#125;&#125; P3810 陌上花开 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657struct Node &#123; int a, b, c, cnt, ans; bool operator ==(const Node &amp;t) const &#123; return a == t.a &amp;&amp; b == t.b &amp;&amp; c == t.c; &#125;&#125;;int n, bn, maxk;int cnt[N];Node a[N], b[N];inline bool cmp1d(Node x, Node y) &#123; if (x.a == y.a) return x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b; return x.a &lt; y.a;&#125;inline bool cmp2d(Node x, Node y) &#123; return x.b == y.b ? x.c &lt; y.c : x.b &lt; y.b;&#125;struct Bit_tree &#123;...&#125; tr;void CDQ(int l, int r) &#123; if (l == r) return; int mid = (l + r) &gt;&gt; 1; CDQ(l, mid), CDQ(mid+1, r); sort(a+l, a+mid+1, cmp2d); sort(a+mid+1, a+r+1, cmp2d); int i = l, j = mid + 1, k = l; while (j &lt;= r) &#123; while (i &lt;= mid &amp;&amp; a[i].b &lt;= a[j].b) tr.add(a[i].c, a[i].cnt), i++; a[j].ans += tr.query(a[j].c), j++; &#125; for (j = l; j &lt; i; ++j) tr.add(a[j].c, -a[j].cnt);&#125;inline void main() &#123; read(bn), read(maxk); for (int i = 1; i &lt;= bn; ++i) read(b[i].a), read(b[i].b), read(b[i].c); sort(b+1, b+bn+1, cmp1d); for (int i = 1; i &lt;= bn; ++i) &#123; if (b[i] == b[i-1]) a[n].cnt++; else a[++n] = b[i], a[n].cnt++; &#125; CDQ(1, n); for (int i = 1; i &lt;= n; ++i) cnt[a[i].ans + a[i].cnt - 1] += a[i].cnt; for (int i = 0; i &lt; bn; ++i) printf(\"%d\\n\", cnt[i]);&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"CDQ分治","slug":"CDQ分治","permalink":"http://true-banana.github.io/tags/CDQ%E5%88%86%E6%B2%BB/"}]},{"title":"板子 FFT/NTT","slug":"2020-01-17-板子-FFTNTT","date":"2020-01-17T11:42:00.000Z","updated":"2020-01-24T09:26:45.133Z","comments":true,"path":"2020/01/17/2020-01-17-板子-FFTNTT/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-FFTNTT/","excerpt":"","text":"Rader排序123456for (lim = 1; lim &lt;= n; lim &lt;&lt;= 1, len++);inline void calc_rev(int lim, int len) &#123; for (int i = 1; i &lt; lim; ++i) rev[i] = (rev[i&gt;&gt;1] &gt;&gt; 1) | ((i &amp; 1) &lt;&lt; (len - 1));&#125; FFT封装复数123456789101112131415struct Complex &#123; double x, y; Complex(double xx = 0, double yy = 0) &#123; x = xx, y = yy; &#125; Complex operator +(const Complex &amp;t) const &#123; return Complex(x + t.x, y + t.y); &#125; Complex operator -(const Complex &amp;t) const &#123; return Complex(x - t.x, y - t.y); &#125; Complex operator *(const Complex &amp;t) const &#123; return Complex(x * t.x - y * t.y, y * t.x + x * t.y); &#125;&#125;; FFT()123456789101112131415161718192021const double Pi = acos(-1.0);inline void FFT(Complex *f, int lim, int opt) &#123; for (int i = 0; i &lt; lim; ++i) if (i &lt; rev[i]) swap(f[i], f[rev[i]]); for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; Complex wn(cos(Pi / mid), opt * sin(Pi / mid)); for (int i = 0; i &lt; lim; i += mid &lt;&lt; 1) &#123; Complex w(1, 0); for (int j = 0; j &lt; mid; ++j, w = w * wn) &#123; Complex tx = f[i+j], ty = w * f[i+mid+j]; f[i+j] = tx + ty, f[i+mid+j] = tx - ty; &#125; &#125; &#125; if (opt == -1) &#123; for (int i = 0; i &lt; lim; ++i) f[i].x /= n, f[i].y /= n; &#125;&#125; 三次变两次优化把 f2 放到 f1 的虚部上，DFT一遍，平方，再把虚部取出来除以2即可 NTT用 int 时注意模好 12345678910111213141516171819202122232425const int MOD = 998244353;const int G = 3;const int invG = 332748118;inline void NTT(int *f, int lim, int opt) &#123; for (int i = 0; i &lt; lim; ++i) if (i &lt; rev[i]) swap(f[i], f[rev[i]]); for (int mid = 1; mid &lt; lim; mid &lt;&lt;= 1) &#123; int wn = power(opt == 1 ? G : invG, (MOD - 1) / (mid &lt;&lt; 1)); for (int i = 0; i &lt; lim; i += (mid &lt;&lt; 1)) &#123; int w = 1; for (int j = 0; j &lt; mid; ++j, w = (1ll * w * wn) % MOD) &#123; LL tx = f[i+j], ty = (1ll * w * f[i+mid+j]) % MOD; f[i+j] = (0ll + tx + ty) % MOD; f[i+mid+j] = (0ll + tx - ty + MOD) % MOD; &#125; &#125; &#125; if (opt == -1) &#123; int invlim = power(lim, MOD - 2); for (int i = 0; i &lt; lim; ++i) f[i] = 1ll * f[i] * invlim % MOD; &#125;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"}],"tags":[{"name":"FFT/NTT","slug":"FFT-NTT","permalink":"http://true-banana.github.io/tags/FFT-NTT/"}]},{"title":"蒟蒻的zz码风","slug":"2020-01-17-蒟蒻的zz码风","date":"2020-01-17T11:40:00.000Z","updated":"2020-04-07T13:06:30.333Z","comments":true,"path":"2020/01/17/2020-01-17-蒟蒻的zz码风/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E8%92%9F%E8%92%BB%E7%9A%84zz%E7%A0%81%E9%A3%8E/","excerpt":"","text":"自认为码风就像代码的脸，无论是调试还是写题解都极其重要 下面是我的码风，莫喷 空格 &amp; tab松散胜于紧凑 tab宽度4 运算符前后加空格 , 后加空格 嫌挤的地方加空格 大括号不换行（少说这个，引起战争） 大概一个 a+b 写成这样： 12345678#include &lt;iostream&gt;using namespace std;int main() &#123; int a, b; cin &gt;&gt; a &gt;&gt; b; cout &lt;&lt; a + b &lt;&lt; endl; return 0;&#125; 代码块分布意思相近的语句、函数写到一块 大块数据结构包装起来 各个代码块间加空行（我乱加空行的怪癖改不掉） 顺序嘛： 12345678910111213141516171819202122232425// 头文件#include &lt;iostream&gt;using namespace std;// 快读template&lt;typename TT&gt; inline void read(TT &amp;x) &#123; /*...*/ &#125;// 宏定义/结构体定义#define ... ...typedef long long LL;struct Node &#123;&#125;;// 常量定义const int N = ...;// 变量定义int n, m;int a[N];// 函数/包装用的结构体void solve() &#123;&#125;struct Splay &#123;&#125;;// 主函数int main() &#123;&#125; 当然我喜欢总体套一个 namespace ，看这里 压行曾经我是痛恨压行的，如今自己成为了曾经讨厌的人。。。 代码还是简洁的好 不过自认为压行并不是凑到一块那么简单 我曾见过这样的压行 123456789101112131415inline bool bfs()&#123; for (int i=0;i&lt;=n+k+1;++i)cur[i]=head[i]; queue&lt;int&gt; q; memset(deep,0x3f,sizeof(deep));memset(inq,0,sizeof(inq)); q.push(s);inq[s]=true;deep[s]=0; while(!q.empty())&#123; int u=q.front(),v;q.pop();inq[u]=false; for(int i=head[u];i;i=e[i].nxt)&#123;v=e[i].to; if(deep[v]&gt;deep[u]+1&amp;&amp;e[i].flow)&#123; deep[v]=deep[u]+1;if(!inq[v])&#123;q.push(v);inq[v]=true;&#125; &#125; &#125; &#125; return deep[t]!=INF;&#125; 不是我想针对谁，这样压行太拙劣了 压行要有原则和规范 一行内尽量不出现多个; { 后不要写东西， }另起一行（大括号一般使用时） 不好理解或过于复杂的代码不压行 熟练运用 C++ 语言特性来缩减语句 for/while 等里面只有一句时不加大括号 用,连接较短语句，作为一句（有时候还能少个大括号呢） 12for (int i = 1, u, v; i &lt;= n; ++i) read(u), read(v), add(u, v); 多用三目运算符代替简单的 if/else 判断 12get(fa) == get(x) ? rotate(fa) : rotate(x);(tag ? a1 : a2)[i] = x;// 雾 多使用结构体的整体赋值 1e[++cnt] = (Edge)&#123;head[u], v&#125;; 运用&amp;&amp; ||的短路特性 部分() []中嵌套一些简单赋值 123for (int i = head[u], v; i; i = e[i].nxt) if ((v = e[i].to) != fa) ... 显然我的压行优越得多 总之敲代码要心情愉悦~ 最后附上我美轮美奂的 vscode update 2020.1.18 有人说“美轮美奂”不应该在这用，好吧我语文不好，只好说把我的VSCODE比喻为华丽的建筑 欢迎交流互鉴 平写题解都没见你bb这么多","categories":[{"name":"随笔","slug":"随笔","permalink":"http://true-banana.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"板子 Link-Cut Tree","slug":"2020-01-17-板子-Link-Cut-Tree","date":"2020-01-17T11:39:00.000Z","updated":"2020-01-20T03:32:50.562Z","comments":true,"path":"2020/01/17/2020-01-17-板子-Link-Cut-Tree/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Link-Cut-Tree/","excerpt":"","text":"多敲多理解，适合小黄鸭调试的数据结构 发现还是不要包装每个节点的好，好看还常数小 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980struct Link_Cut_Tree &#123; int fa[N], ch[N][2], sum[N], val[N], rev[N]; int stk[N]; inline bool which(int x) &#123; return ch[fa[x]][1] == x; &#125; inline bool not_root(int x) &#123; return ch[fa[x]][0] == x || ch[fa[x]][1] == x; &#125; inline void push_up(int x) &#123; sum[x] = sum[ch[x][0]] ^ sum[ch[x][1]] ^ val[x]; &#125; inline void reverse(int x) &#123; swap(ch[x][0], ch[x][1]), rev[x] ^= 1; &#125; inline void push_down(int x) &#123; if (rev[x]) &#123; rev[x] = 0; if (ch[x][0]) reverse(ch[x][0]); if (ch[x][1]) reverse(ch[x][1]); &#125; &#125; inline void rotate(int x) &#123; int f = fa[x], gf = fa[f], w = which(x), y = ch[x][w^1]; if (not_root(f)) ch[gf][which(f)] = x; ch[x][w^1] = f, ch[f][w] = y; if (y) fa[y] = f; fa[f] = x, fa[x] = gf; push_up(f); &#125; inline void splay(int x) &#123; int top = 0, f = x; stk[++top] = x; while (not_root(f)) stk[++top] = f = fa[f]; while (top) push_down(stk[top--]); while (not_root(x)) &#123; f = fa[x]; if (not_root(f)) which(x) == which(f) ? rotate(f) : rotate(x); rotate(x); &#125; push_up(x); &#125; inline void access(int x) &#123; for (int y = 0; x; y = x, x = fa[x]) splay(x), ch[x][1] = y, push_up(x); &#125; inline void make_root(int x) &#123; access(x), splay(x), reverse(x); &#125; inline int find_root(int x) &#123; access(x), splay(x); while (ch[x][0]) push_down(x), x = ch[x][0]; splay(x); return x; &#125; inline void split(int x, int y) &#123; make_root(x), access(y), splay(y); &#125; inline void link(int x, int y) &#123; make_root(x); if (find_root(y) != x) fa[x] = y; &#125; inline void cut(int x, int y) &#123; make_root(x); if (find_root(y) == x &amp;&amp; fa[y] == x &amp;&amp; !ch[y][0]) fa[y] = ch[x][1] = 0, push_up(x); &#125;&#125; lct;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","permalink":"http://true-banana.github.io/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://true-banana.github.io/tags/LCT/"}]},{"title":"总结 点分治","slug":"2020-01-17-总结-点分治","date":"2020-01-17T11:38:00.000Z","updated":"2020-01-20T03:30:51.697Z","comments":true,"path":"2020/01/17/2020-01-17-总结-点分治/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%80%BB%E7%BB%93-%E7%82%B9%E5%88%86%E6%B2%BB/","excerpt":"","text":"用于某些统计树上路径的题 每次找树的重心为根（$O(n)$） 处理每个点到根的距离等信息（$O(n)$） 统计答案（$O(n)$或$O(nlogn)$等） 划分根的各个子树，分治下去（总共分治$logn$层） 模板部分getroot() 找树的重心 12345678910111213void getroot(int u, int fa, int size) &#123; sz[u] = 1, maxs[u] = 0; for (int i = head[u], v; i; i = e[i].nxt) if (!vis[e[i].to] &amp;&amp; e[i].to != fa) &#123; v = e[i].to; getroot(v, u, size); sz[u] += sz[v]; maxs[u] = max(maxs[u], sz[v]); &#125; maxs[u] = max(maxs[u], size - sz[u]); if (!root || maxs[u] &lt; maxs[root]) root = u;&#125; getdis() 处理各点的距离 12345678// 带染色void getdis(int u, int fa, int dis, int color) &#123; t[++tot] = u; d[u] = dis, col[u] = color; for (int i = head[u], v; i; i = e[i].nxt) if (e[i].to != fa &amp;&amp; !vis[e[i].to]) v = e[i].to, getdis(v, u, d[u] + e[i].val, color);&#125; 统计答案时会重复，同一子树中的两个点是不能成点对的 有两种方式，将各个子树染色，或是通过容斥原理减去子树的一部分答案 solve() 分治 1234567891011void solve(int u) &#123; vis[u] = true; ans += calc(u, 0); for (int i = head[u], v; i; i = e[i].nxt) if (!vis[e[i].to]) &#123; v = e[i].to, root = 0; ans -= calc(v, e[i].val);// 染色的话不加这句话 getroot(v, 0, sz[v]); solve(root); &#125;&#125; 统计答案calc() 每道题是不同的 以模板题为例 1给定一棵有n个点的树，询问树上距离为k的点对是否存在 将每个点的深度处理出来后，按深度排序 1234567tot = 0;t[++tot] = u;d[u] = dis, col[u] = u;for (int i = head[u], v; i; i = e[i].nxt) if (!vis[e[i].to]) v = e[i].to, getdis(v, u, d[u]+e[i].val, v);sort(t+1, t+tot+1, cmp); 此时又有两种方法： 双指针扫 12345678910111213int l = 1, r = tot;while (l &lt; r) &#123; if (d[t[l]] + d[t[r]] &gt; k) r--; else if (d[t[l]] + d[t[r]] &lt; k) l++; else if (col[t[l]] == col[t[r]]) d[t[r]] == d[t[r-1]] ? r-- : l++; else &#123; ans = true; break; &#125;&#125; 二分查找 123456789101112131415int l = 1, r;while (l &lt; tot &amp;&amp; d[t[l]] + d[t[tot]] &lt; k) l++;while (l &lt; tot) &#123; if (d[t[l]] &gt; k - d[t[l]]) break; d[0] = k - d[t[l]]; r = lower_bound(t+1, t+tot+1, 0, cmp) - t; while (r &lt;= tot &amp;&amp; d[t[l]] + d[t[r]] == k) &#123; if (col[t[l]] != col[t[r]]) ans = true; r++; &#125; l++;&#125; 复杂度上限在于排序（$O(nlogn)$） 如果可以的话，可以桶排，降到（$O(n)$） 一些题目P4178树上长度小于等于k的路径 P4149长度为k的路径最小边数 我菜，好多还没做过。。。","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","permalink":"http://true-banana.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"点分治","slug":"点分治","permalink":"http://true-banana.github.io/tags/%E7%82%B9%E5%88%86%E6%B2%BB/"}]},{"title":"板子 WBLT","slug":"2020-01-17-板子-WBLT","date":"2020-01-17T11:37:00.000Z","updated":"2020-02-19T03:58:35.282Z","comments":true,"path":"2020/01/17/2020-01-17-板子-WBLT/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-WBLT/","excerpt":"","text":"本质上是平衡线段树 叶子节点维护原数列，非叶子节点维护子树最大值 比splay好写多了 我数组版+各种封装的巨大常数+单旋，luogu上跑347ms，开O2后161ms，还算可以 没时间总结了，贴个板子走人 强烈安利 Blog：qwaszx 的博客 维护平衡WBLT 可以通过旋转或者拍扁重建（类似替罪羊树）的方式维护平衡 我只会喜欢旋转，而且为了方便我就只写单旋 单旋复杂度不对但是不好卡（慢是慢一点） 有时间再更双旋吧 每次 insert/delete 后回溯更新信息时 maintain 一下 code update 2020.2.19 贴个封装少的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778struct WBLT &#123; int cnt, root; int val[M], sz[M], ls[M], rs[M]; WBLT() &#123; new_node(root, 1e9); &#125; inline bool is_leaf(int x) &#123; return !(ls[x] || rs[x]); &#125; inline void push_up(int x) &#123; if (is_leaf(x)) return; val[x] = max(val[ls[x]], val[rs[x]]); sz[x] = sz[ls[x]] + sz[rs[x]]; &#125; inline void new_node(int &amp;x, int k) &#123; x = ++cnt; val[x] = k, sz[x] = 1; &#125; inline void rotate(int x, bool opt) &#123; if (!opt) &#123; int rson = rs[x]; rs[x] = ls[x], ls[x] = ls[rs[x]]; ls[rs[x]] = rs[rs[x]], rs[rs[x]] = rson; &#125; else &#123; int lson = ls[x]; ls[x] = rs[x], rs[x] = rs[ls[x]]; rs[ls[x]] = ls[ls[x]], ls[ls[x]] = lson; &#125; push_up(ls[x]), push_up(rs[x]); &#125; inline void maintain(int x) &#123; if (is_leaf(x)) return; if (sz[ls[x]] &gt;= sz[rs[x]] * 4) rotate(x, 0); if (sz[rs[x]] &gt;= sz[ls[x]] * 4) rotate(x, 1); &#125; void insert(int x, int k) &#123; if (is_leaf(x)) &#123; new_node(ls[x], min(val[x], k)); new_node(rs[x], max(val[x], k)); push_up(x); return; &#125; if (k &lt;= val[ls[x]]) insert(ls[x], k); else insert(rs[x], k); push_up(x), maintain(x); &#125; void erase(int x, int fa, int k) &#123; if (is_leaf(x)) &#123; if (!fa) return; int son = ls[fa] == x ? rs[fa] : ls[fa]; val[fa] = val[son], sz[fa] = sz[son]; ls[fa] = ls[son], rs[fa] = rs[son]; return; &#125; if (k &lt;= val[ls[x]]) erase(ls[x], x, k); else erase(rs[x], x, k); push_up(x), maintain(x); &#125; int rank(int x, int k) &#123; if (is_leaf(x)) return 1 + (k &gt; val[x]); if (k &lt;= val[ls[x]]) return rank(ls[x], k); else return sz[ls[x]] + rank(rs[x], k); &#125; int k_th(int x, int k) &#123; if (is_leaf(x)) return x; if (k &lt;= sz[ls[x]]) return k_th(ls[x], k); else return k_th(rs[x], k - sz[ls[x]]); &#125; int next(int rt, int k, bool opt) &#123; int rk = rank(rt, k), rk2 = rank(rt, k+1); if (!opt &amp;&amp; rk == 1) return -INF; if (opt &amp;&amp; rk2 &gt; sz[rt]) return INF; return val[k_th(rt, opt ? rk2 : rk - 1)]; &#125;&#125;; Luogu P3369 code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;namespace BANANA &#123;template&lt;typename T&gt; inline void read(T &amp;x) &#123;/*Orz*/&#125;const int N = 1e5 + 5;struct WBLT &#123; struct Node &#123; int val, size, ls, rs; &#125;; int root, cnt; Node tr[N&lt;&lt;1]; inline bool is_leaf(int x) &#123; return !(tr[x].ls || tr[x].rs); &#125; inline void push_up(int x) &#123; if (is_leaf(x)) return; tr[x].val = max(tr[tr[x].ls].val, tr[tr[x].rs].val); tr[x].size = tr[tr[x].ls].size + tr[tr[x].rs].size; &#125; inline void new_node(int &amp;x, int val) &#123; x = ++cnt; tr[x].val = val, tr[x].size = 1; &#125; inline void rotate(int x, bool opt) &#123; if (!opt) &#123; int rs = tr[x].rs; tr[x].rs = tr[x].ls; tr[x].ls = tr[tr[x].rs].ls; tr[tr[x].rs].ls = tr[tr[x].rs].rs; tr[tr[x].rs].rs = rs; &#125; else &#123; int ls = tr[x].ls; tr[x].ls = tr[x].rs; tr[x].rs = tr[tr[x].ls].rs; tr[tr[x].ls].rs = tr[tr[x].ls].ls; tr[tr[x].ls].ls = ls; &#125; push_up(tr[x].ls), push_up(tr[x].rs); &#125; inline void maintain(int x) &#123; if (is_leaf(x)) return; if (tr[tr[x].ls].size &gt;= tr[tr[x].rs].size * 4) rotate(x, 0); if (tr[tr[x].rs].size &gt;= tr[tr[x].ls].size * 4) rotate(x, 1); &#125; void insert(int &amp;x, int val) &#123; if (is_leaf(x)) &#123; new_node(tr[x].ls, min(tr[x].val, val)); new_node(tr[x].rs, max(tr[x].val, val)); push_up(x); return; &#125; if (val &lt;= tr[tr[x].ls].val) insert(tr[x].ls, val); else insert(tr[x].rs, val); push_up(x), maintain(x); &#125; void del(int x, int fa, int val) &#123; if (is_leaf(x)) &#123; if (tr[x].val == val) &#123; if (x == tr[fa].ls) tr[fa] = tr[tr[fa].rs]; else tr[fa] = tr[tr[fa].ls]; &#125; return; &#125; if (val &lt;= tr[tr[x].ls].val) del(tr[x].ls, x, val); else del(tr[x].rs, x, val); push_up(x), maintain(x); &#125; int rank(int x, int val) &#123; if (is_leaf(x)) &#123; return 1 + (val &gt; tr[x].val); &#125; if (val &lt;= tr[tr[x].ls].val) return rank(tr[x].ls, val); else return tr[tr[x].ls].size + rank(tr[x].rs, val); &#125; int k_th(int x, int k) &#123; if (is_leaf(x)) return tr[x].val; if (k &lt;= tr[tr[x].ls].size) return k_th(tr[x].ls, k); else return k_th(tr[x].rs, k - tr[tr[x].ls].size); &#125;&#125;;int n;WBLT t;inline void main() &#123; read(n); t.new_node(t.root, 1e9); int opt, x; while (n--) &#123; read(opt), read(x); switch (opt) &#123; case 1: t.insert(t.root, x); break; case 2: t.del(t.root, 0, x); break; case 3: printf(\"%d\\n\", t.rank(t.root, x)); break; case 4: printf(\"%d\\n\", t.k_th(t.root, x)); break; case 5: printf(\"%d\\n\", t.k_th(t.root, t.rank(t.root, x) - 1)); break; case 6: printf(\"%d\\n\", t.k_th(t.root, t.rank(t.root, x+1))); break; &#125; &#125;&#125;&#125;int main() &#123; BANANA::main(); return 0;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://true-banana.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"板子 AC自动机","slug":"2020-01-17-板子-AC自动机","date":"2020-01-17T11:36:00.000Z","updated":"2020-01-20T03:30:31.596Z","comments":true,"path":"2020/01/17/2020-01-17-板子-AC自动机/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-AC%E8%87%AA%E5%8A%A8%E6%9C%BA/","excerpt":"","text":"匹配多个模式串 本质上是trie tree + kmp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748struct AC_automaton &#123; int cnt; int tr[N][26], fail[N], end[N], tot[M]; inline void init() &#123; cnt = 0; memset(tr, 0, sizeof tr); memset(fail, 0, sizeof fail); memset(end, 0, sizeof end); memset(tot, 0, sizeof tot); &#125; inline void insert(char *s, int x) &#123; int p = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; if (!tr[p][s[i]-'a']) tr[p][s[i]-'a'] = ++cnt; p = tr[p][s[i]-'a']; &#125; end[p] = x; &#125; inline void build() &#123; queue&lt;int&gt; q; for (int i = 0; i &lt; 26; ++i) if (tr[0][i]) q.push(tr[0][i]); while (!q.empty()) &#123; int x = q.front(); q.pop(); for (int i = 0; i &lt; 26; ++i) &#123; if (tr[x][i]) fail[tr[x][i]] = tr[fail[x]][i], q.push(tr[x][i]); else tr[x][i] = tr[fail[x]][i]; &#125; &#125; &#125; inline void query(char *s) &#123; int p = 0, len = strlen(s); for (int i = 0; i &lt; len; ++i) &#123; p = tr[p][s[i]-'a']; for (int j = p; j; j = fail[j]) tot[end[j]]++; &#125; &#125;&#125;; 先这样，有时间再补充","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"字符串","slug":"字符串","permalink":"http://true-banana.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"AC自动机","slug":"AC自动机","permalink":"http://true-banana.github.io/tags/AC%E8%87%AA%E5%8A%A8%E6%9C%BA/"}]},{"title":"板子 Dinic","slug":"2020-01-17-板子-Dinic","date":"2020-01-17T11:36:00.000Z","updated":"2020-04-08T06:51:30.599Z","comments":true,"path":"2020/01/17/2020-01-17-板子-Dinic/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dinic/","excerpt":"","text":"网络最大流记得加当前弧优化 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556int n, m, cnt = 1, s, t;int head[N], deep[N], cur[N];Edge e[N&lt;&lt;2];bool inq[N];inline void add(int u, int v, int w) &#123; e[++cnt] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt;&#125;inline bool bfs() &#123; for (int i = 1; i &lt;= n; ++i) cur[i] = head[i]; queue&lt;int&gt; q; memset(deep, 0x3f, sizeof deep); memset(inq, 0, sizeof inq); q.push(s), inq[s] = true; deep[s] = 0; while (!q.empty()) &#123; int u = q.front(); q.pop(); inq[u] = false; for (int i = head[u]; i; i = e[i].nxt) &#123; int v = e[i].to; if (deep[v] &gt; deep[u] + 1 &amp;&amp; e[i].flow) &#123; deep[v] = deep[u] + 1; if (!inq[v]) q.push(v), inq[v] = true; &#125; &#125; &#125; return deep[t] != INF;&#125;int dfs(int u, int flow) &#123; if (u == t || !flow) return flow; int rlow, v, re = 0; for (int i = head[u]; i; i = e[i].nxt) &#123; v = e[i].to; if (deep[v] == deep[u] + 1 &amp;&amp; e[i].val &amp;&amp; (rlow = dfs(v, min(flow, e[i].val)))) &#123; e[i].val -= rlow, e[i^1].val += rlow; flow -= rlow, re += rlow; if (!flow) break; &#125; &#125; if (!re) deep[u] = -1; return re;&#125;inline int Dinic() &#123; int maxflow = 0, lowflow; while (bfs()) if (lowflow = dfs(s, INF)) maxflow += lowflow; return maxflow;&#125; 费用流12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849int n, m, cnt, s, t, maxflow, mincost;int head[N], prev[N], pree[N], dis[N], flow[N];Edge e[M&lt;&lt;1];bool inq[N];inline void add(int u, int v, int w, int f) &#123; e[++cnt] = (Edge)&#123;head[u], v, w, f&#125;, head[u] = cnt;&#125;inline bool SPFA() &#123; queue&lt;int&gt; q; memset(inq, 0, sizeof inq); memset(dis, 0x3f, sizeof dis); memset(flow, 0x3f, sizeof flow); q.push(s), inq[s] = true; dis[s] = 0; while (!q.empty()) &#123; int u = q.front(), v; q.pop(); inq[u] = false; for (int i = head[u]; i; i = e[i].nxt) &#123; v = e[i].to; if (e[i].flow &gt; 0 &amp;&amp; dis[v] &gt; dis[u] + e[i].cost) &#123; dis[v] = dis[u] + e[i].cost; prev[v] = u, pree[v] = i; flow[v] = min(flow[u], e[i].flow); if (!inq[v]) q.push(v), inq[v] = true; &#125; &#125; &#125; return flow[t] != INF;&#125;inline void Dinic() &#123; while (SPFA()) &#123; maxflow += flow[t]; mincost += flow[t] * dis[t]; int x = t; while (x != s) &#123; e[pree[x]].flow -= flow[t]; e[pree[x]^1].flow += flow[t]; x = prev[x]; &#125; &#125;&#125;// 加边注意add(u, v, w, f), add(v, u, 0, -f);","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","permalink":"http://true-banana.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"网络最大流","slug":"网络最大流","permalink":"http://true-banana.github.io/tags/%E7%BD%91%E7%BB%9C%E6%9C%80%E5%A4%A7%E6%B5%81/"},{"name":"费用流","slug":"费用流","permalink":"http://true-banana.github.io/tags/%E8%B4%B9%E7%94%A8%E6%B5%81/"}]},{"title":"题解 P5662 【纪念品】","slug":"2020-01-17-题解-P5662-【纪念品】","date":"2020-01-17T11:35:00.000Z","updated":"2020-01-20T03:31:06.967Z","comments":true,"path":"2020/01/17/2020-01-17-题解-P5662-【纪念品】/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P5662-%E3%80%90%E7%BA%AA%E5%BF%B5%E5%93%81%E3%80%91/","excerpt":"","text":"题面 最后一次考pj了，居然炸了 s组day1把我心态考崩了，下午j组写了200分就开始颓废，估计要被学弟们嘲笑了QAQ 好了，开始事后诸葛 n个物品，t天价格，数据范围不大，但是直接推转移方程不太可行 想到背包（考场上脑子里“背包”两字都没出现） 先考虑$n=1$的情况： 可以把t天的价格中，相邻两天的价格差当作一个物品（$price=a[i],value=a[i+1]-a[i]$） f[i]表示花费i金币的最大收益（不包括本金） 可以自己手玩一下，同时选物品$i$和$i+1$收益就是$a[i+2]-a[i]$，可以连续起来 每一天可以买卖多个，所以是完全背包 注意每天结束之后更新m，毕竟收益也可以用 现在拓展到多个纪念品： 每一天都有n个物品，每个物品的价格还是本身，收益是下一天的减这一天的价格 每一天把n个物品做完全背包，之后更新m 最后得到的m就是答案 坑点是每天背包之前清空f数组 code1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt;inline void read(T &amp;x) &#123;/*...*/&#125;const int N = 105;const int M = 1e4 + 5;int t, n, m;int a[N][N], f[M];int main() &#123; read(t), read(n), read(m); for (int i = 1; i &lt;= t; ++i) for (int j = 1; j &lt;= n; ++j) read(a[i][j]); for (int i = 1; i &lt;= t; ++i) &#123; memset(f, 0, sizeof f); for (int j = 1; j &lt;= n; ++j) for (int k = a[i][j]; k &lt;= m; ++k) f[k] = max(f[k], f[k - a[i][j]] + a[i+1][j] - a[i][j]); m = max(m, f[m] + m); &#125; printf(\"%d\\n\", m); return 0;&#125; 话说今年pj比去年水的多，比tg良心","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"背包DP","slug":"背包DP","permalink":"http://true-banana.github.io/tags/%E8%83%8C%E5%8C%85DP/"}]},{"title":"CSP2019 游记","slug":"2020-01-17-CSP2019-游记","date":"2020-01-17T11:34:00.000Z","updated":"2020-04-07T13:05:38.947Z","comments":true,"path":"2020/01/17/2020-01-17-CSP2019-游记/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-CSP2019-%E6%B8%B8%E8%AE%B0/","excerpt":"","text":"day0大早上迷迷糊糊开始坐车，高铁上和Luan学长邻座，rp++ 睡了一路因为想干的事情太多了于是就什么都不干，下车终于不困了，rp++ 下午试机，发现键盘很爽，rp++ 发现VMware里的noilinux没有vmtools，没法全屏，有点担忧，rp— 虽然是第二次来燕大，回宾馆又差点迷路了QAQ，rp— 晚饭吃的和去年一样的自助，那种按斤算的，很饱，rp++ 晚上板子敲不下去，开始作死调dp，终于过了，rp++ day1 morning早上起来，状态不是很好，rp— 考场现看的，考试区域没看 于是我跟着一群人来到了燕大西校区，而我应该在东校区考的 差点死了rp &gt;&gt;= 1 感谢好心人捎我们回去，rp++ 进了考场，发了题 密码是什么“认真思考”，还有个? 打错一次密码，rp— 看题，rp = 0 T1开始理解错题意，调了半个小时错解 写完之后发现n=64时wa了 好吧这是一道unsigned long long题 T2括号序列一类的问题早忘了怎么写。。。 敲了$n^2$暴力，预估50pts 想着敲完T3暴力回来想正解 T3又一道树上问题？？？ 敲了$n!$暴力，预估10pts 好吧码力太渣，暴力都调了半天，我没救了 敲完想到了贪心做法（估计也不对），但时间只剩40min 赌一把吧。。。（咔嗒咔嗒键盘声） 码力太渣*2，写不出来，心态也崩了 好吧浪费了40min，最后5min收拾收拾交卷 day1估分：$100+50+10=160$，一年白学了 day1两道树论，预感极差 背的板子全没用上，是我太菜不会用？ md不该杠T3的 参照去年的难度，不指望day2翻盘 回宾馆上Luogu，发现： 人均210，我不是人 不想考下午的CSP-J了，我想散散心，现在心里想不开 day1 afternoon完了pj也炸了 开考前2分钟机房停电 延迟了半小时 开题发现不妙啊 T1T2半小时切了 T3似乎某个学长讲过（雾 推了半天，用$n^2$dp套点东西 搞出来$O(nmt^2)$的暴力dp 考场上想平衡树维护凸包来斜率优化1e9-&gt;1e8，我是不是没救了 第二步分组背包不会写了QAQ（时间不够有点紧张） T4想了个错解，算是死了 于是T3T4全靠暴力拿点可怜分了 早知道不考这东西了，200出头真丢人 晚饭去了一个人不多的餐厅，那个牛肉面很难吃 晚上又开始无所事事。。。 其实好慌的，day2翻盘太难了 day2加油！！！ day2早上起来肚子疼，状态极差 永远不要想着day2翻盘，到了day2你都不知道盘是什么样子 T1貌似计数dp，写了半天不对 T2貌似还是dp，反正样例都没过去 md，dp题怎么暴力啊（我还是最菜的） 实在不行写T3吧，写了好像40分的暴力 最后T1T2搞半天没半小时写的T3暴力分高 好颓废啊，这一年真的白学了 $CCF$用实力证明了$CSP$和$NOIP$没有关系 Luogu 上评分两黑两紫。。。 真的是三年降一档 总结算是来旅游的吧 起码有点教训： 码力渣，细节处理不行，常见问题不会解决，明年必须刷题600+吧 三年降一档，能力必须在考试难度以上 dp需要练，快速得出状态表示和转移方程很重要 不能轻视每一场考试，考试期间注意身体 立个flag，明年$CSP$ 必须400+","categories":[{"name":"随笔","slug":"随笔","permalink":"http://true-banana.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"板子 Dijkstra / SPFA / Floyd","slug":"2020-01-17-板子-Dijkstra--SPFA--Floyd","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:26:46.580Z","comments":true,"path":"2020/01/17/2020-01-17-板子-Dijkstra--SPFA--Floyd/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Dijkstra--SPFA--Floyd/","excerpt":"","text":"Dijkstra（堆优化） 取没有访问过的堆顶 标记为访问过 松弛各边 将未访问过的邻点塞进堆里 1234567891011121314151617181920212223242526272829struct Node &#123; int d, p; bool operator &lt;(const Node &amp;x) const &#123; return x.d &lt; d; &#125;&#125;;priority_queue&lt;Node&gt; q;inline void Dijkstra() &#123; for (int i = 1; i &lt;= n; ++i) d[i] = INF; d[s] = 0; q.push((Node)&#123;0, s&#125;); while (!q.empty()) &#123; Node x = q.top(); q.pop(); if (v[x.p]) continue; v[x.p] = true; for (int i = head[x.p]; i; i = e[i].nxt) &#123; int y = e[i].to; if (d[y] &gt; d[x.p] + e[i].w) &#123; d[y] = d[x.p] + e[i].w; if (!v[y]) q.push((Node)&#123;d[y], y&#125;); &#125; &#125; &#125;&#125; SPFA 取队头 标记为出队 松弛各边 将队外的邻点怼进队里，标记为入队 123456789101112131415161718192021222324queue&lt;int&gt; q;inline void SPFA() &#123; for (int i = 1; i &lt;= n; i++) d[i] = INF; d[s] = 0; q.push(s); vis[s] = true; while (!q.empty()) &#123; int u = q.front(); q.pop(); vis[u] = false; for (int i = head[u], v; i; i = e[i].next) &#123; v = e[i].to; if (d[v] &gt; d[u] + e[i].val) &#123; d[v] = d[u] + e[i].val; if (!vis[v]) &#123; q.push(v); vis[v] = true; &#125; &#125; &#125; &#125;&#125; Floyd$k,i,j$ 1234for (int k = 1; k &lt;= n; ++k) for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= n; ++j) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","permalink":"http://true-banana.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"最短路","slug":"最短路","permalink":"http://true-banana.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF/"}]},{"title":"板子 Splay","slug":"2020-01-17-板子-Splay","date":"2020-01-17T11:19:00.000Z","updated":"2020-02-23T14:03:18.224Z","comments":true,"path":"2020/01/17/2020-01-17-板子-Splay/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Splay/","excerpt":"","text":"members &amp; 初始化每个节点： val 值 size 子树大小 fa 父亲 ch[2] 左/右儿子 cnt 元素个数 123456789101112struct Node &#123; int val, size, fa, ch[2], cnt;&#125;;int tot, root;// 元素总数、根Node tr[N];// 初始化Splay() &#123; tot = root = 0; // 为了后面便于操作，插入一个最大值、最小值 insert(INF), insert(-INF);&#125; 还有一些常用函数： push_up() 更新子树大小 123inline void push_up(int x) &#123; tr[x].size = tr[tr[x].ch[0]].size + tr[tr[x].ch[1]].size + tr[x].cnt;&#125; which() 判断是其父亲的左/右儿子 123inline bool which(int x) &#123; return x == tr[tr[x].fa].ch[1];&#125; BST核心 1p = tr[p].ch[val &gt; tr[p].val]; insert() 插入从root开始走 如果有相同值的点，cnt++ 否则建新点 splay到根 1234567891011121314151617inline void insert(int val) &#123; int p = root, fa = 0; while (p &amp;&amp; tr[p].val != val) fa = p, p = tr[p].ch[val &gt; tr[p].val]; if (p) tr[p].cnt++; else &#123; p = ++tot; tr[p].val = val; tr[p].fa = fa; tr[p].ch[0] = tr[p].ch[1] = 0; tr[p].size = tr[p].cnt = 1; if (fa) tr[fa].ch[val &gt; tr[fa].val] = p; &#125; splay(p);&#125; find() 查找值的位置没有节点直接返回 从根开始走就行，返回的是最接近val的节点 splay到根 12345678inline void find(int val) &#123; if (!root) return; int p = root; while (tr[p].ch[val &gt; tr[p].val] &amp;&amp; val != tr[p].val) p = tr[p].ch[val &gt; tr[p].val]; splay(p);&#125; next() 查找前驱、后继find一下这个值，这个值已经splay到根了 如果根满足，直接返回 否则往大/小走一步，在反方向走到底 1234567891011// opt 0前驱，1后继inline int next(int val, int opt) &#123; find(val); int p = root; if ((!opt &amp;&amp; tr[p].val &lt; val) || (opt &amp;&amp; tr[p].val &gt; val)) return p; p = tr[p].ch[opt]; while (tr[p].ch[opt^1]) p = tr[p].ch[opt^1]; return p;&#125; delete() 删除值找到该值的前驱、后继 splay前驱到根，后继到根的右儿子 后继的左儿子就是该节点 要么cnt--，要么后继的左儿子改为0 123456789inline void del(int val) &#123; int last = next(val, 0), nxt = next(val, 1); splay(last, 0), splay(nxt, last); int x = tr[nxt].ch[0]; if (tr[x].cnt &gt; 1) tr[x].cnt--, splay(x, 0); else tr[nxt].ch[0] = 0;&#125; rotate() 旋转先求出x的父亲、爷爷，以及x的方向 爷爷把我当儿子，我把爷爷当爹 父亲把我另一个儿子当儿子，他也把我父亲当爹 我的父亲当我另一个儿子，父亲把我当爹 更新fa和x的size 1234567inline void rotate(int x) &#123; int fa = tr[x].fa, gfa = tr[fa].fa, w = which(x); tr[gfa].ch[which(fa)] = x, tr[x].fa = gfa; tr[fa].ch[w] = tr[x].ch[w^1], tr[tr[x].ch[w^1]].fa = fa; tr[x].ch[w^1] = fa, tr[fa].fa = x; push_up(fa), push_up(x);&#125; splay() 核心操作如果x的fa不是终点，循环： 如果爷爷也不是终点： 如果x和fa三点共线（方向一致），旋转fa，否则旋转x 再次旋转x 如果旋转到根，更新root 1234567891011inline void splay(int x, int goal = 0) &#123; int fa; while (tr[x].fa != goal) &#123; fa = tr[x].fa; if (tr[fa].fa != goal) which(x) == which(fa) ? rotate(fa) : rotate(x); rotate(x); &#125; if (!goal) root = x;&#125; k_th() 排名为k的值如果从根开始 如果左儿子大小$\\ge x$，走左儿子 如果左儿子大小加上当前点大小$&lt;x$，x减去它，走右儿子 剩下的就返回该点 12345678910111213inline int k_th(int x) &#123; x++;// 树中有个最小值 int p = root; while (1) &#123; int ls = tr[p].ch[0]; if (tr[ls].size &gt;= x) p = ls; else if (tr[ls].size + tr[p].cnt &lt; x) x -= tr[ls].size + tr[p].cnt, p = tr[p].ch[1]; else return tr[p].val; &#125;&#125; rank() 查找x的排名find该值 此时根的左儿子的大小就是排名（减去最小值再加上该点） 1234inline int rank(int val) &#123; find(val); return tr[tr[root].ch[0]].size;&#125; 时刻注意树中有最大值和最小值 luogu P3369 code update on 2020某一天 这个写法很丑很慢，Splay 里面的节点就不要包装了吧 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;namespace BANANA &#123;template &lt;typename T&gt;inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;const int N = 1e5 + 5;const int INF = 0x7fffffff;struct Splay &#123; struct Node &#123; int val, size, fa, ch[2], cnt; &#125;; int tot, root; Node tr[N]; Splay() &#123; tot = root = 0; insert(INF), insert(-INF); &#125; inline void push_up(int x) &#123; tr[x].size = tr[tr[x].ch[0]].size + tr[tr[x].ch[1]].size + tr[x].cnt; &#125; inline bool which(int x) &#123; return x == tr[tr[x].fa].ch[1]; &#125; inline void insert(int val) &#123; int p = root, fa = 0; while (p &amp;&amp; tr[p].val != val) fa = p, p = tr[p].ch[val &gt; tr[p].val]; if (p) tr[p].cnt++; else &#123; p = ++tot; tr[p].val = val; tr[p].fa = fa; tr[p].ch[0] = tr[p].ch[1] = 0; tr[p].size = tr[p].cnt = 1; if (fa) tr[fa].ch[val &gt; tr[fa].val] = p; &#125; splay(p); &#125; inline void del(int val) &#123; int last = next(val, 0), nxt = next(val, 1); splay(last, 0), splay(nxt, last); int x = tr[nxt].ch[0]; if (tr[x].cnt &gt; 1) tr[x].cnt--, splay(x, 0); else tr[nxt].ch[0] = 0; &#125; inline void rotate(int x) &#123; int fa = tr[x].fa, gfa = tr[fa].fa, w = which(x); tr[gfa].ch[which(fa)] = x, tr[x].fa = gfa; tr[fa].ch[w] = tr[x].ch[w^1], tr[tr[x].ch[w^1]].fa = fa; tr[x].ch[w^1] = fa, tr[fa].fa = x; push_up(fa), push_up(x); &#125; inline void splay(int x, int goal = 0) &#123; int fa; while (tr[x].fa != goal) &#123; fa = tr[x].fa; if (tr[fa].fa != goal) which(x) == which(fa) ? rotate(fa) : rotate(x); rotate(x); &#125; if (!goal) root = x; &#125; inline void find(int val) &#123; if (!root) return; int p = root; while (tr[p].ch[val &gt; tr[p].val] &amp;&amp; val != tr[p].val) p = tr[p].ch[val &gt; tr[p].val]; splay(p); &#125; inline int next(int val, int opt) &#123; find(val); int p = root; if ((!opt &amp;&amp; tr[p].val &lt; val) || (opt &amp;&amp; tr[p].val &gt; val)) return p; p = tr[p].ch[opt]; while (tr[p].ch[opt^1]) p = tr[p].ch[opt^1]; return p; &#125; inline int k_th(int x) &#123; x++; int p = root; while (1) &#123; int ls = tr[p].ch[0]; if (tr[ls].size &gt;= x) p = ls; else if (tr[ls].size + tr[p].cnt &lt; x) x -= tr[ls].size + tr[p].cnt, p = tr[p].ch[1]; else return tr[p].val; &#125; &#125; inline int rank(int val) &#123; find(val); return tr[tr[root].ch[0]].size; &#125;&#125;;Splay tree;int n;inline void main() &#123; read(n); int opt, x; for (int i = 1; i &lt;= n; ++i) &#123; read(opt), read(x); switch (opt) &#123; case 1: tree.insert(x); break; case 2: tree.del(x); break; case 3: printf(\"%d\\n\", tree.rank(x)); break; case 4: printf(\"%d\\n\", tree.k_th(x)); break; case 5: printf(\"%d\\n\", tree.tr[tree.next(x, 0)].val); break; case 6: printf(\"%d\\n\", tree.tr[tree.next(x, 1)].val); break; &#125; &#125;&#125;&#125;int main() &#123; BANANA::main(); return 0;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"平衡树","slug":"平衡树","permalink":"http://true-banana.github.io/tags/%E5%B9%B3%E8%A1%A1%E6%A0%91/"}]},{"title":"板子 Tarjan","slug":"2020-01-17-板子-Tarjan","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:25:48.619Z","comments":true,"path":"2020/01/17/2020-01-17-板子-Tarjan/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-Tarjan/","excerpt":"","text":"Tarjan是个好东西 求强连通分量，可以用来缩点等等 123456789101112131415161718192021222324int stack[N], dfn[N], low[N], col[N];bool vis[N];void Tarjan(int u) &#123; dfn[u] = low[u] = ++tot; stack[++top] = u; vis[u] = true; int v; for (int i = head[u]; i; i = e[i].nxt) &#123; v = e[i].to; if (!dfn[v]) Tarjan(v), low[u] = min(low[u], low[v]); else if (vis[v]) low[u] = min(low[u], low[v]); &#125; if (dfn[u] == low[u]) &#123; scc++; do &#123; v = stack[top--]; vis[v] = false; col[v] = scc; &#125; while (v != u); &#125;&#125; 缩点搞出强连通分量后，重新建图，该干啥干啥 P2515 T103252 P2746 割点和求强连通分量不太一样 low[x]表示 $dfs$ 下去最早遇到的割点 当 $v$ 已经访问过时，用 $dfn[v]$ 更新 $low[u]$ （为什么？画两个连环就知道了） 当 $u$ 为根时只要统计子树个数即可 12345678910111213141516171819202122void Tarjan(int u, int rt) &#123; dfn[u] = low[u] = ++tot; int v, ch = 0; for (int i = head[u]; i; i = e[i].nxt) &#123; v = e[i].to; if (!dfn[v]) &#123; Tarjan(v, rt), low[u] = min(low[u], low[v]); if (u != rt &amp;&amp; low[v] &gt;= dfn[u])// 环在u的子树里，u为割点 cut[u] = true; if (u == rt) ch++; &#125; low[u] = min(low[u], dfn[v]);// 注意这里 &#125; if (u == rt &amp;&amp; ch &gt;= 2) cut[u] = true;&#125;// 缩它for (int i = 1; i &lt;= n; ++i) if (!dfn[i]) Tarjan(i, i);// i = rt","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","permalink":"http://true-banana.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"Tarjan","slug":"Tarjan","permalink":"http://true-banana.github.io/tags/Tarjan/"}]},{"title":"板子 kmp","slug":"2020-01-17-板子-kmp","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:27:51.610Z","comments":true,"path":"2020/01/17/2020-01-17-板子-kmp/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-kmp/","excerpt":"","text":"处理b串的nxt[]i从2开始，j从0开始 i和j+1匹配不上，j跳nxt 匹配就j++ nxt[i] = j 1234567for (int i = 2, j = 0; i &lt;= blen; ++i) &#123; while (j &amp;&amp; b[j+1] != b[i]) j = nxt[j]; if (b[j+1] == b[i]) ++j; nxt[i] = j;&#125; kmp匹配i从a的1-len，j从0开始 a[i]和b[j+1]匹配不上就j跳nxt 否则j++ j到blen则匹配完一次，跳nxt 1234567891011for (int i = 1, j = 0; i &lt;= alen; ++i) &#123; while (j &amp;&amp; b[j+1] != a[i]) j = nxt[j]; if (b[j+1] == a[i]) ++j; if (j == blen) &#123; printf(\"%d\\n\", i - blen + 1); ans++; j = nxt[j]; &#125;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"字符串","slug":"字符串","permalink":"http://true-banana.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}],"tags":[{"name":"kmp匹配","slug":"kmp匹配","permalink":"http://true-banana.github.io/tags/kmp%E5%8C%B9%E9%85%8D/"}]},{"title":"板子 倍增LCA","slug":"2020-01-17-板子-倍增LCA","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:25:07.793Z","comments":true,"path":"2020/01/17/2020-01-17-板子-倍增LCA/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%80%8D%E5%A2%9ELCA/","excerpt":"","text":"先$dfs$一遍预处理： $deep[x]$：x的深度 $fa[x][i]$：x的第$2^i$个祖先（倍增数组） 记住fa[x][i] = fa[fa[x][i-1]][i-1] 123456789void dfs(int x, int last) &#123; deep[x] = deep[last] + 1; fa[x][0] = last; for (int i = 1; 1 &lt;&lt; i &lt;= deep[x]; ++i) fa[x][i] = fa[fa[x][i-1]][i-1]; for (int i = head[x]; i; i = e[i].nxt) if (e[i].to != last) dfs(e[i].to, x);&#125; 预处理$log[]$数组，递推一下就好： 12for (int i = 1; i &lt;= n; ++i) lg[i] = lg[i-1] + (1 &lt;&lt; lg[i-1] == i); 求$LCA$ 让深度大的往上跳，直到两点同一深度 然后两个点同时往上跳，直到父亲相同 123456789101112inline int LCA(int a, int b) &#123; if (deep[a] &lt; deep[b]) swap(a, b); while (deep[a] &gt; deep[b]) a = fa[a][lg[deep[a]-deep[b]]-1]; if (a == b) return a; for (int i = lg[deep[a]]; i &gt;= 0; --i) if (fa[a][i] != fa[b][i]) a = fa[a][i], b = fa[b][i]; return fa[a][0];&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"图论","slug":"图论","permalink":"http://true-banana.github.io/categories/%E5%9B%BE%E8%AE%BA/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://true-banana.github.io/tags/LCA/"}]},{"title":"板子 并查集","slug":"2020-01-17-板子-并查集","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:23:00.425Z","comments":true,"path":"2020/01/17/2020-01-17-板子-并查集/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E5%B9%B6%E6%9F%A5%E9%9B%86/","excerpt":"","text":"就这么水一篇博客？？？ 含路径压缩的找father函数 123int find(int x) &#123; return fa[x] == x ? x : fa[x] = find(fa[x]);&#125; 注意提前把father赋为自己！！！ 12for (int i = 1; i &lt;= n; ++i) fa[i] = i; 我太弱了，更nb的操作还不会，555","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://true-banana.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"}]},{"title":"板子 欧拉线性筛","slug":"2020-01-17-板子-欧拉线性筛","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:27:09.901Z","comments":true,"path":"2020/01/17/2020-01-17-板子-欧拉线性筛/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B/","excerpt":"","text":"未访问的是质数 之后从质数表开始 把$i*pri[j]$标为访问过 如果$i$是$pri[j]$的倍数就跳出 1234567891011vector&lt;int&gt; pri;bool vis[N];for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri.push_back(i); for (int j = 0; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123; vis[pri[j]*i] = true; if (i % pri[j] == 0) break; &#125;&#125; 欧拉线性筛$\\varphi(x)$ 12345678910111213for (int i = 2; i &lt;= n; ++i) &#123; if (!tag[i]) pri[++tot] = i, phi[i] = i - 1; for (int j = 1, k; j &lt;= tot &amp;&amp; (k = pri[j] * i) &lt;= n; ++j) &#123; tag[k] = true; if (i % pri[j]) phi[k] = phi[i] * phi[pri[j]]; else &#123; phi[k] = phi[i] * pri[j]; break; &#125; &#125;&#125; 粘过来的线性筛$d(x)$ 123456789101112131415vis[i] = d[1] = 1;for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri.push_back(i), d[i] = 2, a[i] = 1; for (int j = 0; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123; vis[i*pri[j]] = 1; if (i % pri[j]) d[i*pri[j]] = d[i] * d[pri[j]], a[i*pri[j]] = 1; else &#123; d[i*pri[j]] = d[i] / (a[i] + 1) * (a[i] + 2); a[i*pri[j]] = a[i]+1; break; &#125; &#125;&#125;","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"}],"tags":[{"name":"欧拉线性筛","slug":"欧拉线性筛","permalink":"http://true-banana.github.io/tags/%E6%AC%A7%E6%8B%89%E7%BA%BF%E6%80%A7%E7%AD%9B/"}]},{"title":"题解 P1373 【小a和uim之大逃离】","slug":"2020-01-17-题解-P1373-【小a和uim之大逃离】","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:26:32.652Z","comments":true,"path":"2020/01/17/2020-01-17-题解-P1373-【小a和uim之大逃离】/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1373-%E3%80%90%E5%B0%8Fa%E5%92%8Cuim%E4%B9%8B%E5%A4%A7%E9%80%83%E7%A6%BB%E3%80%91/","excerpt":"","text":"题目 奇怪的递推（DP），居然没有自己做出来QAQ 初始思路用f[i][j][x][y]表示取到 点$i,j$时，小a有$x$魔液，uim有$y$魔液，的方案数 显然MLE，且复杂度不优秀，$O(nmk^2)$ 优化表示方式答案要求两人差为零的方案数，所以只考虑两者魔液之差 用f[i][j][x][p]表示表示取到 点$i,j$时，两人之差为$x$，由$p$（小a或uim）取最后一堆的方案数 转移方程123456&#x2F;&#x2F; 小af[i][j][x][0] +&#x3D; f[i-1][j][x-a[i][j]][1]&#x2F;&#x2F; 上边f[i][j][x][0] +&#x3D; f[i][j-1][x-a[i][j]][1]&#x2F;&#x2F; 左边&#x2F;&#x2F; uimf[i][j][x][1] +&#x3D; f[i-1][j][x+a[i][j]][0]f[i][j][x][1] +&#x3D; f[i][j-1][x+a[i][j]][0] 细节注意模的是k+1，所以我一开始k++ 因为只能由小a取第一堆，初始值： 1f[i][j][a[i][j]][0] &#x3D; 1 只能由uim取最后一堆，答案为： 1ans +&#x3D; f[i][j][0][1] 空间开到f[805][805][20][2]左右，不然容易MLE 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;namespace BANANA &#123;template&lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;typedef long long ll;const int MOD = 1e9 + 7;const int N = 805;int n, m, k;ll ans;int a[N][N], f[N][N][20][2];inline int mod(int x) &#123; return (x + k) % k;&#125;inline void main() &#123; read(n), read(m), read(k); k++; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) &#123; read(a[i][j]), a[i][j] %= k; f[i][j][a[i][j]][0] = 1; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) for (int x = 0; x &lt; k; ++x) &#123; f[i][j][x][0] = (f[i][j][x][0] + f[i-1][j][mod(x-a[i][j])][1] + f[i][j-1][mod(x-a[i][j])][1]) % MOD; f[i][j][x][1] = (f[i][j][x][1] + f[i-1][j][mod(x+a[i][j])][0] + f[i][j-1][mod(x+a[i][j])][0]) % MOD; &#125; for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) (ans += f[i][j][0][1]) %= MOD; printf(\"%lld\\n\", ans);&#125;&#125;int main() &#123; BANANA::main(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"递推DP","slug":"递推DP","permalink":"http://true-banana.github.io/tags/%E9%80%92%E6%8E%A8DP/"}]},{"title":"板子 高斯消元","slug":"2020-01-17-板子-高斯消元","date":"2020-01-17T11:19:00.000Z","updated":"2020-02-06T13:14:09.248Z","comments":true,"path":"2020/01/17/2020-01-17-板子-高斯消元/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E6%9D%BF%E5%AD%90-%E9%AB%98%E6%96%AF%E6%B6%88%E5%85%83/","excerpt":"","text":"我选择的是简单好写的高斯-约旦消法 1.选择一个尚未被选过的未知数作为主元，选择一个包含这个主元的方程。 2.将这个方程主元的系数化为1。 3.通过加减消元，消掉其它方程中的这个未知数。 4.重复以上步骤，直到把所有式子变成形如: a*1+b*0+c*0……=d code: 12345678910111213141516171819202122inline bool Gauss() &#123; for (int i = 1; i &lt;= n; ++i) &#123; // 找到该列的最大值 int mx = i; for (int j = i + 1; j &lt;= n; ++j) if (abs(a[j][i]) &gt; abs(a[mx][i])) mx = j; if (a[mx][i] == 0) return false;// 返回无解 // 交换行 for (int j = i; j &lt;= n + 1; ++j) swap(a[i][j], a[mx][j]); // 加减消元 for (int j = 1; j &lt;= n; ++j)// 注意是1~n if (j != i) &#123; double d = a[j][i] / a[i][i]; for (int k = i + 1; k &lt;= n + 1; ++k) a[j][k] -= a[i][k] * d; &#125; &#125; return true;&#125; 输出解 12for (int i = 1; i &lt;= n; ++i) printf(\"%.2f\\n\", a[i][n+1] / a[i][i]);","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"}],"tags":[{"name":"线性代数","slug":"线性代数","permalink":"http://true-banana.github.io/tags/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0/"}]},{"title":"题解 P1967 【货车运输】","slug":"2020-01-17-题解-P1967-【货车运输】","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:25:35.763Z","comments":true,"path":"2020/01/17/2020-01-17-题解-P1967-【货车运输】/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P1967-%E3%80%90%E8%B4%A7%E8%BD%A6%E8%BF%90%E8%BE%93%E3%80%91/","excerpt":"","text":"题面 因为一些容量小的边不会被经过，考虑先建出最大生成树 题目转化成在树上求两点间路径最小权值 利用$LCA$求最短路径 另外搞一个倍增数组$minn[x][i]$，表示x到第$2^i$个祖先之间路径最小权值 转移：minn[x][i] = min(minn[x][i-1], minn[fa[x][i-1]][i-1]); code123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;namespace BANANA &#123;template&lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;const int N = 1e4 + 5;const int M = 5e4 + 5;const int INF = 0x3f3f3f3f;struct Edge_ &#123; int x, y, w; bool operator &lt;(const Edge_ &amp;t) const &#123; return w &gt; t.w;// 从大到小排 &#125;&#125;;struct Edge &#123; int nxt, to, w;&#125;;int n, m, q, cnt;int head[N], col[N], fa[N][30], log[N], deep[N], minn[N][30];bool vis[N];Edge_ e_[M];Edge e[M&lt;&lt;1];inline void add(int u, int v, int w) &#123; e[++cnt] = (Edge)&#123;head[u], v, w&#125;, head[u] = cnt;&#125;inline void swap(int &amp;a, int &amp;b) &#123; int t = a; a = b, b = t;&#125;// 并查集找fatherint find(int x) &#123; return col[x] == x ? x : col[x] = find(col[x]);&#125;// 最大生成树inline void Kruskal() &#123; for (int i = 1; i &lt;= n; ++i) col[i] = i; sort(e_+1, e_+m+1); for (int i = 1; i &lt;= m; ++i) if (find(e_[i].x) != find(e_[i].y)) &#123; col[find(e_[i].x)] = e_[i].y; add(e_[i].x, e_[i].y, e_[i].w), add(e_[i].y, e_[i].x, e_[i].w); &#125;&#125;// LCA预处理void dfs(int x) &#123; vis[x] = true; for (int i = 1; i &lt;= log[deep[x]]; ++i) fa[x][i] = fa[fa[x][i-1]][i-1], minn[x][i] = min(minn[fa[x][i-1]][i-1], minn[x][i-1]); for (int i = head[x], y; i; i = e[i].nxt) &#123; y = e[i].to; if (!vis[y]) &#123; deep[y] = deep[x] + 1, fa[y][0] = x, minn[y][0] = e[i].w; dfs(y); &#125; &#125;&#125;inline int LCA(int x, int y) &#123; if (find(x) != find(y)) return -1; int ans = INF; if (deep[x] &lt; deep[y]) swap(x, y); while (deep[x] &gt; deep[y]) &#123; ans = min(ans, minn[x][log[deep[x]-deep[y]]-1]); x = fa[x][log[deep[x]-deep[y]]-1]; &#125; if (x == y) return ans; for (int i = log[deep[x]]; ~i; --i) if (fa[x][i] != fa[y][i]) &#123; ans = min(ans, min(minn[x][i], minn[y][i])); x = fa[x][i], y = fa[y][i]; &#125; ans = min(ans, min(minn[x][0], minn[y][0])); return ans;// 返回路径上最小值&#125;inline void main() &#123; read(n), read(m); for (int i = 1; i &lt;= m; ++i) read(e_[i].x), read(e_[i].y), read(e_[i].w); Kruskal(); // 递推log数组 for (int i = 1; i &lt;= n; ++i) log[i] = log[i-1] + ((1 &lt;&lt; log[i-1]) == i); // 注意图不一定联通 for (int i = 1; i &lt;= n; ++i) if (!vis[i]) &#123; deep[i] = 1; fa[i][0] = i; minn[i][0] = INF; dfs(i); &#125; read(q); int x, y; for (int i = 1; i &lt;= q; ++i) &#123; read(x), read(y); printf(\"%d\\n\", LCA(x, y)); &#125;&#125;&#125;int main() &#123; BANANA::main(); return 0;&#125;","categories":[{"name":"图论","slug":"图论","permalink":"http://true-banana.github.io/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"LCA","slug":"LCA","permalink":"http://true-banana.github.io/tags/LCA/"},{"name":"倍增","slug":"倍增","permalink":"http://true-banana.github.io/tags/%E5%80%8D%E5%A2%9E/"}]},{"title":"题解 P2279 【[HNOI2003]消防局的设立】","slug":"2020-01-17-题解-P2279-【HNOI2003消防局的设立】","date":"2020-01-17T11:19:00.000Z","updated":"2020-01-20T03:27:34.611Z","comments":true,"path":"2020/01/17/2020-01-17-题解-P2279-【HNOI2003消防局的设立】/","link":"","permalink":"http://true-banana.github.io/2020/01/17/2020-01-17-%E9%A2%98%E8%A7%A3-P2279-%E3%80%90HNOI2003%E6%B6%88%E9%98%B2%E5%B1%80%E7%9A%84%E8%AE%BE%E7%AB%8B%E3%80%91/","excerpt":"","text":"题目 第一道连状态都不会表示的$dp$ 转移方程推到吐。。。 状态表示每一个点$x$都有五个状态： f[x][0]：覆盖到x的爷爷和x整棵子树（向上2层），最少个数 f[x][1]：覆盖到x的父亲和x整棵子树（向上1层），最少个数 f[x][2]：覆盖x整棵子树（向上0层），最少个数 f[x][3]：覆盖所有x的儿子及其子树（向上-1层），最少个数 f[x][4]：覆盖所有x的孙子及其子树（向上-2层），最少个数 f[x][0]：覆盖到x的爷爷和x整棵子树（向上2层），最少个数 f[x][1]：覆盖到x的父亲和x整棵子树（向上1层），最少个数 f[x][2]：覆盖x整棵子树（向上0层），最少个数 f[x][3]：覆盖所有x的儿子及其子树（向上-1层），最少个数 f[x][4]：覆盖所有x的孙子及其子树（向上-2层），最少个数 转移方程y，z是x的儿子 $f[x][0] = 1 + \\sum{f[y][4]}$$f[x][1] = min(f[y][0] + \\sum{(y!=z)f[z][3]})$$f[x][2] = min(f[y][1] + \\sum{(y!=z)f[z][2]})$$f[x][3] = \\sum{f[y][2]}$$f[x][4] = \\sum{f[y][3]}$ 显然f[x][i]一定包含f[x][i+1] 易得f[x][0] &gt;= f[x][1] &gt;= f[x][2] &gt;= f[x][3] &gt;= f[x][4] 所以转移时保证满足条件的前提下尽量选最低层的状态 $f[x][0] = 1 + \\sum{f[y][4]}$ 要覆盖到爷爷的话必须选x，并贪心地选y的第五种状态 $f[x][1] = min(f[y][0] + \\sum{(y!=z)f[z][3]})$ x的儿子中有一个一定覆盖的爷爷，同时覆盖到兄弟（因为y一定是选了），其他的儿子只需要覆盖的自己的儿子即可 $f[x][2] = min(f[y][1] + \\sum{(y!=z)f[z][2]})$ 同理，有一个儿子覆盖到父亲，但无法覆盖到y的兄弟，所以其他儿子要覆盖到自己 $f[x][3] = \\sum{f[y][2]}$ 让每个儿子覆盖到自己即可 $f[x][4] = \\sum{f[y][3]}$ 让每个儿子覆盖到自己的儿子 注意： f[x][i]包含f[x][i+1]，若f[x][i]比f[x][i+1]更优，f[x][i+1]应更新 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;const int N = 1005;struct Edge &#123; int nxt, to;&#125;;int n, cnt;int head[N], f[N][5];Edge e[N&lt;&lt;1];inline void add(int u, int v) &#123; e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;&#125;void dfs(int x, int fa) &#123; // 记录f[y][2], f[y][3]的总和，后面容斥即可 int sum2 = 0, sum3 = 0, y, tot; for (int i = head[x]; i; i = e[i].nxt) if (e[i].to != fa) &#123; y = e[i].to; dfs(y, x); sum2 += f[y][2], sum3 += f[y][3]; tot++; &#125; // 没有儿子特判 if (!tot) &#123; f[x][0] = f[x][1] = f[x][2] = 1; return; &#125; f[x][0] = 1, f[x][1] = f[x][2] = N; for (int i = head[x]; i; i = e[i].nxt) if (e[i].to != fa) &#123; y = e[i].to; f[x][0] += f[y][4]; f[x][1] = min(f[x][1], f[y][0] + sum3 - f[y][3]); f[x][2] = min(f[x][2], f[y][1] + sum2 - f[y][2]); f[x][3] += f[y][2]; f[x][4] += f[y][3]; &#125; // 检查最小值 for (int i = 1; i &lt; 5; ++i) f[x][i] = min(f[x][i], f[x][i-1]);&#125;int main() &#123; read(n); for (int i = 2, x; i &lt;= n; ++i) read(x), add(x, i), add(i, x); dfs(1, 0); printf(\"%d\\n\", f[1][2]);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://true-banana.github.io/tags/%E6%A0%91%E5%BD%A2DP/"}]},{"title":"题解 P2054 【[AHOI2005]洗牌】","slug":"sol_P2054","date":"2019-12-25T13:41:07.000Z","updated":"2020-02-13T23:52:40.902Z","comments":true,"path":"2019/12/25/sol_P2054/","link":"","permalink":"http://true-banana.github.io/2019/12/25/sol_P2054/","excerpt":"","text":"洗牌??? 吐槽一下题目的图片，差点误导了我 这么麻烦的题面当然先模拟啦。。。 打表发现每次洗牌后第 $i$ 张牌会转移到第 $2*i \\%(n+1)$ 的位置上 即在$\\mod{n+1}$意义下，$i$ 和 $2i$ 是同余的 so，可以列出一个同余方程： $i * 2^{m} \\equiv l\\pmod {n+1}$ 再转化为 2 ^ {m} * i + (n+1) * k = l2^{m} * \\frac{i}{l} + (n+1) * \\frac{k}{l} = 1此时利用$exgcd$完美地算出$\\frac{i}{l}$，乘上$l$即可 注意：范围1e10，如果直接乘会gg，要用快速乘，和快速幂差不多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123;// 快读 x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;typedef long long ll;// 开long long// 快速乘inline ll mul(ll a, ll b, ll p) &#123; // 将乘法变为加法，二进制优化，边加边模 ll ans = 0; while (b) &#123; if (b &amp; 1) ans = (ans + a) % p; a = (a + a) % p; b &gt;&gt;= 1; &#125; return ans;&#125;// 快速幂，其实只要写针对2的整次幂就行，这里犯懒。。。inline ll q_pow(ll a, ll b, ll p) &#123; ll ans = 1; while (b) &#123; if (b &amp; 1) ans = mul(ans, a, p) % p; a = mul(a, a, p) % p, b &gt;&gt;= 1; &#125; return ans;&#125;// 标配扩欧void exgcd(ll a, ll b, ll &amp;x, ll &amp;y, ll &amp;g) &#123; if (!b) x = 1, y = 0, g = a; else &#123; exgcd(b, a%b, y, x, g); y -= a / b * x; &#125;&#125;int main() &#123; ll n, m, l, x, y, g, t; read(n), read(m), read(l); t = q_pow(2, m, n+1);// 2的m次幂 exgcd(t, n+1, x, y, g); x = (x % (n+1) + n+1) % (n+1);// 注意exgcd后解可能为负 printf(\"%lld\\n\", mul(x, l, n+1));// 乘上l return 0;&#125;","categories":[{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"},{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://true-banana.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"题解 P2704 【[NOI2001]炮兵阵地】","slug":"sol_P2704","date":"2019-12-25T13:41:07.000Z","updated":"2020-01-20T03:23:20.360Z","comments":true,"path":"2019/12/25/sol_P2704/","link":"","permalink":"http://true-banana.github.io/2019/12/25/sol_P2704/","excerpt":"","text":"题目 珍爱头发，远离状压 首先如果没做过状压的话，出门右转 这道题。。。数据范围很状压 显然，把每一行的地图（有山为1，否则为0）压到一个数里 把枚举的状态压成有炮为1，否则为0 把有解的情况存下来，便于枚举，并预处理每种情况的炮兵个数 现在用$f_{i,j,k}$表示第$i$行是状态$j$，是由状态$k$转移来的，最大的炮兵个数 单独处理第一行和第二行 后面$dp$的时候注意: 如何使一列中的每三行只有一个炮兵？ 保证$k1$ &amp; $k2$, $k2$ &amp; $k3$, $k1$ &amp; $k3$都为0即可（显然） 另外，空间有点。。。建议滚动数组 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;const int M = 1&lt;&lt;11;const int N = 105;int n, m, maxn, ans;int mp[N], f[3][M][M];vector&lt;int&gt; d, v;// 可行状态的对应的炮兵个数char in[15];// 计算每种情况的炮兵个数inline int count(int x) &#123; int re = 0; for (int i = 0; i &lt;= 30; ++i) if (x &amp; (1 &lt;&lt; i)) re++; return re;&#125;int main() &#123; read(n), read(m); maxn = (1 &lt;&lt; m) - 1; for (int i = 0; i &lt; n; ++i) &#123; scanf(\"%s\", in); //处理地图 for (int j = 0; j &lt; m; ++j) if (in[j] == 'H') mp[i] |= 1 &lt;&lt; j; &#125; // 预处理可行状态 for (int i = 0; i &lt;= maxn; ++i) if ((i &amp; (i &gt;&gt; 1)) == 0 &amp;&amp; (i &amp; (i &gt;&gt; 2)) == 0) d.push_back(i), v.push_back(count(i)); // 单独处理一二行 for (int i = 0; i &lt; d.size(); ++i) if ((d[i] &amp; mp[0]) == 0)// 一贯的保证可行 f[0][d[i]][0] = v[i]; for (int i = 0; i &lt; d.size(); ++i) if ((d[i] &amp; mp[1]) == 0) for (int j = 0; j &lt; d.size(); ++j) if ((d[j] &amp; d[i]) == 0) f[1][d[i]][d[j]] = max(f[1][d[i]][d[j]], f[0][d[j]][0] + v[i]); // 愉快的dp for (int i = 2; i &lt; n; ++i)// 行数 for (int j = 0; j &lt; d.size(); ++j)// 该行 if ((d[j] &amp; mp[i]) == 0) for (int k = 0; k &lt; d.size(); ++k)// 上一行 if ((d[k] &amp; d[j]) == 0) for (int l = 0; l &lt; d.size(); ++l)// 上二行 if ((d[l] &amp; d[k]) == 0 &amp;&amp; (d[l] &amp; d[j]) == 0) f[i%3][d[j]][d[k]] = max(f[i%3][d[j]][d[k]], f[(i-1)%3][d[k]][d[l]] + v[j]);// 重点 // 统计最后一行的最大值 for (int i = 0; i &lt; d.size(); ++i) for (int j = 0; j &lt; d.size(); ++j) ans = max(ans, f[(n-1)%3][d[i]][d[j]]); printf(\"%d\\n\", ans);&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"},{"name":"DP","slug":"DP","permalink":"http://true-banana.github.io/categories/DP/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://true-banana.github.io/tags/%E7%8A%B6%E5%8E%8BDP/"}]},{"title":"题解 P3538 【[POI2012]OKR-A Horrible Poem】","slug":"sol_P3538","date":"2019-12-25T13:41:07.000Z","updated":"2020-01-20T03:22:05.929Z","comments":true,"path":"2019/12/25/sol_P3538/","link":"","permalink":"http://true-banana.github.io/2019/12/25/sol_P3538/","excerpt":"","text":"题面 判断字符串循环节最方便的是$hash$ 不会的请出门左转P3370 我们先把字符串$hash$一遍 如图，如果设循环节长度为$3$时，$s1$和$s2$的$hash$值是相等的 所以只需要找最小的$len$使得$hash(l+len,r)=hash(l,r-len)$ 另外，循环节的长度的循环次数都一定是总长的约数 我的做法是把总长除掉循环次数 先把$len$分解质因数 （线性筛质数，并记录下每个数的最小质因子加速分解，这已经是常规操作了） 因为最小循环节的倍数也是循环节 所以从$len$开始试除每个质因子并判断（你可以理解为$len$的因子分为循环节的因子和循环次数的因子，要把循环次数的因子除掉） 具体的看代码吧。。。 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;typedef long long ll;const ll MOD = 1e9 + 7;const int N = 5e5 + 5;int n, m;ll g[N], hash[N], pow[N];// g记录最小质因子，pow存进制的整数次幂char s[N];bool vis[N];vector&lt;ll&gt; pri;// 线性筛inline void euler() &#123; for (ll i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri.push_back(i), g[i] = i; for (int j = 0; j &lt; pri.size() &amp;&amp; pri[j] * i &lt;= n; ++j) &#123; vis[pri[j]*i] = true, g[pri[j]*i] = pri[j]; if (i % pri[j] == 0) break; &#125; &#125;&#125;// 提取hash值inline ll calc(int l, int r) &#123; return ((hash[r] - hash[l-1] * pow[r-l+1]) % MOD + MOD) % MOD;&#125;int main() &#123; read(n); euler(); scanf(\"%s\", s+1); // hash for (int i = 1; i &lt;= n; ++i) hash[i] = (hash[i-1] * 29 + s[i] - 'a' + 1) % MOD; // 预处理整数次幂 pow[0] = 1; for (int i = 1; i &lt;= n; ++i) pow[i] = (pow[i-1] * 29) % MOD; read(m); while (m--) &#123; int l, r, len, ans; read(l), read(r), ans = len = r - l + 1; // 一点点常数优化 if (calc(l+1, r) == calc(l, r-1)) &#123; puts(\"1\"); continue; &#125; // 重点 while (len &gt; 1) &#123; if (calc(l+ans/g[len], r) == calc(l, r-ans/g[len]))// 判断 ans /= g[len];// 除掉循环次数的因子 len /= g[len];//分解 &#125; printf(\"%d\\n\", ans); &#125; return 0;&#125;","categories":[{"name":"字符串","slug":"字符串","permalink":"http://true-banana.github.io/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://true-banana.github.io/tags/%E6%95%B0%E8%AE%BA/"},{"name":"Hash","slug":"Hash","permalink":"http://true-banana.github.io/tags/Hash/"}]},{"title":"题解 P4167 【[Violet]樱花】","slug":"sol_P4167","date":"2019-12-25T13:41:07.000Z","updated":"2020-01-20T03:20:05.607Z","comments":true,"path":"2019/12/25/sol_P4167/","link":"","permalink":"http://true-banana.github.io/2019/12/25/sol_P4167/","excerpt":"","text":"题目描述求不定方程 \\frac{1}{x} + \\frac{1}{y} = \\frac{1}{n!}的正整数解(x,y)的数目。 先开始万恶的推式子。。。 原式： \\frac{1}{x} + \\frac{1}{y} = \\frac{1}{n!}通个分： xy - n!x - n!y= 0补点东西： xy - n!x - n!y + (n!)^2= (n!)^2(n! - x)(n! - y) = (n!)^2此时答案就是$(n!)^2$的约数个数 统计$n!$的约数个数： 把1~n质因数分解，统计各质因子的幂数和即可 再用唯一分解定理统计 注意线性筛素数时记录每一个数的最小质因子，分解就具体看代码 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;vector&gt;using namespace std;template&lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;typedef long long ll;const int N = 1e6 + 5;const int MOD = 1e9 + 7;ll n, ans;int cnt[N], g[N];bool vis[N];vector&lt;int&gt; pri;inline void make_prime() &#123; for (int i = 2; i &lt;= n; ++i) &#123; if (!vis[i]) pri.push_back(i), g[i] = pri.size() - 1; for (int j = 0; j &lt; pri.size() &amp;&amp; i * pri[j] &lt;= n; ++j) &#123; vis[i*pri[j]] = true; g[i*pri[j]] = j; if (i % pri[j] == 0) break; &#125; &#125;&#125;int main() &#123; read(n); make_prime(); for (int i = 2; i &lt;= n; ++i) &#123; int x = i; while (x != 1) cnt[g[x]]++, x /= pri[g[x]]; &#125; ans = 1; for (int i = 0; i &lt;= pri.size(); ++i) if (cnt[i]) ans = (ans * (cnt[i] * 2 + 1)) % MOD; printf(\"%lld\\n\", ans); return 0;&#125;","categories":[{"name":"Math","slug":"Math","permalink":"http://true-banana.github.io/categories/Math/"},{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"数论","slug":"数论","permalink":"http://true-banana.github.io/tags/%E6%95%B0%E8%AE%BA/"}]},{"title":"总结 线段树/树状数组","slug":"总结-线段树树状数组","date":"2019-12-25T13:41:07.000Z","updated":"2020-01-20T03:23:36.646Z","comments":true,"path":"2019/12/25/总结-线段树树状数组/","link":"","permalink":"http://true-banana.github.io/2019/12/25/%E6%80%BB%E7%BB%93-%E7%BA%BF%E6%AE%B5%E6%A0%91%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/","excerpt":"","text":"虽然是总结，但是真的讲不出点啥，贴个板子就溜 毕竟就我自己看 树状数组单点修改，区间查询 123456789101112131415161718#define lowbit(x) (x &amp; -x)inline void update(int x, int k) &#123; for (int i = x; i &lt;= n; i += lowbit(i)) tr[i] += k;&#125;inline int query(int x) &#123; int ans = 0; for (int i = x; i; i -= lowbit(i)) ans += tr[i]; return ans;&#125;// 修改update(x, k)// 查询l到r区间和query(r) - query(l-1) 单点修改，区间查询好像还能CDQ分治 进阶操作：区间修改，单点查询 用树状数组维护差分序列 12345// 区间修改update(l, k)update(r+1, -k)// 单点查询query(x) 线段树区间修改，区间查询 要开4倍空间 每个节点的l，r可以存下来，也可以现算（卡空间的话） 包装起来比较优美 最好动态开点（存$lson$和$rson$），当成二叉堆存也行（比较难调，还丑） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960struct Segtree &#123; struct Leave &#123; int ls, rs, sum, lazy; &#125;; Leave tr[N&lt;&lt;2]; int cnt; int val[N]; inline void push_up(int suc) &#123; tr[suc].sum = tr[tr[suc].ls].sum + tr[tr[suc].rs].sum; &#125; inline void push_down(int suc, int L, int R) &#123; int ls = tr[suc].ls, rs = tr[suc].rs, mid = (L + R) &gt;&gt; 1; tr[ls].lazy += tr[suc].lazy; tr[ls].sum += (mid - L + 1) * tr[suc].lazy; tr[rs].lazy += tr[suc].lazy; tr[rs].sum += (R - mid) * tr[suc].lazy; tr[suc].lazy = 0; &#125; void build(int suc, int L, int R) &#123; tr[suc].lazy = 0; if (L == R) &#123; tr[suc].sum = val[L]; return; &#125; int mid = (L + R) &gt;&gt; 1; tr[suc].ls = ++cnt, tr[suc].rs = ++cnt; build(tr[suc].ls, L, mid), build(tr[suc].rs, mid+1, R); push_up(suc); &#125; void change(int suc, int L, int R, int cl, int cr, int k) &#123; if (cl &lt;= L &amp;&amp; R &lt;= cr) &#123; tr[suc].sum += (R - L + 1) * k; tr[suc].lazy += k; return; &#125; push_down(suc, L, R); int mid = (L + R) &gt;&gt; 1; if (cl &lt;= mid) change(tr[suc].ls, L, mid, cl, cr, k); if (cr &gt; mid) change(tr[suc].rs, mid+1, R, cl, cr, k); push_up(suc); &#125; int query(int suc, int L, int R, int ql, int qr) &#123; if (ql &lt;= L &amp;&amp; R &lt;= qr) return tr[suc].sum; push_down(suc, L, R); int mid = (L + R) &gt;&gt; 1; if (qr &lt;= mid) return query(tr[suc].ls, L, mid, ql, qr); if (ql &gt; mid) return query(tr[suc].rs, mid+1, R, ql, qr); return query(tr[suc].ls, L, mid, ql, qr) + query(tr[suc].rs, mid+1, R, ql, qr); &#125;&#125;; 线段树基本上都套板子，会魔改的只有$push_up()$和$query()$的合并操作 没有lazy tag的暴力修改区间开根SP2713 每个数开方几次就会变成1，暴力修改即可 打tag记录区间是否都为1 区间改成约数CF920F 同上 线段树维护序列操作 基本上都是多了维护前缀答案和后缀答案，从而利于合并 区间最大子段和SPOJ1043 SPOJ1716 记录每个节点的最大子段和，最大前缀，最大后缀，区间和 区间涂色P2894 维护前缀空房数和后缀空房数，同上","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://true-banana.github.io/tags/%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/"},{"name":"线段树","slug":"线段树","permalink":"http://true-banana.github.io/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"}]},{"title":"总结 树链剖分","slug":"总结-树链剖分","date":"2019-12-25T13:41:07.000Z","updated":"2020-01-21T08:01:55.655Z","comments":true,"path":"2019/12/25/总结-树链剖分/","link":"","permalink":"http://true-banana.github.io/2019/12/25/%E6%80%BB%E7%BB%93-%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/","excerpt":"","text":"咕了很久，敲完才体会到什么是“出题人毫无意义地强行把代码增加5KB” 首先，树剖是把一棵树划分成多条轻重链，然后用线段树维护这些链 模板题 通过基础的树剖，可以做以下操作： 将树从x到y最短路径上的权值都加上z 求树从x到y最短路径上的权值和 将以x为根节点的子树内权值都加上z 求将以x为根节点的子树内的权值和 具体做法:dfs1遍历一遍树，求出每个点的： $fa[x]$：父亲 $deep[x]$：深度 $sz[x]$：子树大小 $son[x]$：重儿子 1234567891011121314void dfs1(int x, int last) &#123; fa[x] = last; deep[x] = deep[last] + 1; sz[x] = 1; int y, maxson = -1; for (int i = head[x]; i; i = e[i].nxt) if (e[i].to != last) &#123; y = e[i].to; dfs1(y, x); sz[x] += sz[y]; if (sz[y] &gt; maxson) maxson = sz[y], son[x] = y; &#125;&#125; dfs2第二遍遍历要划分轻重链，先求出： $id[x]$：x的$dfs$序 $top[x]$：x所在链的起始点 注意先走重儿子，再遍历轻儿子，使得重链每个点的$dfs$序一定是连续的 根据$dfs$序的性质，x的子树每个点的$dfs$序也是连续的 因此可以用线段树维护得到的$dfs$序（记得把权值转移到$dfs$序上） 1234567891011void dfs2(int x, int top_) &#123; id[x] = ++cnt; top[x] = top_; segtree.val[id[x]] = val[x];// 转移权值 if (!son[x]) return; dfs2(son[x], top_);// 先重儿子 for (int i = head[x]; i; i = e[i].nxt) if (e[i].to != fa[x] &amp;&amp; e[i].to != son[x]) dfs2(e[i].to, e[i].to);// 轻儿子新开一条链&#125; 线段树直接在$dfs$序上建立线段树，套模板即可 这里就不贴code了 update on 2020.1.21 听学长讲，对于每个链单独开一棵线段树可以减小常数 下面是愉快的各种操作。。。 路径修改/查询对于每个x和y 我们可以不停的让深度大的跳到所在链的顶部，在线段树上直接操作一个链 直到x和y在同一个链上，然后还是线段树操作 （注意，让深度小的往上跳，可能会错过最短路径） 12345678910111213inline void change_road(int x, int y, int k) &#123; if (deep[x] &lt; deep[y]) swap(x, y);// 选深度大的 while (top[x] != top[y]) &#123;// 不在同一条链时 if (deep[top[x]] &lt; deep[top[y]]) swap(x, y);//注意深度 segtree.change(1, 1, n, id[top[x]], id[x], k);// 注意顺序，链顶的id一定大于x的id x = fa[top[x]]; &#125; if (deep[x] &gt; deep[y]) swap(x, y);// 注意顺序 segtree.change(1, 1, n, id[x], id[y], k);&#125; 路径查询同理，就不贴了 话说这里太容易出bug了 QAQ 子树修改/查询因为以x为根的子树在$dfs$序上一定是连续的一段 线段树直接操作$id[x]$到$id[x]+sz[x]-1$的区间 segtree.change(1, 1, n, id[x], id[x]+sz[x]-1, z); 查询同理 LuoguP3384 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;namespace BANANA &#123;template&lt;typename T&gt; inline void read(T &amp;x) &#123; x = 0; T k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) x = x * 10 + in - '0', in = getchar(); x *= k;&#125;const int N = 1e5 + 5;struct Edge &#123; int nxt, to;&#125;;struct Segtree &#123; struct Leave &#123; int ls, rs, sum, lazy; &#125;; Leave tr[N&lt;&lt;2]; int mod, cnt; int val[N]; inline void push_up(int suc) &#123; tr[suc].sum = (tr[tr[suc].ls].sum + tr[tr[suc].rs].sum) % mod; &#125; inline void push_down(int suc, int L, int R) &#123; int ls = tr[suc].ls, rs = tr[suc].rs, mid = (L + R) &gt;&gt; 1; (tr[ls].lazy += tr[suc].lazy) %= mod; (tr[ls].sum += (mid - L + 1) * tr[suc].lazy) %= mod; (tr[rs].lazy += tr[suc].lazy) %= mod; (tr[rs].sum += (R - mid) * tr[suc].lazy) %= mod; tr[suc].lazy = 0; &#125; void build(int suc, int L, int R) &#123; tr[suc].lazy = 0; if (L == R) &#123; tr[suc].sum = val[L]; return; &#125; int mid = (L + R) &gt;&gt; 1; tr[suc].ls = ++cnt, tr[suc].rs = ++cnt; build(tr[suc].ls, L, mid), build(tr[suc].rs, mid+1, R); push_up(suc); &#125; void change(int suc, int L, int R, int cl, int cr, int k) &#123; if (cl &lt;= L &amp;&amp; R &lt;= cr) &#123; (tr[suc].sum += (R - L + 1) * k) %= mod; (tr[suc].lazy += k) %= mod; return; &#125; push_down(suc, L, R); int mid = (L + R) &gt;&gt; 1; if (cl &lt;= mid) change(tr[suc].ls, L, mid, cl, cr, k); if (cr &gt; mid) change(tr[suc].rs, mid+1, R, cl, cr, k); push_up(suc); &#125; int query(int suc, int L, int R, int ql, int qr) &#123; if (ql &lt;= L &amp;&amp; R &lt;= qr) return tr[suc].sum; push_down(suc, L, R); int mid = (L + R) &gt;&gt; 1; if (qr &lt;= mid) return query(tr[suc].ls, L, mid, ql, qr); if (ql &gt; mid) return query(tr[suc].rs, mid+1, R, ql, qr); return (query(tr[suc].ls, L, mid, ql, qr) + query(tr[suc].rs, mid+1, R, ql, qr)) % mod; &#125;&#125;;int n, Q, root, mod, cnt;int head[N], val[N], deep[N], sz[N], fa[N], son[N], top[N], id[N];Edge e[N&lt;&lt;1];Segtree segtree;inline void add(int u, int v) &#123; e[++cnt] = (Edge)&#123;head[u], v&#125;, head[u] = cnt;&#125;inline void swap(int &amp;a, int &amp;b) &#123; int t = a; a = b, b = t;&#125;void dfs1(int x, int last) &#123; fa[x] = last; deep[x] = deep[last] + 1; sz[x] = 1; int y, maxson = -1; for (int i = head[x]; i; i = e[i].nxt) if (e[i].to != last) &#123; y = e[i].to; dfs1(y, x); sz[x] += sz[y]; if (sz[y] &gt; maxson) maxson = sz[y], son[x] = y; &#125;&#125;void dfs2(int x, int top_) &#123; id[x] = ++cnt; top[x] = top_; segtree.val[id[x]] = val[x]; if (!son[x]) return; dfs2(son[x], top_); for (int i = head[x]; i; i = e[i].nxt) if (e[i].to != fa[x] &amp;&amp; e[i].to != son[x]) dfs2(e[i].to, e[i].to);&#125;inline void change_road(int x, int y, int k) &#123; if (deep[x] &lt; deep[y]) swap(x, y); while (top[x] != top[y]) &#123; if (deep[top[x]] &lt; deep[top[y]]) swap(x, y); segtree.change(1, 1, n, id[top[x]], id[x], k); x = fa[top[x]]; &#125; if (deep[x] &gt; deep[y]) swap(x, y); segtree.change(1, 1, n, id[x], id[y], k);&#125;inline int query_road(int x, int y) &#123; if (deep[x] &lt; deep[y]) swap(x, y); int res = 0; while (top[x] != top[y]) &#123; if (deep[top[x]] &lt; deep[top[y]]) swap(x, y); (res += segtree.query(1, 1, n, id[top[x]], id[x])) %= mod; x = fa[top[x]]; &#125; if (deep[x] &gt; deep[y]) swap(x, y); (res += segtree.query(1, 1, n, id[x], id[y])) %= mod; return res;&#125;inline void main() &#123; read(n), read(Q), read(root), read(mod); for (int i = 1; i &lt;= n; ++i) read(val[i]); for (int i = 1, u, v; i &lt; n; ++i) read(u), read(v), add(u, v), add(v, u); dfs1(root, 0); cnt = 0; dfs2(root, root); segtree.mod = mod, segtree.cnt = 1; segtree.build(1, 1, n); int opt, x, y, z; while (Q--) &#123; read(opt); switch (opt) &#123; case 1: read(x), read(y), read(z); change_road(x, y, z); break; case 2: read(x), read(y); printf(\"%d\\n\", query_road(x, y)); break; case 3: read(x), read(y); segtree.change(1, 1, n, id[x], id[x]+sz[x]-1, y); break; case 4: read(x); printf(\"%d\\n\", segtree.query(1, 1, n, id[x], id[x]+sz[x]-1)); break; &#125; &#125;&#125;&#125;int main() &#123; BANANA::main(); return 0;&#125; 第一次写的时候太艰辛了，调了半天发现是$swap()$写错了$qwq$","categories":[{"name":"总结","slug":"总结","permalink":"http://true-banana.github.io/categories/%E6%80%BB%E7%BB%93/"},{"name":"数据结构","slug":"数据结构","permalink":"http://true-banana.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"树链剖分","slug":"树链剖分","permalink":"http://true-banana.github.io/tags/%E6%A0%91%E9%93%BE%E5%89%96%E5%88%86/"}]},{"title":"通过namespace防止命名冲突","slug":"通过namespace防止命名冲突","date":"2019-12-25T13:41:07.000Z","updated":"2020-04-07T13:05:21.712Z","comments":true,"path":"2019/12/25/通过namespace防止命名冲突/","link":"","permalink":"http://true-banana.github.io/2019/12/25/%E9%80%9A%E8%BF%87namespace%E9%98%B2%E6%AD%A2%E5%91%BD%E5%90%8D%E5%86%B2%E7%AA%81/","excerpt":"","text":"不止一位学长讲述过一些选手因为”next””pipe”而暴毙的英雄事迹。。。 那么Linux下如何防止命名冲突？ 或者仅仅是因为懒得想变量名 听过学长的指导后，本文全程口糊，有不恰当处还请指出 C++中有了命名空间这个东西，不同命名空间的元素可以同名 你平时写的using namespace std;就是代替了每次调用时的std::，相当于把std作为此程序的命名空间 我们可以创建自己的命名空间 123namespace NAME &#123;// NAME可以是你自己取的名字 // code...&#125; 里面的程序正常写就行 不过C++的运行端口是::main，所以main函数写在namespace里会找不到端口，无法运行 只把main写在外面？这辈子都不会的 为了程序的优美性，可以namespace里写一个main，外面调用即可 123456789namespace BANANA &#123; inline void main() &#123;// inline是一点优化，自己百度。因为没必要必须返回0，可以是void // code &#125;&#125;int main() &#123; BANANA::main();// 和std同理，通过BANANA::调用就没有冲突 return 0;&#125; 这样的话写一大堆函数和全局变量的时候，main函数依然优美 总之自己看着舒服就行 另外，namespace是可以嵌套的，并且优先级是本层namespace &gt; 外层namespace 调用时本层找不到就会从上一层找 于是我们照样写using namespace std，不受影响，太棒了不用写烦人的std 12345678910111213141516171819#include &lt;iostream&gt;using namespace std;namespace BANANA &#123; int a = 1; namespace OI &#123; int a = 5; inline void sell() &#123; cout &lt;&lt;\"兜售小main包烤绿鸟\" &lt;&lt; endl;// cout照样用 &#125; &#125; inline void main() &#123; cout &lt;&lt; a &lt;&lt; endl;// 这里的a = 1 OI::sell();// 调用其他namespace的元素同理 &#125;&#125;int main() &#123; BANANA::main(); return 0;&#125; 好了你还怕什么？ 不过学长实测，如果你起linux,unix的变量名，还是会翻车，他们太硬了 不过你可以随心所欲地打万能头了。。。 12345678910111213#include &lt;bits/stdc++.h&gt;using namespace std;namespace BANANA &#123; int x1, x2, y1, y2; long long pipe, next[105]; inline void main() &#123; cout &lt;&lt; \"小main包烤绿鸟还有人要么！！！\" &lt;&lt; endl; &#125;&#125;int main() &#123; BANANA::main(); return 0;&#125; 祝大家敲代码愉快~","categories":[{"name":"随笔","slug":"随笔","permalink":"http://true-banana.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[]},{"title":"题解 P1322 【logo语言】","slug":"sol_P1322","date":"2019-12-24T13:41:00.000Z","updated":"2020-01-20T03:29:59.286Z","comments":true,"path":"2019/12/24/sol_P1322/","link":"","permalink":"http://true-banana.github.io/2019/12/24/sol_P1322/","excerpt":"","text":"这里是栈的做法 递归快写吐了，决心用栈，结果调了半天。。。 应该都能想到，FD就加，BF就减，REPEAT就压栈，’]’就弹栈 手写栈比较舒服，用STL的stack有点丑 细节太重要了 敲的时候应该注意：读入是否从有效字符开始（用char[]的注意）、’]’的读入、用过的那层栈要清空。。。 都是废话，自己写写就知道了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;string&gt;#include &lt;iostream&gt;#include &lt;cmath&gt;using namespace std;namespace BANANA &#123;//防止命名冲突inline int read() &#123;// 快读 int re = 0, k = 1; char in = getchar(); while (!isdigit(in)) &#123; if (in == '-') k = -1; in = getchar(); &#125; while (isdigit(in)) re = re * 10 + in - '0', in = getchar(); return re * k;&#125;int stack[305], k[305];// stack：栈，k：这一层栈repeat的次数string s;int num(string s) &#123;// 把s串开头的数字提出来 int ans = 0; for (int i = 0; isdigit(s[i]); i++) ans = ans * 10 + s[i] - '0'; return ans;&#125;inline void main() &#123; int top = 1; while (cin &gt;&gt; s) &#123;// ctrl+z结束 if (s[0] == 'F') &#123; cin &gt;&gt; s; stack[top] += num(s); int len = s.size() - 1; while (s[len] == ']')// 结尾有']'要退栈 stack[top-1] += k[top-1] * stack[top], top--, len--; &#125; else if (s[0] == 'B') &#123; cin &gt;&gt; s; stack[top] -= num(s); int len = s.size() - 1; while (s[len] == ']') stack[top-1] += k[top-1] * stack[top], top--, len--; &#125; else if (s[0] == 'R') &#123; k[top] = read(); top++; stack[top] = 0;// 用之前清空（之前因为这个WA了 &#125; else &#123; // 特判\"[]\"里什么都没有的 int i = 0;// 前面已经读入了'['，所以从0开始 while (s[i] == ']' &amp;&amp; i &lt; s.size()) stack[top-1] += k[top-1] * stack[top], top--, i++; &#125; &#125; printf(\"%d\\n\", abs(stack[1]));// 注意是距离（绝对值）&#125;&#125;int main() &#123; BANANA::main(); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://true-banana.github.io/categories/%E9%A2%98%E8%A7%A3/"}],"tags":[{"name":"栈","slug":"栈","permalink":"http://true-banana.github.io/tags/%E6%A0%88/"}]}]}